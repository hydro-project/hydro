# Graph Neighbors
> In this example we cover:
> * Our first multi-input operator, [`join`](./surface_ops.gen.md#join)
> * The [`unique`](./surface_ops.gen.md#unique) operator for removing duplicates from a stream
> * A first exposure to the concepts of _strata_ and _epochs_

So far all the operators we've used have one input and one output and therefore
create a linear flow of operators. Let's now take a look at a Hydroflow program containing
an operator which has multiple inputs; in the following examples we'll extend this to
multiple outputs.

To motivate this, we'll build a simple flow-based algorithm for the problem of *graph neighbors*. 
Given an abstract graph -- represented as data in the form of a streaming list of edges -- which 
vertices can be reached from a vertex passed in as the `origin`? It turns out this is fairly 
naturally represented as a dataflow program. 

> **Note on terminology**: In each of the next few examples, we're going to write a Hydroflow program (a dataflow graph) to process data that itself represents some other graph! To avoid confusion, in these examples, we'll refer to the Hydroflow program as a "flow" or "program", and the data as a "graph" of "edges" and "vertices".

To work our way up to graph reachability, we'll first start with a simple flow that finds
graph *neighbors*: vertices that are just one hop away. 

Our first Hydroflow program will take
our initial `origin` vertex as one input, and join it another input that streams in all the edges---this 
join will stream out the vertices that are one hop (edge) away from the starting vertex. 

Here is an *intuitive* diagram of that dataflow program (we'll see complete, autogenerated Hydroflow diagrams
below):
```mermaid
graph TD
  subgraph sources
    01[Stream of Edges]
  end
  subgraph neighbors of origin
    00[Origin Vertex]
    20("V ⨝ E")
    40[Output]

    00 --> 20
    
    01 ---> 20
    20 --> 40
    
  end
```

Lets take a look at some Hydroflow code that implements the program:

```rust
# use hydroflow::hydroflow_syntax;
pub fn main() {
    // An edge in the input data = a pair of `usize` vertex IDs.
    let (pairs_send, pairs_recv) = hydroflow::util::unbounded_channel::<(usize, usize)>();

    let mut flow = hydroflow_syntax! {
        // inputs: the origin vertex (vertex 0) and stream of input edges
        origin = source_iter(vec![0]);
        stream_of_edges = source_stream(pairs_recv);

        // the join
        my_join = join() -> flat_map(|(src, (_, dst))| [src, dst]);
        origin -> map(|v| (v, ())) -> [0]my_join;
        stream_of_edges -> [1]my_join;

        // the output
        my_join -> unique() -> for_each(|n| println!("Reached: {}", n));
    };

    println!(
        "{}",
        flow.serde_graph()
            .expect("No graph found, maybe failed to parse.")
            .to_mermaid()
    );
    pairs_send.send((0, 1)).unwrap();
    pairs_send.send((2, 4)).unwrap();
    pairs_send.send((3, 4)).unwrap();
    pairs_send.send((1, 2)).unwrap();
    pairs_send.send((0, 3)).unwrap();
    pairs_send.send((0, 3)).unwrap();
    flow.run_available();
}
```

And the output:
```txt
Reached: 0
Reached: 3
Reached: 1
```
That looks right: the edges we "sent" into the flow that start at `0` are 
`(0, 1)` and `(0, 3)`.

As for the code itself, we start out with the origin vertex, `0`,
and the stream of edges coming in:
```rust,ignore
    origin = source_iter(vec![0]);
    stream_of_edges = source_stream(pairs_recv);
```
The Rust syntax `vec![0]` constructs a vector with a single element, `0`, which we iterate
over using `source_iter`.

We then set up a [`join()`](./surface_ops.gen.md#join) that we
name `my_join`, which acts like a SQL inner join. 
First, note the syntax for passing data into a subflow with multiple inputs requires us to *prepend* 
an input index (starting at `0`) in square brackets to the multi-input variable name or operator.  In this example we have `-> [0]my_join`
and `-> [1]my_join`.

Hydroflow's `join()` API requires
a little massaging of its inputs to work properly.
The inputs must be of the form of a pair of elements `(K, V1)`
and `(K, V2)`, and the operator joins them on equal keys `K` and produces an
output of `(K, (V1, V2))` elements. In this case we only want to join on the key `v` and
don't have any corresponding value, so we feed `origin` through a [`map()`](./surface_ops.gen.md#map)
to generate `(v, ())` elements as the first join input. 
```rust,ignore
    my_join = join() -> map(|(_x, (_y, z))| z);
    origin -> map(|v| (v, ())) -> [0]my_join;
    stream_of_edges -> [1]my_join;
```
The `stream_of_edges` are `(src, dst)` pairs,
so the join's output is `(src, ((), dst))` where `dst` are new neighbor
vertices. So the `my_join` variable feeds the output of the join through a `flat_map` to extract the pairs into 2-item arrays, which are flattened to give us a list of all vertices reached.
Finally we print the neighbor vertices as follows:
```rust,ignore
    my_join -> unique() -> for_each(|n| println!("Reached: {}", n));
```
The [unique](./surface_ops.gen.md#unique) operator removes duplicates from the stream to make things more readable. Note that `unique` does not run in a streaming fashion, which we will talk about more [below](#strata-and-epochs).

The remaining code runs the graph on example edge data. There's
also some extra code there, particularly `flow.serde_graph().expect(...).to_mermaid()` which lets us
generate a diagram rendered by [Mermaid](https://mermaid-js.github.io/) showing
the structure of the graph:

```mermaid
flowchart TB
    subgraph "sg_1v1 stratum 0"
        1v1["1v1 <tt>op_1v1: source_iter(vec! [0])</tt>"]
        2v1["2v1 <tt>op_2v1: source_stream(pairs_recv)</tt>"]
        5v1["5v1 <tt>op_5v1: map(| v | (v, ()))</tt>"]
        3v1["3v1 <tt>op_3v1: join()</tt>"]
        4v1["4v1 <tt>op_4v1: flat_map(| (src, (_, dst)) | [src, dst])</tt>"]
    end
    subgraph "sg_2v1 stratum 1"
        6v1["6v1 <tt>op_6v1: unique()</tt>"]
        7v1["7v1 <tt>op_7v1: for_each(| n | println! (&quot;Reached: {}&quot;, n))</tt>"]
    end

    8v1{"handoff"}

    1v1-->5v1
    2v1-->3v1
    3v1-->4v1
    4v1-->8v1
    5v1-->3v1
    6v1-->7v1
    8v1-->6v1
```

Returning to the code, if you read the `pairs_send` calls carefully, you'll see that the example data 
has vertices (`2`, `4`) that are more than one hop away from `0`, which were
not output by our simple program. To extend this example to graph *reachability*, 
we need to recurse: find neighbors of our neighbors, neighbors of our neighbors' neighbors, and so on. In Hydroflow,
this is done by adding a loop to the flow, as we'll see in our [next example](example_5_surface.md).
## Strata and Epochs
Before we proceed, note in the mermaid graph how Hydroflow separates the `unique` operator and its downstream dependencies into their own
_stratum_ (plural: _strata_). The stratum boundary before `unique` ensures that all the values arrive before it executes, ensuring that all duplicates are eliminated. 

Hydroflow runs each stratum
in order, one at a time, ensuring all values are computed
before moving on to the next stratum. Between strata we see a _handoff_, which logically buffers the 
output of the first stratum, and delineates the separation of execution between the 2 strata.

After all strata are run, Hydroflow returns to the first stratum; this begins the next _epoch_. This doesn't really matter for this example, but it is important for long-running Hydroflow services that accept input from the outside world.
