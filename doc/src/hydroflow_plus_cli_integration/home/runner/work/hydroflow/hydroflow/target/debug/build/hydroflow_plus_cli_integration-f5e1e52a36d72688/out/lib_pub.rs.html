<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/hydroflow/hydroflow/target/debug/build/hydroflow_plus_cli_integration-f5e1e52a36d72688/out/lib_pub.rs`."><title>lib_pub.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-fecee23daa4e8a6d.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="hydroflow_plus_cli_integration" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0-nightly (4ac7bcbaa 2024-09-04)" data-channel="nightly" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../../../../../../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../../../../../../../../../../../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
</pre></div><pre class="rust"><code><span class="kw">pub mod </span>runtime { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>hydroflow_plus :: location :: { Cluster , ClusterSpec , Deploy , HfSendManyToMany , HfSendManyToOne , HfSendOneToMany , HfSendOneToOne , Location , ProcessSpec , } ; <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: { ConnectedDemux , ConnectedDirect , ConnectedSink , ConnectedSource , ConnectedTagged , HydroCLI , } ; <span class="kw">pub use </span>stageleft :: { q , Quoted , RuntimeData } ; <span class="kw">pub use super </span>:: HydroflowPlusMeta ; <span class="kw">pub use crate </span>:: runtime :: CLIRuntime ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Deploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>CLIRuntime { <span class="kw">type </span>ClusterId = u32 ; <span class="kw">type </span>Process = CLIRuntimeNode &lt; <span class="lifetime">'a </span>&gt; ; <span class="kw">type </span>Cluster = CLIRuntimeCluster &lt; <span class="lifetime">'a </span>&gt; ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = usize ; <span class="kw">type </span>ProcessPort = String ; <span class="kw">type </span>ClusterPort = String ; } <span class="kw">pub use crate </span>:: runtime :: CLIRuntimeNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Location <span class="kw">for </span>CLIRuntimeNode &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">type </span>Port = String ; <span class="kw">type </span>Meta = () ; <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; usize { <span class="self">self </span>. id } <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; String { <span class="kw">let </span>next_send_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; format ! (<span class="string">"port_{}" </span>, next_send_port) } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } } <span class="kw">pub use crate </span>:: runtime :: CLIRuntimeCluster ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Location <span class="kw">for </span>CLIRuntimeCluster &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">type </span>Port = String ; <span class="kw">type </span>Meta = () ; <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; usize { <span class="self">self </span>. id } <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; String { <span class="kw">let </span>next_send_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; format ! (<span class="string">"port_{}" </span>, next_send_port) } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Cluster &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>CLIRuntimeCluster &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">type </span>Id = u32 ; <span class="kw">fn </span>ids (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; u32 &gt; &gt; + Copy + <span class="lifetime">'a </span>{ <span class="kw">let </span>cli = <span class="self">self </span>. cli ; <span class="kw">let </span>self_id = <span class="self">self </span>. id ; q ! (cli . meta . clusters . get (&amp; self_id) . unwrap ()) } <span class="kw">fn </span>self_id (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, u32 &gt; + Copy + <span class="lifetime">'a </span>{ <span class="kw">let </span>cli = <span class="self">self </span>. cli ; q ! (cli . meta . cluster_id . expect (<span class="string">"Tried to read Cluster ID on a non-cluster node"</span>)) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; HfSendOneToOne &lt; CLIRuntimeNode &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>CLIRuntimeNode &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, _other : &amp; CLIRuntimeNode , _source_port : &amp; String , _recipient_port : &amp; String) { } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, port : &amp; String) -&gt; syn :: Expr { <span class="kw">let </span>self_cli = <span class="self">self </span>. cli ; <span class="kw">let </span>port = port . as_str () ; q ! ({ self_cli . port (port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_sink () }) . splice () } <span class="kw">fn </span>gen_source_statement (other : &amp; CLIRuntimeNode &lt; <span class="lifetime">'a </span>&gt; , port : &amp; String) -&gt; syn :: Expr { <span class="kw">let </span>self_cli = other . cli ; <span class="kw">let </span>port = port . as_str () ; q ! ({ self_cli . port (port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_source () }) . splice () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; HfSendManyToOne &lt; CLIRuntimeNode &lt; <span class="lifetime">'a </span>&gt; , u32 &gt; <span class="kw">for </span>CLIRuntimeCluster &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, _other : &amp; CLIRuntimeNode , _source_port : &amp; String , _recipient_port : &amp; String) { } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, port : &amp; String) -&gt; syn :: Expr { <span class="kw">let </span>self_cli = <span class="self">self </span>. cli ; <span class="kw">let </span>port = port . as_str () ; q ! ({ self_cli . port (port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_sink () }) . splice () } <span class="kw">fn </span>gen_source_statement (other : &amp; CLIRuntimeNode &lt; <span class="lifetime">'a </span>&gt; , port : &amp; String) -&gt; syn :: Expr { <span class="kw">let </span>self_cli = other . cli ; <span class="kw">let </span>port = port . as_str () ; q ! ({ self_cli . port (port) . connect_local_blocking ::&lt; ConnectedTagged &lt; ConnectedDirect &gt;&gt; () . into_source () }) . splice () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; HfSendOneToMany &lt; CLIRuntimeCluster &lt; <span class="lifetime">'a </span>&gt; , u32 &gt; <span class="kw">for </span>CLIRuntimeNode &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, _other : &amp; CLIRuntimeCluster , _source_port : &amp; String , _recipient_port : &amp; String) { } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, port : &amp; String) -&gt; syn :: Expr { <span class="kw">let </span>self_cli = <span class="self">self </span>. cli ; <span class="kw">let </span>port = port . as_str () ; q ! ({ self_cli . port (port) . connect_local_blocking ::&lt; ConnectedDemux &lt; ConnectedDirect &gt;&gt; () . into_sink () }) . splice () } <span class="kw">fn </span>gen_source_statement (other : &amp; CLIRuntimeCluster &lt; <span class="lifetime">'a </span>&gt; , port : &amp; String) -&gt; syn :: Expr { <span class="kw">let </span>self_cli = other . cli ; <span class="kw">let </span>port = port . as_str () ; q ! ({ self_cli . port (port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_source () }) . splice () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; HfSendManyToMany &lt; CLIRuntimeCluster &lt; <span class="lifetime">'a </span>&gt; , u32 &gt; <span class="kw">for </span>CLIRuntimeCluster &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, _other : &amp; CLIRuntimeCluster , _source_port : &amp; String , _recipient_port : &amp; String) { } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, port : &amp; String) -&gt; syn :: Expr { <span class="kw">let </span>self_cli = <span class="self">self </span>. cli ; <span class="kw">let </span>port = port . as_str () ; q ! ({ self_cli . port (port) . connect_local_blocking ::&lt; ConnectedDemux &lt; ConnectedDirect &gt;&gt; () . into_sink () }) . splice () } <span class="kw">fn </span>gen_source_statement (other : &amp; CLIRuntimeCluster &lt; <span class="lifetime">'a </span>&gt; , port : &amp; String) -&gt; syn :: Expr { <span class="kw">let </span>self_cli = other . cli ; <span class="kw">let </span>port = port . as_str () ; q ! ({ self_cli . port (port) . connect_local_blocking ::&lt; ConnectedTagged &lt; ConnectedDirect &gt;&gt; () . into_source () }) . splice () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'cli </span>&gt; ProcessSpec &lt; <span class="lifetime">'cli </span>, CLIRuntime &gt; <span class="kw">for </span>RuntimeData &lt; &amp; <span class="lifetime">'cli </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; { <span class="kw">fn </span>build (&amp; <span class="self">self </span>, id : usize , _meta : &amp; <span class="kw-2">mut </span>()) -&gt; CLIRuntimeNode &lt; <span class="lifetime">'cli </span>&gt; { CLIRuntimeNode { id , next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , cli : * <span class="self">self </span>, } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'cli </span>&gt; ClusterSpec &lt; <span class="lifetime">'cli </span>, CLIRuntime &gt; <span class="kw">for </span>RuntimeData &lt; &amp; <span class="lifetime">'cli </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; { <span class="kw">fn </span>build (&amp; <span class="self">self </span>, id : usize , _meta : &amp; <span class="kw-2">mut </span>()) -&gt; CLIRuntimeCluster &lt; <span class="lifetime">'cli </span>&gt; { CLIRuntimeCluster { id , next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , cli : * <span class="self">self </span>, } } } } <span class="kw">pub use </span>std :: collections :: HashMap ; <span class="kw">pub use </span>runtime :: * ; # [cfg (feature = <span class="string">"deploy"</span>)] <span class="kw">pub mod </span>deploy { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: HashMap ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>std :: sync :: Arc ; <span class="kw">pub use </span>hydro_deploy :: custom_service :: CustomClientPort ; <span class="kw">pub use </span>hydro_deploy :: hydroflow_crate :: ports :: { DemuxSink , HydroflowSink , HydroflowSource , TaggedSource , } ; <span class="kw">pub use </span>hydro_deploy :: hydroflow_crate :: HydroflowCrateService ; <span class="kw">pub use </span>hydro_deploy :: { Deployment , Host } ; <span class="kw">pub use </span>hydroflow_plus :: location :: { Cluster , ClusterSpec , Deploy , HfSendManyToMany , HfSendManyToOne , HfSendOneToMany , HfSendOneToOne , Location , ProcessSpec , } ; <span class="kw">pub use </span>stageleft :: internal :: syn :: parse_quote ; <span class="kw">pub use </span>stageleft :: q ; <span class="kw">pub use </span>tokio :: sync :: RwLock ; <span class="kw">pub use super </span>:: HydroflowPlusMeta ; <span class="kw">pub use crate </span>:: deploy :: HydroDeploy ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Deploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>HydroDeploy { <span class="kw">type </span>ClusterId = u32 ; <span class="kw">type </span>Process = DeployNode ; <span class="kw">type </span>Cluster = DeployCluster ; <span class="kw">type </span>Meta = HashMap &lt; usize , Vec &lt; u32 &gt; &gt; ; <span class="kw">type </span>GraphId = () ; <span class="kw">type </span>ProcessPort = DeployPort &lt; DeployNode &gt; ; <span class="kw">type </span>ClusterPort = DeployPort &lt; DeployCluster &gt; ; } <span class="kw">pub use crate </span>:: deploy :: DeployCrateWrapper ; <span class="kw">pub use crate </span>:: deploy :: DeployNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployCrateWrapper <span class="kw">for </span>DeployNode { <span class="kw">fn </span>underlying (&amp; <span class="self">self</span>) -&gt; Arc &lt; RwLock &lt; HydroflowCrateService &gt; &gt; { <span class="self">self </span>. underlying . clone () } } <span class="kw">pub use crate </span>:: deploy :: DeployPort ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployPort &lt; DeployNode &gt; { <span class="kw">pub async fn </span>create_sender (&amp; <span class="self">self </span>, deployment : &amp; <span class="kw-2">mut </span>Deployment , on : &amp; Arc &lt; <span class="kw">impl </span>Host + <span class="lifetime">'static </span>&gt; ,) -&gt; CustomClientPort { <span class="self">self </span>. node . create_sender (&amp; <span class="self">self </span>. port , deployment , on) . <span class="kw">await </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployPort &lt; DeployCluster &gt; { <span class="kw">pub async fn </span>create_senders (&amp; <span class="self">self </span>, deployment : &amp; <span class="kw-2">mut </span>Deployment , on : &amp; Arc &lt; <span class="kw">impl </span>Host + <span class="lifetime">'static </span>&gt; ,) -&gt; Vec &lt; CustomClientPort &gt; { <span class="kw">let </span><span class="kw-2">mut </span>out = vec ! [] ; <span class="kw">for </span>member <span class="kw">in </span>&amp; <span class="self">self </span>. node . members { out . push (member . create_sender (&amp; <span class="self">self </span>. port , deployment , on) . <span class="kw">await</span>) ; } out } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Location <span class="kw">for </span>DeployNode { <span class="kw">type </span>Port = DeployPort &lt; <span class="self">Self </span>&gt; ; <span class="kw">type </span>Meta = HashMap &lt; usize , Vec &lt; u32 &gt; &gt; ; <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; usize { <span class="self">self </span>. id } <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; DeployPort &lt; <span class="self">Self </span>&gt; { <span class="kw">let </span>next_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; DeployPort { node : <span class="self">self </span>. clone () , port : format ! (<span class="string">"port_{}" </span>, next_port) , } } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, meta : &amp; <span class="self">Self </span>:: Meta) { <span class="kw">let </span><span class="kw-2">mut </span>n = <span class="self">self </span>. underlying . try_write () . unwrap () ; n . update_meta (HydroflowPlusMeta { clusters : meta . clone () , cluster_id : <span class="prelude-val">None </span>, subgraph_id : <span class="self">self </span>. id , }) ; } } <span class="kw">pub use crate </span>:: deploy :: DeployClusterNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployCrateWrapper <span class="kw">for </span>DeployClusterNode { <span class="kw">fn </span>underlying (&amp; <span class="self">self</span>) -&gt; Arc &lt; RwLock &lt; HydroflowCrateService &gt; &gt; { <span class="self">self </span>. underlying . clone () } } <span class="kw">pub use crate </span>:: deploy :: DeployCluster ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Location <span class="kw">for </span>DeployCluster { <span class="kw">type </span>Port = DeployPort &lt; <span class="self">Self </span>&gt; ; <span class="kw">type </span>Meta = HashMap &lt; usize , Vec &lt; u32 &gt; &gt; ; <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; usize { <span class="self">self </span>. id } <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; DeployPort &lt; <span class="self">Self </span>&gt; { <span class="kw">let </span>next_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; DeployPort { node : <span class="self">self </span>. clone () , port : format ! (<span class="string">"port_{}" </span>, next_port) , } } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, meta : &amp; <span class="self">Self </span>:: Meta) { <span class="self">self </span>. members . iter () . enumerate () . for_each (| (cluster_id , n) | { <span class="kw">let </span><span class="kw-2">mut </span>n = n . underlying . try_write () . unwrap () ; n . update_meta (&amp; HydroflowPlusMeta { clusters : meta . clone () , cluster_id : <span class="prelude-val">Some </span>(cluster_id <span class="kw">as </span>u32) , subgraph_id : <span class="self">self </span>. id , }) ; }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Cluster &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>DeployCluster { <span class="kw">type </span>Id = u32 ; <span class="kw">fn </span>ids (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>stageleft :: Quoted &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; u32 &gt; &gt; + Copy + <span class="lifetime">'a </span>{ q ! (panic ! ()) } <span class="kw">fn </span>self_id (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>stageleft :: Quoted &lt; <span class="lifetime">'a </span>, <span class="self">Self </span>:: Id &gt; + Copy + <span class="lifetime">'a </span>{ q ! (panic ! ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>HfSendOneToOne &lt; DeployNode &gt; <span class="kw">for </span>DeployNode { <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, other : &amp; DeployNode , source_port : &amp; DeployPort &lt; DeployNode &gt; , recipient_port : &amp; DeployPort &lt; DeployNode &gt; ,) { <span class="kw">let </span>source_port = <span class="self">self </span>. underlying . try_read () . unwrap () . get_port (source_port . port . clone () , &amp; <span class="self">self </span>. underlying) ; <span class="kw">let </span>recipient_port = other . underlying . try_read () . unwrap () . get_port (recipient_port . port . clone () , &amp; other . underlying) ; source_port . send_to (&amp; recipient_port) ; } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, _port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { parse_quote ! (null) } <span class="kw">fn </span>gen_source_statement (_other : &amp; DeployNode , _port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { parse_quote ! (null) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>HfSendManyToOne &lt; DeployNode , u32 &gt; <span class="kw">for </span>DeployCluster { <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, other : &amp; DeployNode , source_port : &amp; DeployPort &lt; DeployCluster &gt; , recipient_port : &amp; DeployPort &lt; DeployNode &gt; ,) { <span class="kw">let </span>recipient_port = other . underlying . try_read () . unwrap () . get_port (recipient_port . port . clone () , &amp; other . underlying) . merge () ; <span class="kw">for </span>(i , node) <span class="kw">in </span><span class="self">self </span>. members . iter () . enumerate () { <span class="kw">let </span>source_port = node . underlying . try_read () . unwrap () . get_port (source_port . port . clone () , &amp; node . underlying) ; TaggedSource { source : Arc :: new (source_port) , tag : i <span class="kw">as </span>u32 , } . send_to (&amp; recipient_port) ; } } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, _port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { parse_quote ! (null) } <span class="kw">fn </span>gen_source_statement (_other : &amp; DeployNode , _port : &amp; DeployPort &lt; DeployNode &gt;) -&gt; syn :: Expr { parse_quote ! (null) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>HfSendOneToMany &lt; DeployCluster , u32 &gt; <span class="kw">for </span>DeployNode { <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, other : &amp; DeployCluster , source_port : &amp; DeployPort &lt; DeployNode &gt; , recipient_port : &amp; DeployPort &lt; DeployCluster &gt; ,) { <span class="kw">let </span>source_port = <span class="self">self </span>. underlying . try_read () . unwrap () . get_port (source_port . port . clone () , &amp; <span class="self">self </span>. underlying) ; <span class="kw">let </span>recipient_port = DemuxSink { demux : other . members . iter () . enumerate () . map (| (id , c) | { <span class="kw">let </span>n = c . underlying . try_read () . unwrap () ; (id <span class="kw">as </span>u32 , Arc :: new (n . get_port (recipient_port . port . clone () , &amp; c . underlying)) <span class="kw">as </span>Arc &lt; <span class="kw">dyn </span>HydroflowSink + <span class="lifetime">'static </span>&gt; ,) }) . collect () , } ; source_port . send_to (&amp; recipient_port) ; } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, _port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { parse_quote ! (null) } <span class="kw">fn </span>gen_source_statement (_other : &amp; DeployCluster , _port : &amp; DeployPort &lt; DeployCluster &gt; ,) -&gt; syn :: Expr { parse_quote ! (null) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>HfSendManyToMany &lt; DeployCluster , u32 &gt; <span class="kw">for </span>DeployCluster { <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, other : &amp; DeployCluster , source_port : &amp; DeployPort &lt; DeployCluster &gt; , recipient_port : &amp; DeployPort &lt; DeployCluster &gt; ,) { <span class="kw">for </span>(i , sender) <span class="kw">in </span><span class="self">self </span>. members . iter () . enumerate () { <span class="kw">let </span>source_port = sender . underlying . try_read () . unwrap () . get_port (source_port . port . clone () , &amp; sender . underlying) ; <span class="kw">let </span>recipient_port = DemuxSink { demux : other . members . iter () . enumerate () . map (| (id , c) | { <span class="kw">let </span>n = c . underlying . try_read () . unwrap () ; (id <span class="kw">as </span>u32 , Arc :: new (n . get_port (recipient_port . port . clone () , &amp; c . underlying) . merge () ,) <span class="kw">as </span>Arc &lt; <span class="kw">dyn </span>HydroflowSink + <span class="lifetime">'static </span>&gt; ,) }) . collect () , } ; TaggedSource { source : Arc :: new (source_port) , tag : i <span class="kw">as </span>u32 , } . send_to (&amp; recipient_port) ; } } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, _port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { parse_quote ! (null) } <span class="kw">fn </span>gen_source_statement (_other : &amp; DeployCluster , _port : &amp; DeployPort &lt; DeployCluster &gt; ,) -&gt; syn :: Expr { parse_quote ! (null) } } <span class="kw">type </span>CrateBuilder &lt; <span class="lifetime">'a </span>&gt; = <span class="kw">dyn </span>FnMut () -&gt; Arc &lt; RwLock &lt; HydroflowCrateService &gt; &gt; + <span class="lifetime">'a </span>; <span class="kw">pub use crate </span>:: deploy :: DeployProcessSpec ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; DeployProcessSpec &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">pub fn </span>new &lt; F : FnMut () -&gt; Arc &lt; RwLock &lt; HydroflowCrateService &gt; &gt; + <span class="lifetime">'a </span>&gt; (f : F) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>(RefCell :: new (Box :: new (f))) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>: <span class="lifetime">'b </span>, <span class="lifetime">'b </span>&gt; ProcessSpec &lt; <span class="lifetime">'a </span>, HydroDeploy &gt; <span class="kw">for </span>DeployProcessSpec &lt; <span class="lifetime">'b </span>&gt; { <span class="kw">fn </span>build (&amp; <span class="self">self </span>, id : usize , _meta : &amp; <span class="kw-2">mut </span>HashMap &lt; usize , Vec &lt; u32 &gt; &gt;) -&gt; DeployNode { DeployNode { id , next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , underlying : (<span class="self">self </span>. <span class="number">0 </span>. borrow_mut ()) () , } } } <span class="kw">type </span>ClusterSpecFn &lt; <span class="lifetime">'a </span>&gt; = <span class="kw">dyn </span>FnMut () -&gt; Vec &lt; Arc &lt; RwLock &lt; HydroflowCrateService &gt; &gt; &gt; + <span class="lifetime">'a </span>; <span class="kw">pub use crate </span>:: deploy :: DeployClusterSpec ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; DeployClusterSpec &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">pub fn </span>new &lt; F : FnMut () -&gt; Vec &lt; Arc &lt; RwLock &lt; HydroflowCrateService &gt; &gt; &gt; + <span class="lifetime">'a </span>&gt; (f : F) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>(RefCell :: new (Box :: new (f))) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>: <span class="lifetime">'b </span>, <span class="lifetime">'b </span>&gt; ClusterSpec &lt; <span class="lifetime">'a </span>, HydroDeploy &gt; <span class="kw">for </span>DeployClusterSpec &lt; <span class="lifetime">'b </span>&gt; { <span class="kw">fn </span>build (&amp; <span class="self">self </span>, id : usize , meta : &amp; <span class="kw-2">mut </span>HashMap &lt; usize , Vec &lt; u32 &gt; &gt;) -&gt; DeployCluster { <span class="kw">let </span>cluster_nodes = (<span class="self">self </span>. <span class="number">0 </span>. borrow_mut ()) () ; meta . insert (id , (<span class="number">0 </span>.. (cluster_nodes . len () <span class="kw">as </span>u32)) . collect ()) ; DeployCluster { id , next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , members : cluster_nodes . into_iter () . map (| u | DeployClusterNode { underlying : u }) . collect () , } } } } # [cfg (feature = <span class="string">"deploy"</span>)] <span class="kw">pub use </span>deploy :: * ; <span class="kw">pub use </span>serde :: { Deserialize , Serialize } ; <span class="kw">pub use crate </span>:: HydroflowPlusMeta ;</code></pre></div></section></main></body></html>