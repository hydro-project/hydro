<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/hydroflow/hydroflow/target/debug/build/hydroflow_plus-24c70b468a905318/out/lib_pub.rs`."><title>lib_pub.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-fecee23daa4e8a6d.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="hydroflow_plus" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0-nightly (4ac7bcbaa 2024-09-04)" data-channel="nightly" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../../../../../../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../../../../../../../../../../../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
</pre></div><pre class="rust"><code><span class="kw">pub use </span>std :: collections :: BTreeMap ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>hydroflow :: scheduled :: context :: Context ; <span class="kw">pub use </span>hydroflow :: scheduled :: graph :: Hydroflow ; <span class="kw">pub use </span>hydroflow :: * ; <span class="kw">pub use </span>lang :: graph :: { partition_graph , propagate_flow_props , HydroflowGraph } ; <span class="kw">pub use </span>proc_macro2 :: TokenStream ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>stageleft :: runtime_support :: FreeVariable ; <span class="kw">pub use </span>stageleft :: Quoted ; <span class="kw">pub mod </span>runtime_support { <span class="kw">pub use </span>bincode ; } <span class="kw">pub mod </span>stream { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: hash :: Hash ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>hydroflow :: bytes :: Bytes ; <span class="kw">pub use </span>hydroflow :: futures :: Sink ; <span class="kw">pub use </span>hydroflow_lang :: parse :: Pipeline ; <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use </span>stageleft :: { q , IntoQuotedMut , Quoted } ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: ir :: { HfPlusLeaf , HfPlusNode , HfPlusSource } ; <span class="kw">pub use crate </span>:: location :: { Cluster , HfSend , Location } ; <span class="kw">pub use crate </span>:: stream :: Async ; <span class="kw">pub use crate </span>:: stream :: Windowed ; <span class="kw">pub use crate </span>:: stream :: Stream ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location + Clone &gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">pub </span>(<span class="kw">crate</span>) <span class="kw">fn </span>new (node : N , ir_leaves : Rc &lt; RefCell &lt; Vec &lt; HfPlusLeaf &gt; &gt; &gt; , ir_node : HfPlusNode ,) -&gt; <span class="self">Self </span>{ Stream { node , ir_leaves , ir_node : RefCell :: new (ir_node) , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , W , N : Location + Clone &gt; Clone <span class="kw">for </span>Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ <span class="kw">if </span>! matches ! (<span class="self">self </span>. ir_node . borrow () . deref () , HfPlusNode :: Tee { .. }) { <span class="kw">let </span>orig_ir_node = <span class="self">self </span>. ir_node . replace (HfPlusNode :: Placeholder) ; * <span class="self">self </span>. ir_node . borrow_mut () = HfPlusNode :: Tee { inner : Rc :: new (RefCell :: new (orig_ir_node)) , } ; } Stream :: new (<span class="self">self </span>. node . clone () , <span class="self">self </span>. ir_leaves . clone () , <span class="self">self </span>. ir_node . borrow () . clone () ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location + Clone &gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">pub fn </span>map &lt; U , F : Fn (T) -&gt; U + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, U , W , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Map { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, U , W , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: FlatMap { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>enumerate (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, (usize , T) , W , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Enumerate (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>inspect &lt; F : Fn (&amp; T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Inspect { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter &lt; F : Fn (&amp; T) -&gt; bool + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Filter { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter_map &lt; U , F : Fn (T) -&gt; <span class="prelude-ty">Option </span>&lt; U &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, U , W , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: FilterMap { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>cross_product &lt; O &gt; (<span class="self">self </span>, other : Stream &lt; <span class="lifetime">'a </span>, O , W , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, (T , O) , W , N &gt; { <span class="kw">if </span><span class="self">self </span>. node . id () != other . node . id () { panic ! (<span class="string">"cross_product must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: CrossProduct (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>union (<span class="self">self </span>, other : Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">if </span><span class="self">self </span>. node . id () != other . node . id () { panic ! (<span class="string">"union must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Union (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>for_each &lt; F : Fn (T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt;) { <span class="self">self </span>. ir_leaves . borrow_mut () . push (HfPlusLeaf :: ForEach { input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , f : f . splice () . into () , }) ; } <span class="kw">pub fn </span>dest_sink &lt; S : Unpin + Sink &lt; T &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, sink : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, S &gt;) { <span class="self">self </span>. ir_leaves . borrow_mut () . push (HfPlusLeaf :: DestSink { sink : sink . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } <span class="kw">pub fn </span>all_ticks (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>assume_windowed (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , <span class="self">self </span>. ir_node . into_inner ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location + Clone &gt; Stream &lt; <span class="lifetime">'a </span>, T , Async , N &gt; { <span class="kw">pub fn </span>tick_batch (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , <span class="self">self </span>. ir_node . into_inner ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location + Clone &gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { <span class="kw">pub fn </span>fold &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, C : Fn (&amp; <span class="kw-2">mut </span>A , T) &gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, C &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, A , Windowed , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Fold { init : init . splice () . into () , acc : comb . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>reduce &lt; C : Fn (&amp; <span class="kw-2">mut </span>T , T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, C &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Reduce { f : comb . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>count (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, usize , Windowed , N &gt; { <span class="self">self </span>. fold (q ! (|| <span class="number">0usize</span>) , q ! (| count , <span class="kw">_ </span>| * count += <span class="number">1</span>)) } <span class="kw">pub fn </span>delta (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Delta (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>unique (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; <span class="kw">where </span>T : Eq + Hash , { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Unique (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>filter_not_in (<span class="self">self </span>, other : Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; <span class="kw">where </span>T : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. node . id () != other . node . id () { panic ! (<span class="string">"union must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Difference (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>sample_every (<span class="self">self </span>, duration : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, std :: time :: Duration &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , N &gt; { <span class="kw">let </span>interval = duration . splice () ; <span class="kw">let </span>samples = Stream :: &lt; <span class="lifetime">'a </span>, hydroflow :: tokio :: time :: Instant , Windowed , N &gt; :: new (<span class="self">self </span>. node . clone () , <span class="self">self </span>. ir_leaves . clone () , HfPlusNode :: Source { source : HfPlusSource :: Interval (interval . into ()) , location_id : <span class="self">self </span>. node . id () , } ,) ; <span class="self">self </span>. cross_product (samples) . map (q ! (| (a , <span class="kw">_</span>) | a)) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , W , N : Location + Clone &gt; Stream &lt; <span class="lifetime">'a </span>, &amp; T , W , N &gt; { <span class="kw">pub fn </span>cloned (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="self">self </span>. map (q ! (| d | d . clone ())) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, K , V1 , W , N : Location + Clone &gt; Stream &lt; <span class="lifetime">'a </span>, (K , V1) , W , N &gt; { <span class="kw">pub fn </span>join &lt; W2 , V2 &gt; (<span class="self">self </span>, n : Stream &lt; <span class="lifetime">'a </span>, (K , V2) , W2 , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, (K , (V1 , V2)) , W , N &gt; <span class="kw">where </span>K : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. node . id () != n . node . id () { panic ! (<span class="string">"join must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: Join (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (n . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>anti_join &lt; W2 &gt; (<span class="self">self </span>, n : Stream &lt; <span class="lifetime">'a </span>, K , W2 , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, (K , V1) , W , N &gt; <span class="kw">where </span>K : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. node . id () != n . node . id () { panic ! (<span class="string">"anti_join must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: AntiJoin (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (n . ir_node . into_inner ()) ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, K : Eq + Hash , V , N : Location + Clone &gt; Stream &lt; <span class="lifetime">'a </span>, (K , V) , Windowed , N &gt; { <span class="kw">pub fn </span>fold_keyed &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, C : Fn (&amp; <span class="kw-2">mut </span>A , V) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, C &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, (K , A) , Windowed , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: FoldKeyed { init : init . splice () . into () , acc : comb . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>reduce_keyed &lt; F : Fn (&amp; <span class="kw-2">mut </span>V , V) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, (K , V) , Windowed , N &gt; { Stream :: new (<span class="self">self </span>. node , <span class="self">self </span>. ir_leaves , HfPlusNode :: ReduceKeyed { f : comb . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } } <span class="kw">pub fn </span>get_this_crate () -&gt; TokenStream { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydroflow_plus"</span>) . expect (<span class="string">"hydroflow_plus should be present in `Cargo.toml`"</span>) ; <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , Span :: call_site ()) ; quote ! { # ident } } } } <span class="kw">pub fn </span>serialize_bincode &lt; T : Serialize &gt; (is_demux : bool) -&gt; Pipeline { <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span>t_type : syn :: Type = stageleft :: quote_type :: &lt; T &gt; () ; <span class="kw">if </span>is_demux { parse_quote ! { map (| (id , data) | { (id , # root :: runtime_support :: bincode :: serialize ::&lt;# t_type &gt; (&amp; data) . unwrap () . into ()) }) } } <span class="kw">else </span>{ parse_quote ! { map (| data | { # root :: runtime_support :: bincode :: serialize ::&lt;# t_type &gt; (&amp; data) . unwrap () . into () }) } } } <span class="kw">pub fn </span>deserialize_bincode &lt; T : DeserializeOwned &gt; (tagged : bool) -&gt; Pipeline { <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span>t_type : syn :: Type = stageleft :: quote_type :: &lt; T &gt; () ; <span class="kw">if </span>tagged { parse_quote ! { map (| res | { <span class="kw">let </span>(id , b) = res . unwrap () ; (id , # root :: runtime_support :: bincode :: deserialize ::&lt;# t_type &gt; (&amp; b) . unwrap ()) }) } } <span class="kw">else </span>{ parse_quote ! { map (| res | { # root :: runtime_support :: bincode :: deserialize ::&lt;# t_type &gt; (&amp; res . unwrap ()) . unwrap () }) } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location + Clone &gt; Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">pub fn </span>send_bincode &lt; N2 : Location + Clone , V , CoreType &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, N :: Out &lt; CoreType &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; N2 , V , In &lt; CoreType &gt; = T &gt; , CoreType : Serialize + DeserializeOwned , { <span class="kw">let </span>send_port = <span class="self">self </span>. node . next_port () ; <span class="kw">let </span>serialize_pipeline = <span class="prelude-val">Some </span>(serialize_bincode :: &lt; CoreType &gt; (N :: is_demux ())) ; <span class="kw">let </span>sink_expr = <span class="self">self </span>. node . gen_sink_statement (&amp; send_port) . into () ; <span class="kw">let </span>recv_port = other . next_port () ; <span class="kw">let </span>deserialize_pipeline = <span class="prelude-val">Some </span>(deserialize_bincode :: &lt; CoreType &gt; (N :: is_tagged ())) ; <span class="kw">let </span>source_expr = N :: gen_source_statement (other , &amp; recv_port) . into () ; <span class="self">self </span>. node . connect (other , &amp; send_port , &amp; recv_port) ; Stream :: new (other . clone () , <span class="self">self </span>. ir_leaves , HfPlusNode :: Network { to_location : other . id () , serialize_pipeline , sink_expr , source_expr , deserialize_pipeline , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>send_bytes &lt; N2 : Location + Clone , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, N :: Out &lt; Bytes &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; N2 , V , In &lt; Bytes &gt; = T &gt; , { <span class="kw">let </span>send_port = <span class="self">self </span>. node . next_port () ; <span class="kw">let </span>sink_expr = <span class="self">self </span>. node . gen_sink_statement (&amp; send_port) . into () ; <span class="kw">let </span>recv_port = other . next_port () ; <span class="kw">let </span>source_expr = N :: gen_source_statement (other , &amp; recv_port) . into () ; <span class="self">self </span>. node . connect (other , &amp; send_port , &amp; recv_port) ; Stream :: new (other . clone () , <span class="self">self </span>. ir_leaves , HfPlusNode :: Network { to_location : other . id () , serialize_pipeline : <span class="prelude-val">None </span>, sink_expr , source_expr , deserialize_pipeline : <span class="kw">if </span>N :: is_tagged () { <span class="prelude-val">Some </span>(parse_quote ! (map (| (id , b) | (id , b . unwrap () . freeze ())))) } <span class="kw">else </span>{ <span class="prelude-val">Some </span>(parse_quote ! (map (| b | b . unwrap () . freeze ()))) } , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>send_bincode_interleaved &lt; N2 : Location + Clone , Tag , CoreType , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; N2 , V , In &lt; CoreType &gt; = T , Out &lt; CoreType &gt; = (Tag , T) &gt; , CoreType : Serialize + DeserializeOwned , { <span class="self">self </span>. send_bincode :: &lt; N2 , V , CoreType &gt; (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>send_bytes_interleaved &lt; N2 : Location + Clone , Tag , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, Bytes , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; N2 , V , In &lt; Bytes &gt; = T , Out &lt; Bytes &gt; = (Tag , Bytes) &gt; , { <span class="self">self </span>. send_bytes :: &lt; N2 , V &gt; (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>broadcast_bincode &lt; N2 : Location + Cluster &lt; <span class="lifetime">'a </span>&gt; + Clone , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, N :: Out &lt; T &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; N2 , V , In &lt; T &gt; = (N2 :: Id , T) &gt; , T : Serialize + DeserializeOwned , N2 :: Id : Clone , { <span class="kw">let </span>ids_spliced = other . ids () . splice () ; <span class="kw">let </span>other_ids = Stream :: &lt; <span class="lifetime">'a </span>, &amp; N2 :: Id , Windowed , N &gt; :: new (<span class="self">self </span>. node . clone () , <span class="self">self </span>. ir_leaves . clone () , HfPlusNode :: Source { source : HfPlusSource :: Iter (ids_spliced . into ()) , location_id : <span class="self">self </span>. node . id () , } ,) . cloned () . all_ticks () ; other_ids . cross_product (<span class="self">self </span>. assume_windowed ()) . send_bincode (other) } <span class="kw">pub fn </span>broadcast_bincode_interleaved &lt; N2 : Location + Cluster &lt; <span class="lifetime">'a </span>&gt; + Clone , Tag , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; N2 , V , In &lt; T &gt; = (N2 :: Id , T) , Out &lt; T &gt; = (Tag , T) &gt; , T : Serialize + DeserializeOwned , N2 :: Id : Clone , { <span class="self">self </span>. broadcast_bincode (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>broadcast_bytes &lt; N2 : Location + Cluster &lt; <span class="lifetime">'a </span>&gt; + Clone , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, N :: Out &lt; Bytes &gt; , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; N2 , V , In &lt; Bytes &gt; = (N2 :: Id , T) &gt; , N2 :: Id : Clone , { <span class="kw">let </span>ids_spliced = other . ids () . splice () ; <span class="kw">let </span>other_ids = Stream :: &lt; <span class="lifetime">'a </span>, &amp; N2 :: Id , Windowed , N &gt; :: new (<span class="self">self </span>. node . clone () , <span class="self">self </span>. ir_leaves . clone () , HfPlusNode :: Source { source : HfPlusSource :: Iter (ids_spliced . into ()) , location_id : <span class="self">self </span>. node . id () , } ,) . cloned () . all_ticks () ; other_ids . cross_product (<span class="self">self </span>. assume_windowed ()) . send_bytes (other) } <span class="kw">pub fn </span>broadcast_bytes_interleaved &lt; N2 : Location + Cluster &lt; <span class="lifetime">'a </span>&gt; + Clone , Tag , V &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, Bytes , Async , N2 &gt; <span class="kw">where </span>N : HfSend &lt; N2 , V , In &lt; Bytes &gt; = (N2 :: Id , T) , Out &lt; Bytes &gt; = (Tag , Bytes) &gt; , N2 :: Id : Clone , { <span class="self">self </span>. broadcast_bytes (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } } } <span class="kw">pub use </span>stream :: Stream ; <span class="kw">pub mod </span>location { <span class="kw">pub use </span>dyn_clone :: DynClone ; <span class="kw">pub use </span>stageleft :: Quoted ; <span class="kw">pub mod </span>graphs { <span class="kw">pub use </span>stageleft :: { Quoted , RuntimeData } ; <span class="kw">pub use super </span>:: { Cluster , LocalDeploy , Location , ProcessSpec } ; <span class="kw">pub use crate </span>:: location :: graphs :: SingleProcessGraph ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>SingleProcessGraph { <span class="kw">type </span>ClusterId = () ; <span class="kw">type </span>Process = SingleNode ; <span class="kw">type </span>Cluster = SingleNode ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = () ; } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ProcessSpec &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (&amp; <span class="self">self </span>, _id : usize , _meta : &amp; <span class="kw-2">mut </span>()) -&gt; SingleNode { SingleNode { } } } <span class="kw">pub use crate </span>:: location :: graphs :: SingleNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Location <span class="kw">for </span>SingleNode { <span class="kw">type </span>Port = () ; <span class="kw">type </span>Meta = () ; <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; usize { <span class="number">0 </span>} <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) { panic ! () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Cluster &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>SingleNode { <span class="kw">type </span>Id = () ; <span class="kw">fn </span>ids (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; () &gt; &gt; + Copy + <span class="lifetime">'a </span>{ panic ! () ; # [allow (unreachable_code)] RuntimeData :: new (<span class="string">""</span>) } <span class="kw">fn </span>self_id (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, <span class="self">Self </span>:: Id &gt; + Copy + <span class="lifetime">'a </span>{ panic ! () ; # [allow (unreachable_code)] RuntimeData :: new (<span class="string">""</span>) } } <span class="kw">pub use crate </span>:: location :: graphs :: MultiGraph ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>MultiGraph { <span class="kw">type </span>ClusterId = u32 ; <span class="kw">type </span>Process = MultiNode ; <span class="kw">type </span>Cluster = MultiNode ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = usize ; } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ProcessSpec &lt; <span class="lifetime">'a </span>, MultiGraph &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (&amp; <span class="self">self </span>, id : usize , _meta : &amp; <span class="kw-2">mut </span>()) -&gt; MultiNode { MultiNode { id } } } <span class="kw">pub use crate </span>:: location :: graphs :: MultiNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Location <span class="kw">for </span>MultiNode { <span class="kw">type </span>Port = () ; <span class="kw">type </span>Meta = () ; <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; usize { <span class="self">self </span>. id } <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) { panic ! () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Cluster &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>MultiNode { <span class="kw">type </span>Id = u32 ; <span class="kw">fn </span>ids (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; u32 &gt; &gt; + Copy + <span class="lifetime">'a </span>{ panic ! () ; # [allow (unreachable_code)] RuntimeData :: new (<span class="string">""</span>) } <span class="kw">fn </span>self_id (&amp; <span class="self">self</span>) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, <span class="self">Self </span>:: Id &gt; + Copy + <span class="lifetime">'a </span>{ panic ! () ; # [allow (unreachable_code)] RuntimeData :: new (<span class="string">""</span>) } } } <span class="kw">pub use </span>graphs :: * ; <span class="kw">pub mod </span>network { <span class="kw">pub use super </span>:: Location ; <span class="kw">pub use crate </span>:: location :: network :: HfSend ; <span class="kw">pub use crate </span>:: location :: network :: HfSendOneToOne ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; O : Location , H : HfSendOneToOne &lt; O &gt; &gt; HfSend &lt; O , () &gt; <span class="kw">for </span>H { <span class="kw">type </span>In &lt; T &gt; = T ; <span class="kw">type </span>Out &lt; T &gt; = T ; <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, other : &amp; O , source_port : &amp; <span class="self">Self </span>:: Port , recipient_port : &amp; O :: Port) { H :: connect (<span class="self">self </span>, other , source_port , recipient_port) ; } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { H :: gen_sink_statement (<span class="self">self </span>, port) } <span class="kw">fn </span>gen_source_statement (other : &amp; O , port : &amp; O :: Port) -&gt; syn :: Expr { H :: gen_source_statement (other , port) } <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">false </span>} <span class="kw">fn </span>is_tagged () -&gt; bool { <span class="bool-val">false </span>} } <span class="kw">pub use crate </span>:: location :: network :: HfSendManyToOne ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; O : Location , Tag , H : HfSendManyToOne &lt; O , Tag &gt; &gt; HfSend &lt; O , (() , Tag) &gt; <span class="kw">for </span>H { <span class="kw">type </span>In &lt; T &gt; = T ; <span class="kw">type </span>Out &lt; T &gt; = (Tag , T) ; <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, other : &amp; O , source_port : &amp; <span class="self">Self </span>:: Port , recipient_port : &amp; O :: Port) { H :: connect (<span class="self">self </span>, other , source_port , recipient_port) ; } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { H :: gen_sink_statement (<span class="self">self </span>, port) } <span class="kw">fn </span>gen_source_statement (other : &amp; O , port : &amp; O :: Port) -&gt; syn :: Expr { H :: gen_source_statement (other , port) } <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">false </span>} <span class="kw">fn </span>is_tagged () -&gt; bool { <span class="bool-val">true </span>} } <span class="kw">pub use crate </span>:: location :: network :: HfSendOneToMany ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; O : Location , Cid , H : HfSendOneToMany &lt; O , Cid &gt; &gt; HfSend &lt; O , (() , () , Cid) &gt; <span class="kw">for </span>H { <span class="kw">type </span>In &lt; T &gt; = (Cid , T) ; <span class="kw">type </span>Out &lt; T &gt; = T ; <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, other : &amp; O , source_port : &amp; <span class="self">Self </span>:: Port , recipient_port : &amp; O :: Port) { H :: connect (<span class="self">self </span>, other , source_port , recipient_port) ; } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { H :: gen_sink_statement (<span class="self">self </span>, port) } <span class="kw">fn </span>gen_source_statement (other : &amp; O , port : &amp; O :: Port) -&gt; syn :: Expr { H :: gen_source_statement (other , port) } <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>is_tagged () -&gt; bool { <span class="bool-val">false </span>} } <span class="kw">pub use crate </span>:: location :: network :: HfSendManyToMany ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; O : Location , Cid , H : HfSendManyToMany &lt; O , Cid &gt; &gt; HfSend &lt; O , (() , () , Cid , Cid) &gt; <span class="kw">for </span>H { <span class="kw">type </span>In &lt; T &gt; = (Cid , T) ; <span class="kw">type </span>Out &lt; T &gt; = (Cid , T) ; <span class="kw">fn </span>connect (&amp; <span class="self">self </span>, other : &amp; O , source_port : &amp; <span class="self">Self </span>:: Port , recipient_port : &amp; O :: Port) { H :: connect (<span class="self">self </span>, other , source_port , recipient_port) ; } <span class="kw">fn </span>gen_sink_statement (&amp; <span class="self">self </span>, port : &amp; <span class="self">Self </span>:: Port) -&gt; syn :: Expr { H :: gen_sink_statement (<span class="self">self </span>, port) } <span class="kw">fn </span>gen_source_statement (other : &amp; O , port : &amp; O :: Port) -&gt; syn :: Expr { H :: gen_source_statement (other , port) } <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>is_tagged () -&gt; bool { <span class="bool-val">true </span>} } } <span class="kw">pub use </span>network :: * ; <span class="kw">pub use crate </span>:: location :: LocalDeploy ; <span class="kw">pub use crate </span>:: location :: Deploy ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, Cid : Clone + <span class="lifetime">'static </span>, T : Deploy &lt; <span class="lifetime">'a </span>, ClusterId = Cid , Process = N , Cluster = C , Meta = M , GraphId = R &gt; , N : Location &lt; Meta = M &gt; + HfSendOneToOne &lt; N &gt; + HfSendOneToMany &lt; C , Cid &gt; + Clone , C : Location &lt; Meta = M &gt; + HfSendManyToOne &lt; N , Cid &gt; + HfSendManyToMany &lt; C , Cid &gt; + Cluster &lt; <span class="lifetime">'a </span>, Id = Cid &gt; + Clone , M : Default , R , &gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>T { <span class="kw">type </span>ClusterId = Cid ; <span class="kw">type </span>Process = N ; <span class="kw">type </span>Cluster = C ; <span class="kw">type </span>Meta = M ; <span class="kw">type </span>GraphId = R ; } <span class="kw">pub use crate </span>:: location :: ProcessSpec ; <span class="kw">pub use crate </span>:: location :: ClusterSpec ; <span class="kw">pub use crate </span>:: location :: Location ; <span class="kw">pub use crate </span>:: location :: Cluster ; } <span class="kw">pub use </span>location :: { Cluster , ClusterSpec , Deploy , LocalDeploy , Location , MultiGraph , ProcessSpec , SingleProcessGraph , } ; <span class="kw">pub mod </span>cycle { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; <span class="kw">pub use crate </span>:: location :: Location ; <span class="kw">pub use crate </span>:: Stream ; <span class="kw">pub use crate </span>:: cycle :: HfCycle ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location + Clone &gt; HfCycle &lt; <span class="lifetime">'a </span>, T , W , N &gt; { <span class="kw">pub fn </span>complete (<span class="self">self </span>, stream : Stream &lt; <span class="lifetime">'a </span>, T , W , N &gt;) { <span class="kw">let </span>ident = <span class="self">self </span>. ident ; <span class="self">self </span>. ir_leaves . borrow_mut () . push (HfPlusLeaf :: CycleSink { ident , location_id : <span class="self">self </span>. node . id () , input : Box :: new (stream . ir_node . into_inner ()) , }) ; } } } <span class="kw">pub use </span>cycle :: HfCycle ; <span class="kw">pub mod </span>builder { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: { BTreeMap , HashMap } ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>std :: time :: Duration ; <span class="kw">pub use </span>hydroflow :: bytes :: Bytes ; <span class="kw">pub use </span>hydroflow :: futures :: stream :: Stream <span class="kw">as </span>FuturesStream ; <span class="kw">pub use </span>hydroflow :: lattices :: collections :: MapMapValues ; <span class="kw">pub use </span>hydroflow_lang :: graph :: eliminate_extra_unions_tees ; <span class="kw">pub use </span>proc_macro2 :: Span ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: ir :: { HfPlusLeaf , HfPlusNode , HfPlusSource } ; <span class="kw">pub use crate </span>:: location :: { ClusterSpec , HfSendOneToMany , HfSendOneToOne , LocalDeploy , Location , ProcessSpec , } ; <span class="kw">pub use crate </span>:: stream :: { Async , Windowed } ; <span class="kw">pub use crate </span>:: { HfCompiled , HfCycle , RuntimeContext , Stream } ; <span class="kw">pub use crate </span>:: builder :: FlowBuilder ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; QuotedContext <span class="kw">for </span>FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">fn </span>create () -&gt; <span class="self">Self </span>{ FlowBuilder :: new () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; { # [allow (clippy :: new_without_default)] <span class="kw">pub fn </span>new () -&gt; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; { FlowBuilder { ir_leaves : Rc :: new (RefCell :: new (Vec :: new ())) , nodes : RefCell :: new (Vec :: new ()) , clusters : RefCell :: new (Vec :: new ()) , cycle_ids : RefCell :: new (HashMap :: new ()) , meta : RefCell :: new (Default :: default ()) , next_node_id : RefCell :: new (<span class="number">0</span>) , _phantom : PhantomData , } } <span class="kw">pub fn </span>extract (<span class="self">self</span>) -&gt; BuiltFlow &lt; <span class="lifetime">'a </span>, D &gt; { BuiltFlow { ir : <span class="self">self </span>. ir_leaves . borrow () . clone () , nodes : <span class="self">self </span>. nodes . into_inner () , clusters : <span class="self">self </span>. clusters . into_inner () , _phantom : PhantomData , } } <span class="kw">pub fn </span>ir_leaves (&amp; <span class="self">self</span>) -&gt; &amp; Rc &lt; RefCell &lt; Vec &lt; HfPlusLeaf &gt; &gt; &gt; { &amp; <span class="self">self </span>. ir_leaves } <span class="kw">pub fn </span>process (&amp; <span class="self">self </span>, spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt;) -&gt; D :: Process { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="kw">let </span>node = spec . build (id , &amp; <span class="kw-2">mut </span><span class="self">self </span>. meta . borrow_mut ()) ; <span class="self">self </span>. nodes . borrow_mut () . push (node . clone ()) ; <span class="self">self </span>. update_metas () ; node } <span class="kw">pub fn </span>cluster (&amp; <span class="self">self </span>, spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt;) -&gt; D :: Cluster { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="kw">let </span>cluster = spec . build (id , &amp; <span class="kw-2">mut </span><span class="self">self </span>. meta . borrow_mut ()) ; <span class="self">self </span>. clusters . borrow_mut () . push (cluster . clone ()) ; <span class="self">self </span>. update_metas () ; cluster } <span class="kw">pub fn </span>runtime_context (&amp; <span class="self">self</span>) -&gt; RuntimeContext &lt; <span class="lifetime">'a </span>&gt; { RuntimeContext { _phantom : PhantomData , } } <span class="kw">pub fn </span>spin &lt; L : Location + Clone &gt; (&amp; <span class="self">self </span>, on : &amp; L) -&gt; Stream &lt; <span class="lifetime">'a </span>, () , Async , L &gt; { Stream :: new (on . clone () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: Source { source : HfPlusSource :: Spin () , location_id : on . id () , } ,) } <span class="kw">pub fn </span>spin_batch &lt; L : Location + Clone &gt; (&amp; <span class="self">self </span>, on : &amp; L , batch_size : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, usize &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; <span class="lifetime">'a </span>, () , Windowed , L &gt; { <span class="self">self </span>. spin (on) . flat_map (q ! (<span class="kw">move </span>| <span class="kw">_ </span>| <span class="number">0 </span>.. batch_size)) . map (q ! (| <span class="kw">_ </span>| ())) . tick_batch () } <span class="kw">pub fn </span>source_stream &lt; T , E : FuturesStream &lt; Item = T &gt; + Unpin , L : Location + Clone &gt; (&amp; <span class="self">self </span>, on : &amp; L , e : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, E &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Async , L &gt; { <span class="kw">let </span>e = e . splice () ; Stream :: new (on . clone () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: Source { source : HfPlusSource :: Stream (e . into ()) , location_id : on . id () , } ,) } <span class="kw">pub fn </span>source_external &lt; L &gt; (&amp; <span class="self">self </span>, on : &amp; L) -&gt; (L :: Port , Stream &lt; <span class="lifetime">'a </span>, Bytes , Async , L &gt;) <span class="kw">where </span>L : Location + Clone + HfSendOneToOne &lt; L &gt; , { <span class="kw">let </span>port = on . next_port () ; <span class="kw">let </span>source_pipeline = L :: gen_source_statement (on , &amp; port) ; <span class="kw">let </span>process : syn :: Expr = parse_quote ! (| b | b . unwrap () . freeze ()) ; (port , Stream :: new (on . clone () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: Map { f : process . into () , input : Box :: new (HfPlusNode :: Source { source : HfPlusSource :: Stream (source_pipeline . into ()) , location_id : on . id () , }) , } ,) ,) } <span class="kw">pub fn </span>many_source_external &lt; S , Cid , L : Location + Clone &gt; (&amp; <span class="self">self </span>, on : &amp; L ,) -&gt; (L :: Port , Stream &lt; <span class="lifetime">'a </span>, Bytes , Async , L &gt;) <span class="kw">where </span>S : Location + HfSendOneToMany &lt; L , Cid &gt; , { <span class="kw">let </span>port = on . next_port () ; <span class="kw">let </span>source_pipeline = S :: gen_source_statement (on , &amp; port) ; <span class="kw">let </span>process : syn :: Expr = parse_quote ! (| b | b . unwrap () . freeze ()) ; (port , Stream :: new (on . clone () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: Map { f : process . into () , input : Box :: new (HfPlusNode :: Source { source : HfPlusSource :: Stream (source_pipeline . into ()) , location_id : on . id () , }) , } ,) ,) } <span class="kw">pub fn </span>source_iter &lt; T , E : IntoIterator &lt; Item = T &gt; , L : Location + Clone &gt; (&amp; <span class="self">self </span>, on : &amp; L , e : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, E &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Windowed , L &gt; { <span class="kw">let </span>e = e . splice () ; Stream :: new (on . clone () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: Source { source : HfPlusSource :: Iter (e . into ()) , location_id : on . id () , } ,) } <span class="kw">pub fn </span>source_interval &lt; L : Location + Clone &gt; (&amp; <span class="self">self </span>, on : &amp; L , interval : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Duration &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; <span class="lifetime">'a </span>, hydroflow :: tokio :: time :: Instant , Async , L &gt; { <span class="kw">let </span>interval = interval . splice () ; Stream :: new (on . clone () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: Source { source : HfPlusSource :: Interval (interval . into ()) , location_id : on . id () , } ,) } <span class="kw">pub fn </span>cycle &lt; T , W , L : Location + Clone &gt; (&amp; <span class="self">self </span>, on : &amp; L ,) -&gt; (HfCycle &lt; <span class="lifetime">'a </span>, T , W , L &gt; , Stream &lt; <span class="lifetime">'a </span>, T , W , L &gt;) { <span class="kw">let </span>next_id = { <span class="kw">let </span><span class="kw-2">mut </span>cycle_ids = <span class="self">self </span>. cycle_ids . borrow_mut () ; <span class="kw">let </span>next_id_entry = cycle_ids . entry (on . id ()) . or_default () ; <span class="kw">let </span>id = * next_id_entry ; * next_id_entry += <span class="number">1 </span>; id } ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"cycle_{}" </span>, next_id) , Span :: call_site ()) ; (HfCycle { ident : ident . clone () , node : on . clone () , ir_leaves : <span class="self">self </span>. ir_leaves () . clone () , _phantom : PhantomData , } , Stream :: new (on . clone () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: CycleSource { ident , location_id : on . id () , } ,) ,) } <span class="kw">fn </span>update_metas (&amp; <span class="self">self</span>) { <span class="self">self </span>. nodes . borrow_mut () . iter_mut () . for_each (| n | n . update_meta (&amp; <span class="self">self </span>. meta . borrow ())) ; <span class="self">self </span>. clusters . borrow_mut () . iter_mut () . for_each (| n | n . update_meta (&amp; <span class="self">self </span>. meta . borrow ())) ; } } <span class="kw">pub use crate </span>:: builder :: BuiltFlow ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; Clone <span class="kw">for </span>BuiltFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ BuiltFlow { ir : <span class="self">self </span>. ir . clone () , nodes : <span class="self">self </span>. nodes . clone () , clusters : <span class="self">self </span>. clusters . clone () , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; BuiltFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>ir (&amp; <span class="self">self</span>) -&gt; &amp; Vec &lt; HfPlusLeaf &gt; { &amp; <span class="self">self </span>. ir } <span class="kw">pub fn </span>optimize_with (<span class="self">self </span>, f : <span class="kw">impl </span>FnOnce (Vec &lt; HfPlusLeaf &gt;) -&gt; Vec &lt; HfPlusLeaf &gt; ,) -&gt; BuiltFlow &lt; <span class="lifetime">'a </span>, D &gt; { BuiltFlow { ir : f (<span class="self">self </span>. ir) , nodes : <span class="self">self </span>. nodes , clusters : <span class="self">self </span>. clusters , _phantom : PhantomData , } } } <span class="kw">pub fn </span>build_inner &lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (me : BuiltFlow &lt; <span class="lifetime">'a </span>, D &gt;) -&gt; HfCompiled &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="kw">let </span><span class="kw-2">mut </span>builders = BTreeMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>built_tees = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>next_stmt_id = <span class="number">0 </span>; <span class="kw">for </span>leaf <span class="kw">in </span>me . ir { leaf . emit (&amp; <span class="kw-2">mut </span>builders , &amp; <span class="kw-2">mut </span>built_tees , &amp; <span class="kw-2">mut </span>next_stmt_id) ; } HfCompiled { hydroflow_ir : builders . map_values (| v | { <span class="kw">let </span>(<span class="kw-2">mut </span>flat_graph , <span class="kw">_ </span>, <span class="kw">_</span>) = v . build () ; eliminate_extra_unions_tees (&amp; <span class="kw-2">mut </span>flat_graph) ; flat_graph }) , _phantom : PhantomData , } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; BuiltFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>no_optimize (<span class="self">self</span>) -&gt; HfCompiled &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { build_inner (<span class="self">self</span>) } <span class="kw">pub fn </span>with_default_optimize (<span class="self">self</span>) -&gt; BuiltFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. optimize_with (<span class="kw">super </span>:: persist_pullup :: persist_pullup) } <span class="kw">pub fn </span>optimize_default (<span class="self">self</span>) -&gt; HfCompiled &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. with_default_optimize () . no_optimize () } } } <span class="kw">pub use </span>builder :: FlowBuilder ; <span class="kw">pub mod </span>ir { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: { BTreeMap , HashMap } ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>hydroflow_lang :: graph :: FlatGraphBuilder ; <span class="kw">pub use </span>hydroflow_lang :: parse :: Pipeline ; <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: ToTokens ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: ir :: DebugExpr ; # [cfg (stageleft_macro)] <span class="kw">impl </span>From &lt; syn :: Expr &gt; <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>from (expr : syn :: Expr) -&gt; DebugExpr { DebugExpr (expr) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Deref <span class="kw">for </span>DebugExpr { <span class="kw">type </span>Target = syn :: Expr ; <span class="kw">fn </span>deref (&amp; <span class="self">self</span>) -&gt; &amp; <span class="self">Self </span>:: Target { &amp; <span class="self">self </span>. <span class="number">0 </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>ToTokens <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>to_tokens (&amp; <span class="self">self </span>, tokens : &amp; <span class="kw-2">mut </span>TokenStream) { <span class="self">self </span>. <span class="number">0 </span>. to_tokens (tokens) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>std :: fmt :: Debug <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"{}" </span>, <span class="self">self </span>. <span class="number">0 </span>. to_token_stream ()) } } <span class="kw">pub use crate </span>:: ir :: DebugPipelineFn ; # [cfg (stageleft_macro)] <span class="kw">impl </span>std :: fmt :: Debug <span class="kw">for </span>DebugPipelineFn { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"&lt;function&gt;"</span>) } } <span class="kw">pub use crate </span>:: ir :: HfPlusSource ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; # [cfg (stageleft_macro)] <span class="kw">impl </span>HfPlusLeaf { <span class="kw">pub fn </span>transform_children (<span class="self">self </span>, <span class="kw-2">mut </span>transform : <span class="kw">impl </span>FnMut (HfPlusNode , &amp; <span class="kw-2">mut </span>SeenTees) -&gt; HfPlusNode , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees ,) -&gt; HfPlusLeaf { <span class="kw">match </span><span class="self">self </span>{ HfPlusLeaf :: ForEach { f , input } =&gt; HfPlusLeaf :: ForEach { f , input : Box :: new (transform (* input , seen_tees)) , } , HfPlusLeaf :: DestSink { sink , input } =&gt; HfPlusLeaf :: DestSink { sink , input : Box :: new (transform (* input , seen_tees)) , } , HfPlusLeaf :: CycleSink { ident , location_id , input , } =&gt; HfPlusLeaf :: CycleSink { ident , location_id , input : Box :: new (transform (* input , seen_tees)) , } , } } <span class="kw">pub fn </span>emit (<span class="self">self </span>, graph_builders : &amp; <span class="kw-2">mut </span>BTreeMap &lt; usize , FlatGraphBuilder &gt; , built_tees : &amp; <span class="kw-2">mut </span>HashMap &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , (syn :: Ident , usize) &gt; , next_stmt_id : &amp; <span class="kw-2">mut </span>usize ,) { <span class="kw">match </span><span class="self">self </span>{ HfPlusLeaf :: ForEach { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; graph_builders . entry (input_location_id) . or_default () . add_statement (parse_quote ! { # input_ident -&gt; for_each (# f) ; }) ; } HfPlusLeaf :: DestSink { sink , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; graph_builders . entry (input_location_id) . or_default () . add_statement (parse_quote ! { # input_ident -&gt; dest_sink (# sink) ; }) ; } HfPlusLeaf :: CycleSink { ident , location_id , input , } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (input_location_id , location_id , <span class="string">"cycle_sink location mismatch"</span>) ; graph_builders . entry (location_id) . or_default () . add_statement (parse_quote ! { # ident = # input_ident ; }) ; } } } } <span class="kw">pub use crate </span>:: ir :: HfPlusNode ; <span class="kw">pub type </span>SeenTees = HashMap &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , Rc &lt; RefCell &lt; HfPlusNode &gt; &gt; &gt; ; # [cfg (stageleft_macro)] <span class="kw">impl </span>HfPlusNode { <span class="kw">pub fn </span>transform_children (<span class="self">self </span>, <span class="kw-2">mut </span>transform : <span class="kw">impl </span>FnMut (HfPlusNode , &amp; <span class="kw-2">mut </span>SeenTees) -&gt; HfPlusNode , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees ,) -&gt; HfPlusNode { <span class="kw">match </span><span class="self">self </span>{ HfPlusNode :: Placeholder =&gt; HfPlusNode :: Placeholder , HfPlusNode :: Source { source , location_id , } =&gt; HfPlusNode :: Source { source , location_id , } , HfPlusNode :: CycleSource { ident , location_id } =&gt; { HfPlusNode :: CycleSource { ident , location_id } } HfPlusNode :: Tee { inner } =&gt; { <span class="kw">if let </span><span class="prelude-val">Some </span>(transformed) = seen_tees . get (&amp; (inner . as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt;)) { HfPlusNode :: Tee { inner : transformed . clone () , } } <span class="kw">else </span>{ <span class="kw">let </span>transformed_cell = Rc :: new (RefCell :: new (HfPlusNode :: Placeholder)) ; seen_tees . insert (inner . as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , transformed_cell . clone () ,) ; <span class="kw">let </span>orig = inner . borrow () . clone () ; * transformed_cell . borrow_mut () = transform (orig , seen_tees) ; HfPlusNode :: Tee { inner : transformed_cell , } } } HfPlusNode :: Persist (inner) =&gt; { HfPlusNode :: Persist (Box :: new (transform (* inner , seen_tees))) } HfPlusNode :: Delta (inner) =&gt; HfPlusNode :: Delta (Box :: new (transform (* inner , seen_tees))) , HfPlusNode :: Union (left , right) =&gt; HfPlusNode :: Union (Box :: new (transform (* left , seen_tees)) , Box :: new (transform (* right , seen_tees)) ,) , HfPlusNode :: CrossProduct (left , right) =&gt; HfPlusNode :: CrossProduct (Box :: new (transform (* left , seen_tees)) , Box :: new (transform (* right , seen_tees)) ,) , HfPlusNode :: Join (left , right) =&gt; HfPlusNode :: Join (Box :: new (transform (* left , seen_tees)) , Box :: new (transform (* right , seen_tees)) ,) , HfPlusNode :: Difference (left , right) =&gt; HfPlusNode :: Difference (Box :: new (transform (* left , seen_tees)) , Box :: new (transform (* right , seen_tees)) ,) , HfPlusNode :: AntiJoin (left , right) =&gt; HfPlusNode :: AntiJoin (Box :: new (transform (* left , seen_tees)) , Box :: new (transform (* right , seen_tees)) ,) , HfPlusNode :: Map { f , input } =&gt; HfPlusNode :: Map { f , input : Box :: new (transform (* input , seen_tees)) , } , HfPlusNode :: FlatMap { f , input } =&gt; HfPlusNode :: FlatMap { f , input : Box :: new (transform (* input , seen_tees)) , } , HfPlusNode :: Filter { f , input } =&gt; HfPlusNode :: Filter { f , input : Box :: new (transform (* input , seen_tees)) , } , HfPlusNode :: FilterMap { f , input } =&gt; HfPlusNode :: FilterMap { f , input : Box :: new (transform (* input , seen_tees)) , } , HfPlusNode :: Enumerate (input) =&gt; { HfPlusNode :: Enumerate (Box :: new (transform (* input , seen_tees))) } HfPlusNode :: Inspect { f , input } =&gt; HfPlusNode :: Inspect { f , input : Box :: new (transform (* input , seen_tees)) , } , HfPlusNode :: Unique (input) =&gt; HfPlusNode :: Unique (Box :: new (transform (* input , seen_tees))) , HfPlusNode :: Fold { init , acc , input } =&gt; HfPlusNode :: Fold { init , acc , input : Box :: new (transform (* input , seen_tees)) , } , HfPlusNode :: FoldKeyed { init , acc , input } =&gt; HfPlusNode :: FoldKeyed { init , acc , input : Box :: new (transform (* input , seen_tees)) , } , HfPlusNode :: Reduce { f , input } =&gt; HfPlusNode :: Reduce { f , input : Box :: new (transform (* input , seen_tees)) , } , HfPlusNode :: ReduceKeyed { f , input } =&gt; HfPlusNode :: ReduceKeyed { f , input : Box :: new (transform (* input , seen_tees)) , } , HfPlusNode :: Network { to_location , serialize_pipeline , sink_expr , source_expr , deserialize_pipeline , input , } =&gt; HfPlusNode :: Network { to_location , serialize_pipeline , sink_expr , source_expr , deserialize_pipeline , input : Box :: new (transform (* input , seen_tees)) , } , } } <span class="kw">pub fn </span>emit (<span class="self">self </span>, graph_builders : &amp; <span class="kw-2">mut </span>BTreeMap &lt; usize , FlatGraphBuilder &gt; , built_tees : &amp; <span class="kw-2">mut </span>HashMap &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , (syn :: Ident , usize) &gt; , next_stmt_id : &amp; <span class="kw-2">mut </span>usize ,) -&gt; (syn :: Ident , usize) { <span class="kw">match </span><span class="self">self </span>{ HfPlusNode :: Placeholder =&gt; { panic ! () } HfPlusNode :: Persist (inner) =&gt; { <span class="kw">let </span>(inner_ident , location) = inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>persist_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>persist_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, persist_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (location) . or_default () ; builder . add_statement (parse_quote ! { # persist_ident = # inner_ident -&gt; persist ::&lt;<span class="lifetime">'static </span>&gt; () ; }) ; (persist_ident , location) } HfPlusNode :: Delta (inner) =&gt; { <span class="kw">let </span>(inner_ident , location) = inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>delta_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>delta_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, delta_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (location) . or_default () ; builder . add_statement (parse_quote ! { # delta_ident = # inner_ident -&gt; multiset_delta () ; }) ; (delta_ident , location) } HfPlusNode :: Source { source , location_id , } =&gt; { <span class="kw">let </span>source_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>source_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, source_id) , Span :: call_site ()) ; <span class="kw">let </span>source_stmt = <span class="kw">match </span>source { HfPlusSource :: Stream (expr) =&gt; { parse_quote ! { # source_ident = source_stream (# expr) ; } } HfPlusSource :: Iter (expr) =&gt; { parse_quote ! { # source_ident = source_iter (# expr) ; } } HfPlusSource :: Interval (expr) =&gt; { parse_quote ! { # source_ident = source_interval (# expr) ; } } HfPlusSource :: Spin () =&gt; { parse_quote ! { # source_ident = spin () ; } } } ; graph_builders . entry (location_id) . or_default () . add_statement (source_stmt) ; (source_ident , location_id) } HfPlusNode :: CycleSource { ident , location_id } =&gt; (ident . clone () , location_id) , HfPlusNode :: Tee { inner } =&gt; { <span class="kw">if let </span><span class="prelude-val">Some </span>(ret) = built_tees . get (&amp; (inner . as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt;)) { ret . clone () } <span class="kw">else </span>{ <span class="kw">let </span>(inner_ident , inner_location_id) = inner . replace (HfPlusNode :: Placeholder) . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>tee_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>tee_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, tee_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (inner_location_id) . or_default () ; builder . add_statement (parse_quote ! { # tee_ident = # inner_ident -&gt; tee () ; }) ; built_tees . insert (inner . as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , (tee_ident . clone () , inner_location_id) ,) ; (tee_ident , inner_location_id) } } HfPlusNode :: Union (left , right) =&gt; { <span class="kw">let </span>(left_ident , left_location_id) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"union inputs must be in the same location"</span>) ; <span class="kw">let </span>union_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>union_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, union_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; builder . add_statement (parse_quote ! { # union_ident = union () ; }) ; builder . add_statement (parse_quote ! { # left_ident -&gt; [<span class="number">0</span>] # union_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [<span class="number">1</span>] # union_ident ; }) ; (union_ident , left_location_id) } HfPlusNode :: CrossProduct (..) | HfPlusNode :: Join (..) =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: CrossProduct (..)) { parse_quote ! (cross_join) } <span class="kw">else </span>{ parse_quote ! (join) } ; <span class="kw">let </span>(HfPlusNode :: CrossProduct (left , right) | HfPlusNode :: Join (left , right)) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(left_inner , left_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (left) = * left { (left , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (left , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(right_inner , right_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (right) = * right { (right , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (right , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(left_ident , left_location_id) = left_inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right_inner . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"join / cross product inputs must be in the same location"</span>) ; <span class="kw">let </span>stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, stream_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; <span class="kw">match </span>(left_was_persist , right_was_persist) { (<span class="bool-val">true </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'static </span>, <span class="lifetime">'static </span>&gt; () ; }) ; } (<span class="bool-val">true </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'static </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; } (<span class="bool-val">false </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'static </span>&gt; () ; }) ; } (<span class="bool-val">false </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; } } ; builder . add_statement (parse_quote ! { # left_ident -&gt; [<span class="number">0</span>] # stream_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [<span class="number">1</span>] # stream_ident ; }) ; (stream_ident , left_location_id) } HfPlusNode :: Difference (..) | HfPlusNode :: AntiJoin (..) =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: Difference (..)) { parse_quote ! (difference) } <span class="kw">else </span>{ parse_quote ! (anti_join) } ; <span class="kw">let </span>(HfPlusNode :: Difference (left , right) | HfPlusNode :: AntiJoin (left , right)) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(right , right_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (right) = * right { (right , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (right , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(left_ident , left_location_id) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"difference / anti join inputs must be in the same location"</span>) ; <span class="kw">let </span>stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, stream_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; <span class="kw">if </span>right_was_persist { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'static </span>&gt; () ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; } builder . add_statement (parse_quote ! { # left_ident -&gt; [pos] # stream_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [neg] # stream_ident ; }) ; (stream_ident , left_location_id) } HfPlusNode :: Map { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # map_ident = # input_ident -&gt; map (# f) ; }) ; (map_ident , input_location_id) } HfPlusNode :: FlatMap { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>flat_map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>flat_map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, flat_map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # flat_map_ident = # input_ident -&gt; flat_map (# f) ; }) ; (flat_map_ident , input_location_id) } HfPlusNode :: Filter { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>filter_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>filter_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, filter_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # filter_ident = # input_ident -&gt; filter (# f) ; }) ; (filter_ident , input_location_id) } HfPlusNode :: FilterMap { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>filter_map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>filter_map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, filter_map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # filter_map_ident = # input_ident -&gt; filter_map (# f) ; }) ; (filter_map_ident , input_location_id) } HfPlusNode :: Enumerate (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>enumerate_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>enumerate_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, enumerate_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # enumerate_ident = # input_ident -&gt; enumerate () ; }) ; (enumerate_ident , input_location_id) } HfPlusNode :: Inspect { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>inspect_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>inspect_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, inspect_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # inspect_ident = # input_ident -&gt; inspect (# f) ; }) ; (inspect_ident , input_location_id) } HfPlusNode :: Unique (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>unique_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>unique_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, unique_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # unique_ident = # input_ident -&gt; unique ::&lt;<span class="lifetime">'tick </span>&gt; () ; }) ; (unique_ident , input_location_id) } HfPlusNode :: Fold { .. } | HfPlusNode :: FoldKeyed { .. } =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: Fold { .. }) { parse_quote ! (fold) } <span class="kw">else </span>{ parse_quote ! (fold_keyed) } ; <span class="kw">let </span>(HfPlusNode :: Fold { init , acc , input } | HfPlusNode :: FoldKeyed { init , acc , input }) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(input , input_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (input) = * input { (input , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (input , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>reduce_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>fold_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, reduce_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if </span>input_was_persist { builder . add_statement (parse_quote ! { # fold_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'static </span>&gt; (# init , # acc) ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # fold_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'tick </span>&gt; (# init , # acc) ; }) ; } (fold_ident , input_location_id) } HfPlusNode :: Reduce { .. } | HfPlusNode :: ReduceKeyed { .. } =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: Reduce { .. }) { parse_quote ! (reduce) } <span class="kw">else </span>{ parse_quote ! (reduce_keyed) } ; <span class="kw">let </span>(HfPlusNode :: Reduce { f , input } | HfPlusNode :: ReduceKeyed { f , input }) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(input , input_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (input) = * input { (input , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (input , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>reduce_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>reduce_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, reduce_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if </span>input_was_persist { builder . add_statement (parse_quote ! { # reduce_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'static </span>&gt; (# f) ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # reduce_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'tick </span>&gt; (# f) ; }) ; } (reduce_ident , input_location_id) } HfPlusNode :: Network { to_location , serialize_pipeline , sink_expr , source_expr , deserialize_pipeline , input , } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>sender_builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(serialize_pipeline) = serialize_pipeline { sender_builder . add_statement (parse_quote ! { # input_ident -&gt; # serialize_pipeline -&gt; dest_sink (# sink_expr) ; }) ; } <span class="kw">else </span>{ sender_builder . add_statement (parse_quote ! { # input_ident -&gt; dest_sink (# sink_expr) ; }) ; } <span class="kw">let </span>receiver_builder = graph_builders . entry (to_location) . or_default () ; <span class="kw">let </span>receiver_stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>receiver_stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, receiver_stream_id) , Span :: call_site ()) ; <span class="kw">if let </span><span class="prelude-val">Some </span>(deserialize_pipeline) = deserialize_pipeline { receiver_builder . add_statement (parse_quote ! { # receiver_stream_ident = source_stream (# source_expr) -&gt; # deserialize_pipeline ; }) ; } <span class="kw">else </span>{ receiver_builder . add_statement (parse_quote ! { # receiver_stream_ident = source_stream (# source_expr) ; }) ; } (receiver_stream_ident , to_location) } } } } } <span class="kw">pub mod </span>persist_pullup { <span class="kw">pub use crate </span>:: ir :: * ; <span class="kw">pub fn </span>persist_pullup_node (node : HfPlusNode , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees) -&gt; HfPlusNode { <span class="kw">match </span>node . transform_children (persist_pullup_node , seen_tees) { HfPlusNode :: Map { f , input : <span class="kw">box </span>HfPlusNode :: Persist (behind_persist) , } =&gt; HfPlusNode :: Persist (Box :: new (HfPlusNode :: Map { f , input : behind_persist , })) , o =&gt; o , } } <span class="kw">pub fn </span>persist_pullup (ir : Vec &lt; HfPlusLeaf &gt;) -&gt; Vec &lt; HfPlusLeaf &gt; { <span class="kw">let </span><span class="kw-2">mut </span>seen_tees = Default :: default () ; ir . into_iter () . map (| l | l . transform_children (persist_pullup_node , &amp; <span class="kw-2">mut </span>seen_tees)) . collect () } # [cfg (stageleft_macro)] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>stageleft :: * ; <span class="kw">use crate </span>:: MultiGraph ; # [test] <span class="kw">fn </span>persist_pullup_through_map () { <span class="kw">let </span>flow = <span class="kw">crate </span>:: builder :: FlowBuilder :: &lt; MultiGraph &gt; :: new () ; <span class="kw">let </span>process = flow . process (&amp; ()) ; flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">10</span>)) . all_ticks () . map (q ! (| v | v + <span class="number">1</span>)) . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; <span class="kw">let </span>built = flow . extract () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">let </span>optimized = built . optimize_with (<span class="kw">super </span>:: persist_pullup) ; insta :: assert_debug_snapshot ! (optimized . ir ()) ; <span class="kw">for </span>(id , graph) <span class="kw">in </span>optimized . no_optimize () . hydroflow_ir () { insta :: with_settings ! ({ snapshot_suffix =&gt; format ! (<span class="string">"surface_graph_{id}"</span>) } , { insta :: assert_display_snapshot ! (graph . surface_syntax_string ()) ; }) ; } } # [test] <span class="kw">fn </span>persist_pullup_behind_tee () { <span class="kw">let </span>flow = <span class="kw">crate </span>:: builder :: FlowBuilder :: &lt; MultiGraph &gt; :: new () ; <span class="kw">let </span>process = flow . process (&amp; ()) ; <span class="kw">let </span>before_tee = flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">10</span>)) . all_ticks () . map (q ! (| v | v + <span class="number">1</span>)) ; before_tee . clone () . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; before_tee . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; <span class="kw">let </span>built = flow . extract () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">let </span>optimized = built . optimize_with (<span class="kw">super </span>:: persist_pullup) ; insta :: assert_debug_snapshot ! (optimized . ir ()) ; <span class="kw">for </span>(id , graph) <span class="kw">in </span>optimized . no_optimize () . hydroflow_ir () { insta :: with_settings ! ({ snapshot_suffix =&gt; format ! (<span class="string">"surface_graph_{id}"</span>) } , { insta :: assert_display_snapshot ! (graph . surface_syntax_string ()) ; }) ; } } } } <span class="kw">pub mod </span>profiler { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>hydroflow :: futures :: channel :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use crate as </span>hydroflow_plus ; <span class="kw">pub use crate </span>:: ir :: * ; <span class="kw">pub use crate </span>:: RuntimeContext ; <span class="kw">pub fn </span>increment_counter (count : &amp; <span class="kw-2">mut </span>u64) { * count += <span class="number">1 </span>; } <span class="kw">pub fn </span>quoted_any_fn &lt; <span class="lifetime">'a </span>, F : Fn (usize) -&gt; usize + <span class="lifetime">'a </span>, Q : IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; &gt; (q : Q) -&gt; Q { q } # [doc = <span class="string">" Add a profiling node before each node to count the cardinality of its input"</span>] <span class="kw">pub fn </span>add_profiling_node &lt; <span class="lifetime">'a </span>&gt; (node : HfPlusNode , _context : RuntimeContext &lt; <span class="lifetime">'a </span>&gt; , counters : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; u64 &gt; &gt; &gt; , counter_queue : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; UnboundedSender &lt; (usize , u64) &gt; &gt; &gt; , id : &amp; <span class="kw-2">mut </span>u32 , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees ,) -&gt; HfPlusNode { <span class="kw">let </span>my_id = * id ; * id += <span class="number">1 </span>; <span class="kw">let </span>child = node . transform_children (| node , seen_tees | { add_profiling_node (node , _context , counters , counter_queue , id , seen_tees) } , seen_tees ,) ; HfPlusNode :: Map { f : quoted_any_fn (q ! ({ counter_queue . borrow () . unbounded_send ((my_id <span class="kw">as </span>usize , counters . borrow () [my_id <span class="kw">as </span>usize])) . unwrap () ; counters . borrow_mut () [my_id <span class="kw">as </span>usize] = <span class="number">0 </span>; <span class="kw">move </span>| v | { hydroflow_plus :: profiler :: increment_counter (&amp; <span class="kw-2">mut </span>counters . borrow_mut () [my_id <span class="kw">as </span>usize] ,) ; v } })) . splice () . into () , input : Box :: new (child) , } } # [doc = <span class="string">" Count the cardinality of each input and periodically output to a file"</span>] <span class="kw">pub fn </span>profiling &lt; <span class="lifetime">'a </span>&gt; (ir : Vec &lt; HfPlusLeaf &gt; , context : RuntimeContext &lt; <span class="lifetime">'a </span>&gt; , counters : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; u64 &gt; &gt; &gt; , counter_queue : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; UnboundedSender &lt; (usize , u64) &gt; &gt; &gt; ,) -&gt; Vec &lt; HfPlusLeaf &gt; { <span class="kw">let </span><span class="kw-2">mut </span>id = <span class="number">0 </span>; <span class="kw">let </span><span class="kw-2">mut </span>seen_tees = Default :: default () ; ir . into_iter () . map (| l | { l . transform_children (| node , seen_tees | { add_profiling_node (node , context , counters , counter_queue , &amp; <span class="kw-2">mut </span>id , seen_tees) } , &amp; <span class="kw-2">mut </span>seen_tees ,) }) . collect () } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>stageleft :: * ; <span class="kw">use crate </span>:: MultiGraph ; # [test] <span class="kw">fn </span>profiler_wrapping_all_operators () { <span class="kw">let </span>flow = <span class="kw">crate </span>:: builder :: FlowBuilder :: &lt; MultiGraph &gt; :: new () ; <span class="kw">let </span>process = flow . process (&amp; ()) ; flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">10</span>)) . all_ticks () . map (q ! (| v | v + <span class="number">1</span>)) . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; <span class="kw">let </span>runtime_context = flow . runtime_context () ; <span class="kw">let </span>built = flow . extract () ; insta :: assert_debug_snapshot ! (&amp; built . ir) ; <span class="kw">let </span>counters = RuntimeData :: new (<span class="string">"Fake"</span>) ; <span class="kw">let </span>counter_queue = RuntimeData :: new (<span class="string">"Fake"</span>) ; <span class="kw">let </span>pushed_down = built . optimize_with (| ir | <span class="kw">super </span>:: profiling (ir , runtime_context , counters , counter_queue)) ; insta :: assert_debug_snapshot ! (&amp; pushed_down . ir) ; } } } <span class="kw">pub mod </span>properties { <span class="kw">pub use </span>std :: collections :: HashSet ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use crate </span>:: ir :: { HfPlusLeaf , HfPlusNode , SeenTees } ; <span class="kw">pub use crate </span>:: properties :: PropertyDatabase ; # [allow (dead_code)] <span class="kw">pub fn </span>convert_hf_to_binary &lt; I , A : Default , F : Fn (&amp; <span class="kw-2">mut </span>A , I) &gt; (f : F) -&gt; <span class="kw">impl </span>Fn (I , I) -&gt; A { <span class="kw">move </span>| a , b | { <span class="kw">let </span><span class="kw-2">mut </span>acc = Default :: default () ; f (&amp; <span class="kw-2">mut </span>acc , a) ; f (&amp; <span class="kw-2">mut </span>acc , b) ; acc } } # [cfg (stageleft_macro)] <span class="kw">impl </span>PropertyDatabase { <span class="kw">pub fn </span>add_commutative_tag &lt; <span class="lifetime">'a </span>, I , A , F : Fn (&amp; <span class="kw-2">mut </span>A , I) , Q : Quoted &lt; <span class="lifetime">'a </span>, F &gt; + Clone &gt; (&amp; <span class="kw-2">mut </span><span class="self">self </span>, expr : Q ,) -&gt; Q { <span class="kw">let </span>expr_clone = expr . clone () ; <span class="self">self </span>. commutative . insert (expr_clone . splice ()) ; expr } <span class="kw">pub fn </span>is_tagged_commutative (&amp; <span class="self">self </span>, expr : &amp; syn :: Expr) -&gt; bool { <span class="self">self </span>. commutative . contains (expr) } } <span class="kw">pub fn </span>properties_optimize_node (node : HfPlusNode , db : &amp; PropertyDatabase , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees ,) -&gt; HfPlusNode { <span class="kw">match </span>node . transform_children (| node , seen_tees | properties_optimize_node (node , db , seen_tees) , seen_tees ,) { HfPlusNode :: ReduceKeyed { f , input } <span class="kw">if </span>db . is_tagged_commutative (&amp; f . <span class="number">0</span>) =&gt; { dbg ! (<span class="string">"IDENTIFIED COMMUTATIVE OPTIMIZATION for {:?}" </span>, &amp; f) ; HfPlusNode :: ReduceKeyed { f , input } } o =&gt; o , } } <span class="kw">pub fn </span>properties_optimize (ir : Vec &lt; HfPlusLeaf &gt; , db : &amp; PropertyDatabase) -&gt; Vec &lt; HfPlusLeaf &gt; { <span class="kw">let </span><span class="kw-2">mut </span>seen_tees = Default :: default () ; ir . into_iter () . map (| l | { l . transform_children (| node , seen_tees | properties_optimize_node (node , db , seen_tees) , &amp; <span class="kw-2">mut </span>seen_tees ,) }) . collect () } # [cfg (stageleft_macro)] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use super </span>:: * ; <span class="kw">use crate </span>:: { FlowBuilder , SingleProcessGraph } ; # [test] <span class="kw">fn </span>test_property_database () { <span class="kw">let </span><span class="kw-2">mut </span>db = PropertyDatabase :: default () ; assert ! (! db . is_tagged_commutative (&amp; (q ! (| a : &amp; <span class="kw-2">mut </span>i32 , b : i32 | * a += b) . splice ()))) ; <span class="kw">let _ </span>= db . add_commutative_tag (q ! (| a : &amp; <span class="kw-2">mut </span>i32 , b : i32 | * a += b)) ; assert ! (db . is_tagged_commutative (&amp; (q ! (| a : &amp; <span class="kw-2">mut </span>i32 , b : i32 | * a += b) . splice ()))) ; } # [test] <span class="kw">fn </span>test_property_optimized () { <span class="kw">let </span>flow = FlowBuilder :: &lt; SingleProcessGraph &gt; :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>database = PropertyDatabase :: default () ; <span class="kw">let </span>process = flow . process (&amp; ()) ; <span class="kw">let </span>counter_func = q ! (| count : &amp; <span class="kw-2">mut </span>i32 , <span class="kw">_ </span>| * count += <span class="number">1</span>) ; <span class="kw">let _ </span>= database . add_commutative_tag (counter_func) ; flow . source_iter (&amp; process , q ! (vec ! [])) . map (q ! (| string : String | (string , ()))) . fold_keyed (q ! (|| <span class="number">0</span>) , counter_func) . for_each (q ! (| (string , count) | println ! (<span class="string">"{}: {}" </span>, string , count))) ; <span class="kw">let </span>built = flow . extract () . optimize_with (| ir | properties_optimize (ir , &amp; database)) . with_default_optimize () ; insta :: assert_debug_snapshot ! (built . ir ()) ; } } } <span class="kw">pub use crate </span>:: RuntimeContext ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Copy <span class="kw">for </span>RuntimeContext &lt; <span class="lifetime">'_ </span>&gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; &amp; <span class="lifetime">'a </span>Context &gt; <span class="kw">for </span>RuntimeContext &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(quote ! (&amp; context))) } } <span class="kw">pub use crate </span>:: HfCompiled ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, ID &gt; HfCompiled &lt; <span class="lifetime">'a </span>, ID &gt; { <span class="kw">pub fn </span>hydroflow_ir (&amp; <span class="self">self</span>) -&gt; &amp; BTreeMap &lt; usize , HydroflowGraph &gt; { &amp; <span class="self">self </span>. hydroflow_ir } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; HfCompiled &lt; <span class="lifetime">'a </span>, usize &gt; { <span class="kw">pub fn </span>with_dynamic_id (<span class="self">self </span>, id : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, usize &gt;) -&gt; HfBuiltWithID &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydroflow_plus"</span>) . expect (<span class="string">"hydroflow_plus should be present in `Cargo.toml`"</span>) ; <span class="kw">let </span>root = <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , proc_macro2 :: Span :: call_site ()) ; quote ! { # ident } } } ; <span class="kw">let </span><span class="kw-2">mut </span>conditioned_tokens = <span class="prelude-val">None </span>; <span class="kw">for </span>(subgraph_id , flat_graph) <span class="kw">in </span><span class="self">self </span>. hydroflow_ir { <span class="kw">let </span><span class="kw-2">mut </span>partitioned_graph = partition_graph (flat_graph) . expect (<span class="string">"Failed to partition (cycle detected)."</span>) ; <span class="kw">let </span><span class="kw-2">mut </span>diagnostics = Vec :: new () ; <span class="kw">let _ </span>= propagate_flow_props :: propagate_flow_props (&amp; <span class="kw-2">mut </span>partitioned_graph , &amp; <span class="kw-2">mut </span>diagnostics ,) ; <span class="kw">let </span>tokens = partitioned_graph . as_code (&amp; root , <span class="bool-val">true </span>, quote :: quote ! () , &amp; <span class="kw-2">mut </span>diagnostics) ; <span class="kw">if let </span><span class="prelude-val">Some </span>(conditioned_tokens) = conditioned_tokens . as_mut () { * conditioned_tokens = syn :: parse_quote ! { # conditioned_tokens <span class="kw">else if </span>__given_id == # subgraph_id { # tokens } } ; } <span class="kw">else </span>{ conditioned_tokens = <span class="prelude-val">Some </span>(syn :: parse_quote ! { <span class="kw">if </span>__given_id == # subgraph_id { # tokens } }) ; } } <span class="kw">let </span>conditioned_tokens : TokenStream = conditioned_tokens . unwrap () ; <span class="kw">let </span>id = id . splice () ; HfBuiltWithID { tokens : syn :: parse_quote ! ({ <span class="kw">let </span>__given_id = # id ; # conditioned_tokens <span class="kw">else </span>{ panic ! (<span class="string">"Invalid node id: {}" </span>, __given_id) ; } }) , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfCompiled &lt; <span class="lifetime">'a </span>, () &gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfCompiled &lt; <span class="lifetime">'a </span>, () &gt; { <span class="kw">fn </span>to_tokens (<span class="kw-2">mut </span><span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydroflow_plus"</span>) . expect (<span class="string">"hydroflow_plus should be present in `Cargo.toml`"</span>) ; <span class="kw">let </span>root = <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , proc_macro2 :: Span :: call_site ()) ; quote ! { # ident } } } ; <span class="kw">if </span><span class="self">self </span>. hydroflow_ir . len () != <span class="number">1 </span>{ panic ! (<span class="string">"Expected exactly one subgraph in the Hydroflow IR"</span>) ; } <span class="kw">let </span>flat_graph = <span class="self">self </span>. hydroflow_ir . remove (&amp; <span class="number">0</span>) . unwrap () ; <span class="kw">let </span><span class="kw-2">mut </span>partitioned_graph = partition_graph (flat_graph) . expect (<span class="string">"Failed to partition (cycle detected)."</span>) ; <span class="kw">let </span><span class="kw-2">mut </span>diagnostics = Vec :: new () ; <span class="kw">let _ </span>= propagate_flow_props :: propagate_flow_props (&amp; <span class="kw-2">mut </span>partitioned_graph , &amp; <span class="kw-2">mut </span>diagnostics) ; <span class="kw">let </span>tokens = partitioned_graph . as_code (&amp; root , <span class="bool-val">true </span>, quote :: quote ! () , &amp; <span class="kw-2">mut </span>diagnostics) ; (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(tokens)) } } <span class="kw">pub use crate </span>:: HfBuiltWithID ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfBuiltWithID &lt; <span class="lifetime">'a </span>&gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfBuiltWithID &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(<span class="self">self </span>. tokens)) } }</code></pre></div></section></main></body></html>