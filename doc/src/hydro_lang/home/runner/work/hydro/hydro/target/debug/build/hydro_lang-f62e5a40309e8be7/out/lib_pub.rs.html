<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/hydro/hydro/target/debug/build/hydro_lang-f62e5a40309e8be7/out/lib_pub.rs`."><title>lib_pub.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-fecee23daa4e8a6d.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="hydro_lang" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0-nightly (4ac7bcbaa 2024-09-04)" data-channel="nightly" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../../../../../../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../../../../../../../../../../../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
</pre></div><pre class="rust"><code><span class="kw">pub use </span>dfir_rs ; <span class="kw">pub use </span>stageleft :: q ; # [doc (hidden)] <span class="kw">pub mod </span>runtime_support { <span class="kw">pub use </span>bincode ; } <span class="kw">pub mod </span>runtime_context { <span class="kw">pub use </span>dfir_rs :: scheduled :: context :: Context ; <span class="kw">pub use </span>proc_macro2 :: TokenStream ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>stageleft :: runtime_support :: FreeVariableWithContext ; <span class="kw">pub use crate </span>:: __staged :: Location ; <span class="kw">pub use crate </span>:: runtime_context :: RUNTIME_CONTEXT ; <span class="kw">pub use crate </span>:: runtime_context :: RuntimeContext ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; FreeVariableWithContext &lt; L &gt; <span class="kw">for </span>RuntimeContext &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">type </span>O = &amp; <span class="lifetime">'a </span>Context ; <span class="kw">fn </span>to_tokens (<span class="self">self </span>, _ctx : &amp; L) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(quote ! (&amp; context))) } } # [cfg (stageleft_macro)] <span class="kw">pub mod </span>tests { <span class="kw">pub use </span>dfir_rs :: futures :: StreamExt ; <span class="kw">pub use </span>hydro_deploy :: Deployment ; <span class="kw">pub use crate </span>:: __staged :: * ; <span class="kw">pub struct </span>P1 { } # [tokio :: test] <span class="kw">pub async fn </span>runtime_context () { <span class="kw">let </span><span class="kw-2">mut </span>deployment = Deployment :: new () ; <span class="kw">let </span>flow = FlowBuilder :: new () ; <span class="kw">let </span>node = flow . process :: &lt; P1 &gt; () ; <span class="kw">let </span>external = flow . external_process :: &lt; () &gt; () ; <span class="kw">let </span>out_port = node . source_iter (q ! (<span class="number">0 </span>.. <span class="number">5</span>)) . map (q ! (| v | (v , RUNTIME_CONTEXT . current_tick () . <span class="number">0</span>))) . send_bincode_external (&amp; external) ; <span class="kw">let </span>nodes = flow . with_process (&amp; node , deployment . Localhost ()) . with_external (&amp; external , deployment . Localhost ()) . deploy (&amp; <span class="kw-2">mut </span>deployment) ; deployment . deploy () . <span class="kw">await </span>. unwrap () ; <span class="kw">let </span><span class="kw-2">mut </span>external_out = nodes . connect_source_bincode (out_port) . <span class="kw">await </span>; deployment . start () . <span class="kw">await </span>. unwrap () ; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5 </span>{ assert_eq ! (external_out . next () . <span class="kw">await </span>. unwrap () , (i , <span class="number">0</span>)) ; } } } } <span class="kw">pub use </span>runtime_context :: RUNTIME_CONTEXT ; <span class="kw">pub mod </span>boundedness { <span class="kw">pub use crate </span>:: boundedness :: Unbounded ; <span class="kw">pub use crate </span>:: boundedness :: Bounded ; } <span class="kw">pub use </span>boundedness :: { Bounded , Unbounded } ; <span class="kw">pub mod </span>stream { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: hash :: Hash ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>dfir_rs :: bytes :: Bytes ; <span class="kw">pub use </span>dfir_rs :: futures ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use </span>stageleft :: { q , IntoQuotedMut , QuotedWithContext } ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use </span>tokio :: time :: Instant ; <span class="kw">pub use crate </span>:: __staged :: builder :: FLOW_USED_MESSAGE ; <span class="kw">pub use crate </span>:: __staged :: cycle :: { CycleCollection , CycleComplete , DeferTick , ForwardRefMarker , TickCycleMarker } ; <span class="kw">pub use crate </span>:: __staged :: ir :: { DebugInstantiate , HydroLeaf , HydroNode , TeeNode } ; <span class="kw">pub use crate </span>:: __staged :: location :: cluster :: CLUSTER_SELF_ID ; <span class="kw">pub use crate </span>:: __staged :: location :: external_process :: { ExternalBincodeStream , ExternalBytesPort } ; <span class="kw">pub use crate </span>:: __staged :: location :: tick :: { NoTimestamp , Timestamped } ; <span class="kw">pub use crate </span>:: __staged :: location :: { check_matching_location , CanSend , ExternalProcess , Location , LocationId , NoTick , Tick , } ; <span class="kw">pub use crate </span>:: __staged :: staging_util :: get_this_crate ; <span class="kw">pub use crate </span>:: __staged :: { Bounded , Cluster , ClusterId , Optional , Process , Singleton , Unbounded } ; <span class="kw">pub use crate </span>:: stream :: TotalOrder ; <span class="kw">pub use crate </span>:: stream :: NoOrder ; <span class="kw">pub use crate </span>:: stream :: MinOrder ; # [cfg (stageleft_macro)] # [sealed :: sealed] <span class="kw">impl </span>&lt; T &gt; MinOrder &lt; T &gt; <span class="kw">for </span>T { <span class="kw">type </span>Min = T ; } # [cfg (stageleft_macro)] # [sealed :: sealed] <span class="kw">impl </span>MinOrder &lt; NoOrder &gt; <span class="kw">for </span>TotalOrder { <span class="kw">type </span>Min = NoOrder ; } # [cfg (stageleft_macro)] # [sealed :: sealed] <span class="kw">impl </span>MinOrder &lt; TotalOrder &gt; <span class="kw">for </span>NoOrder { <span class="kw">type </span>Min = NoOrder ; } <span class="kw">pub use crate </span>:: stream :: Stream ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; From &lt; Stream &lt; T , L , B , TotalOrder &gt; &gt; <span class="kw">for </span>Stream &lt; T , L , B , NoOrder &gt; { <span class="kw">fn </span>from (stream : Stream &lt; T , L , B , TotalOrder &gt;) -&gt; Stream &lt; T , L , B , NoOrder &gt; { Stream { location : stream . location , ir_node : stream . ir_node , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , B , Order &gt; Stream &lt; T , L , B , Order &gt; { <span class="kw">fn </span>location_kind (&amp; <span class="self">self</span>) -&gt; LocationId { <span class="self">self </span>. location . id () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , Order &gt; DeferTick <span class="kw">for </span>Stream &lt; T , Tick &lt; L &gt; , Bounded , Order &gt; { <span class="kw">fn </span>defer_tick (<span class="self">self</span>) -&gt; <span class="self">Self </span>{ Stream :: defer_tick (<span class="self">self</span>) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , Order &gt; CycleCollection &lt; <span class="lifetime">'a </span>, TickCycleMarker &gt; <span class="kw">for </span>Stream &lt; T , Tick &lt; L &gt; , Bounded , Order &gt; { <span class="kw">type </span>Location = Tick &lt; L &gt; ; <span class="kw">fn </span>create_source (ident : syn :: Ident , location : Tick &lt; L &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>location_id = location . id () ; Stream :: new (location , HydroNode :: CycleSource { ident , location_kind : location_id , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , Order &gt; CycleComplete &lt; <span class="lifetime">'a </span>, TickCycleMarker &gt; <span class="kw">for </span>Stream &lt; T , Tick &lt; L &gt; , Bounded , Order &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident , expected_location : LocationId) { assert_eq ! (<span class="self">self </span>. location . id () , expected_location , <span class="string">"locations do not match"</span>) ; <span class="self">self </span>. location . flow_state () . borrow_mut () . leaves . as_mut () . expect (FLOW_USED_MESSAGE) . push (HydroLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B , Order &gt; CycleCollection &lt; <span class="lifetime">'a </span>, ForwardRefMarker &gt; <span class="kw">for </span>Stream &lt; T , L , B , Order &gt; { <span class="kw">type </span>Location = L ; <span class="kw">fn </span>create_source (ident : syn :: Ident , location : L) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>location_id = location . id () ; Stream :: new (location , HydroNode :: Persist (Box :: new (HydroNode :: CycleSource { ident , location_kind : location_id , })) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B , Order &gt; CycleComplete &lt; <span class="lifetime">'a </span>, ForwardRefMarker &gt; <span class="kw">for </span>Stream &lt; T , L , B , Order &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident , expected_location : LocationId) { assert_eq ! (<span class="self">self </span>. location . id () , expected_location , <span class="string">"locations do not match"</span>) ; <span class="self">self </span>. location . flow_state () . borrow_mut () . leaves . as_mut () . expect (FLOW_USED_MESSAGE) . push (HydroLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind () , input : Box :: new (HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , B , Order &gt; Stream &lt; T , L , B , Order &gt; { <span class="kw">pub </span>(<span class="kw">crate</span>) <span class="kw">fn </span>new (location : L , ir_node : HydroNode) -&gt; <span class="self">Self </span>{ Stream { location , ir_node : RefCell :: new (ir_node) , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , L : Location &lt; <span class="lifetime">'a </span>&gt; , B , Order &gt; Clone <span class="kw">for </span>Stream &lt; T , L , B , Order &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ <span class="kw">if </span>! matches ! (<span class="self">self </span>. ir_node . borrow () . deref () , HydroNode :: Tee { .. }) { <span class="kw">let </span>orig_ir_node = <span class="self">self </span>. ir_node . replace (HydroNode :: Placeholder) ; * <span class="self">self </span>. ir_node . borrow_mut () = HydroNode :: Tee { inner : TeeNode (Rc :: new (RefCell :: new (orig_ir_node))) , } ; } <span class="kw">if let </span>HydroNode :: Tee { inner } = <span class="self">self </span>. ir_node . borrow () . deref () { Stream { location : <span class="self">self </span>. location . clone () , ir_node : HydroNode :: Tee { inner : TeeNode (inner . <span class="number">0 </span>. clone ()) , } . into () , _phantom : PhantomData , } } <span class="kw">else </span>{ unreachable ! () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , B , Order &gt; Stream &lt; T , L , B , Order &gt; { # [doc = <span class="string">" Transforms the stream by applying a function (`f`) to each element,"</span>] # [doc = <span class="string">" emitting the output elements in the same order as the input."</span>] # [doc = <span class="string">""</span>] # [doc = <span class="string">" # Example"</span>] # [doc = <span class="string">" ```rust"</span>] # [doc = <span class="string">" # use hydro_lang::*;"</span>] # [doc = <span class="string">" # use dfir_rs::futures::StreamExt;"</span>] # [doc = <span class="string">" # tokio_test::block_on(test_util::stream_transform_test(|process| {"</span>] # [doc = <span class="string">" let numbers = process.source_iter(q!(0..10));"</span>] # [doc = <span class="string">" let mapped = numbers.map(q!(|n| n * 2));"</span>] # [doc = <span class="string">" # mapped"</span>] # [doc = <span class="string">" # }, |mut stream| async move {"</span>] # [doc = <span class="string">" // 2, 4, 6, 8, ..."</span>] # [doc = <span class="string">" # for i in 0..10 {"</span>] # [doc = <span class="string">" #     assert_eq!(stream.next().await.unwrap(), i * 2);"</span>] # [doc = <span class="string">" # }"</span>] # [doc = <span class="string">" # }));"</span>] # [doc = <span class="string">" ```"</span>] <span class="kw">pub fn </span>map &lt; U , F : Fn (T) -&gt; U + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Stream &lt; U , L , B , Order &gt; { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: Map { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>cloned (<span class="self">self</span>) -&gt; Stream &lt; T , L , B , Order &gt; <span class="kw">where </span>T : Clone , { <span class="self">self </span>. map (q ! (| d | d . clone ())) } <span class="kw">pub fn </span>flat_map_ordered &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Stream &lt; U , L , B , Order &gt; { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: FlatMap { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map_unordered &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Stream &lt; U , L , B , NoOrder &gt; { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: FlatMap { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flatten_ordered &lt; U &gt; (<span class="self">self</span>) -&gt; Stream &lt; U , L , B , Order &gt; <span class="kw">where </span>T : IntoIterator &lt; Item = U &gt; , { <span class="self">self </span>. flat_map_ordered (q ! (| d | d)) } <span class="kw">pub fn </span>flatten_unordered &lt; U &gt; (<span class="self">self</span>) -&gt; Stream &lt; U , L , B , NoOrder &gt; <span class="kw">where </span>T : IntoIterator &lt; Item = U &gt; , { <span class="self">self </span>. flat_map_unordered (q ! (| d | d)) } <span class="kw">pub fn </span>filter &lt; F : Fn (&amp; T) -&gt; bool + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Stream &lt; T , L , B , Order &gt; { <span class="kw">let </span>f = f . splice_fn1_borrow_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: Filter { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter_map &lt; U , F : Fn (T) -&gt; <span class="prelude-ty">Option </span>&lt; U &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Stream &lt; U , L , B , Order &gt; { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: FilterMap { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>cross_singleton &lt; O &gt; (<span class="self">self </span>, other : <span class="kw">impl </span>Into &lt; Optional &lt; O , L , Bounded &gt; &gt; ,) -&gt; Stream &lt; (T , O) , L , B , Order &gt; <span class="kw">where </span>O : Clone , { <span class="kw">let </span>other : Optional &lt; O , L , Bounded &gt; = other . into () ; check_matching_location (&amp; <span class="self">self </span>. location , &amp; other . location) ; Stream :: new (<span class="self">self </span>. location , HydroNode :: CrossSingleton (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } # [doc = <span class="string">" Allow this stream through if the other stream has elements, otherwise the output is empty."</span>] <span class="kw">pub fn </span>continue_if &lt; U &gt; (<span class="self">self </span>, signal : Optional &lt; U , L , Bounded &gt;) -&gt; Stream &lt; T , L , B , Order &gt; { <span class="self">self </span>. cross_singleton (signal . map (q ! (| _u | ()))) . map (q ! (| (d , _signal) | d)) } # [doc = <span class="string">" Allow this stream through if the other stream is empty, otherwise the output is empty."</span>] <span class="kw">pub fn </span>continue_unless &lt; U &gt; (<span class="self">self </span>, other : Optional &lt; U , L , Bounded &gt;) -&gt; Stream &lt; T , L , B , Order &gt; { <span class="self">self </span>. continue_if (other . into_stream () . count () . filter (q ! (| c | * c == <span class="number">0</span>))) } <span class="kw">pub fn </span>cross_product &lt; O &gt; (<span class="self">self </span>, other : Stream &lt; O , L , B , Order &gt;) -&gt; Stream &lt; (T , O) , L , B , Order &gt; <span class="kw">where </span>T : Clone , O : Clone , { check_matching_location (&amp; <span class="self">self </span>. location , &amp; other . location) ; Stream :: new (<span class="self">self </span>. location , HydroNode :: CrossProduct (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>unique (<span class="self">self</span>) -&gt; Stream &lt; T , L , B , Order &gt; <span class="kw">where </span>T : Eq + Hash , { Stream :: new (<span class="self">self </span>. location , HydroNode :: Unique (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>filter_not_in &lt; O2 &gt; (<span class="self">self </span>, other : Stream &lt; T , L , Bounded , O2 &gt;) -&gt; Stream &lt; T , L , Bounded , Order &gt; <span class="kw">where </span>T : Eq + Hash , { check_matching_location (&amp; <span class="self">self </span>. location , &amp; other . location) ; Stream :: new (<span class="self">self </span>. location , HydroNode :: Difference (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>inspect &lt; F : Fn (&amp; T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Stream &lt; T , L , B , Order &gt; { <span class="kw">let </span>f = f . splice_fn1_borrow_ctx (&amp; <span class="self">self </span>. location) . into () ; <span class="kw">if </span>L :: is_top_level () { Stream :: new (<span class="self">self </span>. location , HydroNode :: Persist (Box :: new (HydroNode :: Inspect { f , input : Box :: new (HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , })) ,) } <span class="kw">else </span>{ Stream :: new (<span class="self">self </span>. location , HydroNode :: Inspect { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } } # [doc = <span class="string">" Explicitly \"casts\" the stream to a type with a different ordering"</span>] # [doc = <span class="string">" guarantee. Useful in unsafe code where the ordering cannot be proven"</span>] # [doc = <span class="string">" by the type-system."</span>] # [doc = <span class="string">""</span>] # [doc = <span class="string">" # Safety"</span>] # [doc = <span class="string">" This function is used as an escape hatch, and any mistakes in the"</span>] # [doc = <span class="string">" provided ordering guarantee will propogate into the guarantees"</span>] # [doc = <span class="string">" for the rest of the program."</span>] <span class="kw">pub unsafe fn </span>assume_ordering &lt; O &gt; (<span class="self">self</span>) -&gt; Stream &lt; T , L , B , O &gt; { Stream :: new (<span class="self">self </span>. location , <span class="self">self </span>. ir_node . into_inner ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , B , Order &gt; Stream &lt; T , L , B , Order &gt; <span class="kw">where </span>Order : MinOrder &lt; NoOrder , Min = NoOrder &gt; , { <span class="kw">pub fn </span>fold_commutative &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, F : Fn (&amp; <span class="kw-2">mut </span>A , T) &gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I , L &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Singleton &lt; A , L , B &gt; { <span class="kw">let </span>init = init . splice_fn0_ctx (&amp; <span class="self">self </span>. location) . into () ; <span class="kw">let </span>comb = comb . splice_fn2_borrow_mut_ctx (&amp; <span class="self">self </span>. location) . into () ; <span class="kw">let </span><span class="kw-2">mut </span>core = HydroNode :: Fold { init , acc : comb , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ; <span class="kw">if </span>L :: is_top_level () { core = HydroNode :: Persist (Box :: new (core)) ; } Singleton :: new (<span class="self">self </span>. location , core) } <span class="kw">pub fn </span>reduce_commutative &lt; F : Fn (&amp; <span class="kw-2">mut </span>T , T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Optional &lt; T , L , B &gt; { <span class="kw">let </span>f = comb . splice_fn2_borrow_mut_ctx (&amp; <span class="self">self </span>. location) . into () ; <span class="kw">let </span><span class="kw-2">mut </span>core = HydroNode :: Reduce { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ; <span class="kw">if </span>L :: is_top_level () { core = HydroNode :: Persist (Box :: new (core)) ; } Optional :: new (<span class="self">self </span>. location , core) } <span class="kw">pub fn </span>max (<span class="self">self</span>) -&gt; Optional &lt; T , L , B &gt; <span class="kw">where </span>T : Ord , { <span class="self">self </span>. reduce_commutative (q ! (| curr , new | { <span class="kw">if </span>new &gt; * curr { * curr = new ; } })) } <span class="kw">pub fn </span>max_by_key &lt; K : Ord , F : Fn (&amp; T) -&gt; K + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, key : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; + Copy ,) -&gt; Optional &lt; T , L , B &gt; { <span class="kw">let </span>f = key . splice_fn1_borrow_ctx (&amp; <span class="self">self </span>. location) ; <span class="kw">let </span>wrapped : syn :: Expr = parse_quote ! ({ <span class="kw">let </span>key_fn = # f ; <span class="kw">move </span>| curr , new | { <span class="kw">if </span>key_fn (&amp; new) &gt; key_fn (<span class="kw-2">&amp;</span>* curr) { * curr = new ; } } }) ; <span class="kw">let </span><span class="kw-2">mut </span>core = HydroNode :: Reduce { f : wrapped . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ; <span class="kw">if </span>L :: is_top_level () { core = HydroNode :: Persist (Box :: new (core)) ; } Optional :: new (<span class="self">self </span>. location , core) } <span class="kw">pub fn </span>min (<span class="self">self</span>) -&gt; Optional &lt; T , L , B &gt; <span class="kw">where </span>T : Ord , { <span class="self">self </span>. reduce_commutative (q ! (| curr , new | { <span class="kw">if </span>new &lt; * curr { * curr = new ; } })) } <span class="kw">pub fn </span>count (<span class="self">self</span>) -&gt; Singleton &lt; usize , L , B &gt; { <span class="self">self </span>. fold_commutative (q ! (|| <span class="number">0usize</span>) , q ! (| count , <span class="kw">_ </span>| * count += <span class="number">1</span>)) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; Stream &lt; T , L , B , TotalOrder &gt; { <span class="kw">pub fn </span>enumerate (<span class="self">self</span>) -&gt; Stream &lt; (usize , T) , L , B , TotalOrder &gt; { <span class="kw">if </span>L :: is_top_level () { Stream :: new (<span class="self">self </span>. location , HydroNode :: Persist (Box :: new (HydroNode :: Enumerate { is_static : <span class="bool-val">true </span>, input : Box :: new (HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , })) ,) } <span class="kw">else </span>{ Stream :: new (<span class="self">self </span>. location , HydroNode :: Enumerate { is_static : <span class="bool-val">false </span>, input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } } <span class="kw">pub fn </span>first (<span class="self">self</span>) -&gt; Optional &lt; T , L , B &gt; { Optional :: new (<span class="self">self </span>. location , <span class="self">self </span>. ir_node . into_inner ()) } <span class="kw">pub fn </span>last (<span class="self">self</span>) -&gt; Optional &lt; T , L , B &gt; { <span class="self">self </span>. reduce (q ! (| curr , new | * curr = new)) } <span class="kw">pub fn </span>fold &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, F : Fn (&amp; <span class="kw-2">mut </span>A , T) &gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I , L &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Singleton &lt; A , L , B &gt; { <span class="kw">let </span>init = init . splice_fn0_ctx (&amp; <span class="self">self </span>. location) . into () ; <span class="kw">let </span>comb = comb . splice_fn2_borrow_mut_ctx (&amp; <span class="self">self </span>. location) . into () ; <span class="kw">let </span><span class="kw-2">mut </span>core = HydroNode :: Fold { init , acc : comb , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ; <span class="kw">if </span>L :: is_top_level () { core = HydroNode :: Persist (Box :: new (core)) ; } Singleton :: new (<span class="self">self </span>. location , core) } <span class="kw">pub fn </span>reduce &lt; F : Fn (&amp; <span class="kw-2">mut </span>T , T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Optional &lt; T , L , B &gt; { <span class="kw">let </span>f = comb . splice_fn2_borrow_mut_ctx (&amp; <span class="self">self </span>. location) . into () ; <span class="kw">let </span><span class="kw-2">mut </span>core = HydroNode :: Reduce { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ; <span class="kw">if </span>L :: is_top_level () { core = HydroNode :: Persist (Box :: new (core)) ; } Optional :: new (<span class="self">self </span>. location , core) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; T , L , Bounded , TotalOrder &gt; { <span class="kw">pub fn </span>chain (<span class="self">self </span>, other : Stream &lt; T , L , Bounded , TotalOrder &gt; ,) -&gt; Stream &lt; T , L , Bounded , TotalOrder &gt; { check_matching_location (&amp; <span class="self">self </span>. location , &amp; other . location) ; Stream :: new (<span class="self">self </span>. location , HydroNode :: Chain (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick + NoTimestamp &gt; Stream &lt; T , L , Unbounded , NoOrder &gt; { <span class="kw">pub fn </span>union (<span class="self">self </span>, other : Stream &lt; T , L , Unbounded , NoOrder &gt; ,) -&gt; Stream &lt; T , L , Unbounded , NoOrder &gt; { <span class="kw">let </span>tick = <span class="self">self </span>. location . tick () ; <span class="kw">unsafe </span>{ <span class="self">self </span>. timestamped (&amp; tick) . tick_batch () . union (other . timestamped (&amp; tick) . tick_batch ()) . all_ticks () . drop_timestamp () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , Order &gt; Stream &lt; T , L , Bounded , Order &gt; { <span class="kw">pub fn </span>sort (<span class="self">self</span>) -&gt; Stream &lt; T , L , Bounded , TotalOrder &gt; <span class="kw">where </span>T : Ord , { Stream :: new (<span class="self">self </span>. location , HydroNode :: Sort (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>union &lt; B2 , O2 &gt; (<span class="self">self </span>, other : Stream &lt; T , L , B2 , O2 &gt;) -&gt; Stream &lt; T , L , B2 , Order :: Min &gt; <span class="kw">where </span>Order : MinOrder &lt; O2 &gt; , { check_matching_location (&amp; <span class="self">self </span>. location , &amp; other . location) ; Stream :: new (<span class="self">self </span>. location , HydroNode :: Chain (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, K , V1 , L : Location &lt; <span class="lifetime">'a </span>&gt; , B , Order &gt; Stream &lt; (K , V1) , L , B , Order &gt; { <span class="kw">pub fn </span>join &lt; V2 , O2 &gt; (<span class="self">self </span>, n : Stream &lt; (K , V2) , L , B , O2 &gt;) -&gt; Stream &lt; (K , (V1 , V2)) , L , B , NoOrder &gt; <span class="kw">where </span>K : Eq + Hash , { check_matching_location (&amp; <span class="self">self </span>. location , &amp; n . location) ; Stream :: new (<span class="self">self </span>. location , HydroNode :: Join (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (n . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>anti_join &lt; O2 &gt; (<span class="self">self </span>, n : Stream &lt; K , L , Bounded , O2 &gt;) -&gt; Stream &lt; (K , V1) , L , B , Order &gt; <span class="kw">where </span>K : Eq + Hash , { check_matching_location (&amp; <span class="self">self </span>. location , &amp; n . location) ; Stream :: new (<span class="self">self </span>. location , HydroNode :: AntiJoin (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (n . ir_node . into_inner ()) ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, K : Eq + Hash , V , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Stream &lt; (K , V) , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">pub fn </span>fold_keyed &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, F : Fn (&amp; <span class="kw-2">mut </span>A , V) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I , Tick &lt; L &gt; &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , Tick &lt; L &gt; &gt; ,) -&gt; Stream &lt; (K , A) , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">let </span>init = init . splice_fn0_ctx (&amp; <span class="self">self </span>. location) . into () ; <span class="kw">let </span>comb = comb . splice_fn2_borrow_mut_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: FoldKeyed { init , acc : comb , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>reduce_keyed &lt; F : Fn (&amp; <span class="kw-2">mut </span>V , V) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , Tick &lt; L &gt; &gt; ,) -&gt; Stream &lt; (K , V) , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">let </span>f = comb . splice_fn2_borrow_mut_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: ReduceKeyed { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, K : Eq + Hash , V , L : Location &lt; <span class="lifetime">'a </span>&gt; , Order &gt; Stream &lt; (K , V) , Tick &lt; L &gt; , Bounded , Order &gt; { <span class="kw">pub fn </span>fold_keyed_commutative &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, F : Fn (&amp; <span class="kw-2">mut </span>A , V) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I , Tick &lt; L &gt; &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , Tick &lt; L &gt; &gt; ,) -&gt; Stream &lt; (K , A) , Tick &lt; L &gt; , Bounded , Order &gt; { <span class="kw">let </span>init = init . splice_fn0_ctx (&amp; <span class="self">self </span>. location) . into () ; <span class="kw">let </span>comb = comb . splice_fn2_borrow_mut_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: FoldKeyed { init , acc : comb , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>keys (<span class="self">self</span>) -&gt; Stream &lt; K , Tick &lt; L &gt; , Bounded , Order &gt; { <span class="self">self </span>. fold_keyed_commutative (q ! (|| ()) , q ! (| <span class="kw">_ </span>, <span class="kw">_ </span>| { })) . map (q ! (| (k , <span class="kw">_</span>) | k)) } <span class="kw">pub fn </span>reduce_keyed_commutative &lt; F : Fn (&amp; <span class="kw-2">mut </span>V , V) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , Tick &lt; L &gt; &gt; ,) -&gt; Stream &lt; (K , V) , Tick &lt; L &gt; , Bounded , Order &gt; { <span class="kw">let </span>f = comb . splice_fn2_borrow_mut_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: ReduceKeyed { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B , Order &gt; Stream &lt; T , Timestamped &lt; L &gt; , B , Order &gt; { # [doc = <span class="string">" Given a tick, returns a stream corresponding to a batch of elements for that tick."</span>] # [doc = <span class="string">" These batches are guaranteed to be contiguous across ticks and preserve the order"</span>] # [doc = <span class="string">" of the input."</span>] # [doc = <span class="string">""</span>] # [doc = <span class="string">" # Safety"</span>] # [doc = <span class="string">" The batch boundaries are non-deterministic and may change across executions."</span>] <span class="kw">pub unsafe fn </span>tick_batch (<span class="self">self</span>) -&gt; Stream &lt; T , Tick &lt; L &gt; , Bounded , Order &gt; { Stream :: new (<span class="self">self </span>. location . tick , HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>drop_timestamp (<span class="self">self</span>) -&gt; Stream &lt; T , L , B , Order &gt; { Stream :: new (<span class="self">self </span>. location . tick . l , <span class="self">self </span>. ir_node . into_inner ()) } <span class="kw">pub fn </span>timestamp_source (&amp; <span class="self">self</span>) -&gt; Tick &lt; L &gt; { <span class="self">self </span>. location . tick . clone () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick + NoTimestamp , B , Order &gt; Stream &lt; T , L , B , Order &gt; { <span class="kw">pub fn </span>timestamped (<span class="self">self </span>, tick : &amp; Tick &lt; L &gt;) -&gt; Stream &lt; T , Timestamped &lt; L &gt; , B , Order &gt; { Stream :: new (Timestamped { tick : tick . clone () } , <span class="self">self </span>. ir_node . into_inner () ,) } # [doc = <span class="string">" Given a time interval, returns a stream corresponding to samples taken from the"</span>] # [doc = <span class="string">" stream roughly at that interval. The output will have elements in the same order"</span>] # [doc = <span class="string">" as the input, but with arbitrary elements skipped between samples. There is also"</span>] # [doc = <span class="string">" no guarantee on the exact timing of the samples."</span>] # [doc = <span class="string">""</span>] # [doc = <span class="string">" # Safety"</span>] # [doc = <span class="string">" The output stream is non-deterministic in which elements are sampled, since this"</span>] # [doc = <span class="string">" is controlled by a clock."</span>] <span class="kw">pub unsafe fn </span>sample_every (<span class="self">self </span>, interval : <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, std :: time :: Duration , L &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; T , L , Unbounded , Order &gt; { <span class="kw">let </span>samples = <span class="kw">unsafe </span>{ <span class="self">self </span>. location . source_interval (interval) } ; <span class="kw">let </span>tick = <span class="self">self </span>. location . tick () ; <span class="kw">unsafe </span>{ <span class="self">self </span>. timestamped (&amp; tick) . tick_batch () . continue_if (samples . timestamped (&amp; tick) . tick_batch () . first ()) . all_ticks () . drop_timestamp () } } # [doc = <span class="string">" Given a timeout duration, returns an [`Optional`]  which will have a value if the"</span>] # [doc = <span class="string">" stream has not emitted a value since that duration."</span>] # [doc = <span class="string">""</span>] # [doc = <span class="string">" # Safety"</span>] # [doc = <span class="string">" Timeout relies on non-deterministic sampling of the stream, so depending on when"</span>] # [doc = <span class="string">" samples take place, timeouts may be non-deterministically generated or missed,"</span>] # [doc = <span class="string">" and the notification of the timeout may be delayed as well. There is also no"</span>] # [doc = <span class="string">" guarantee on how long the [`Optional`] will have a value after the timeout is"</span>] # [doc = <span class="string">" detected based on when the next sample is taken."</span>] <span class="kw">pub unsafe fn </span>timeout (<span class="self">self </span>, duration : <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, std :: time :: Duration , Tick &lt; L &gt; &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Optional &lt; () , L , Unbounded &gt; <span class="kw">where </span>Order : MinOrder &lt; NoOrder , Min = NoOrder &gt; , { <span class="kw">let </span>tick = <span class="self">self </span>. location . tick () ; <span class="kw">let </span>latest_received = <span class="self">self </span>. fold_commutative (q ! (|| <span class="prelude-val">None</span>) , q ! (| latest , <span class="kw">_ </span>| { * latest = <span class="prelude-val">Some </span>(Instant :: now ()) ; }) ,) ; <span class="kw">unsafe </span>{ latest_received . timestamped (&amp; tick) . latest_tick () } . filter_map (q ! (<span class="kw">move </span>| latest_received | { <span class="kw">if let </span><span class="prelude-val">Some </span>(latest_received) = latest_received { <span class="kw">if </span>Instant :: now () . duration_since (latest_received) &gt; duration { <span class="prelude-val">Some </span>(()) } <span class="kw">else </span>{ <span class="prelude-val">None </span>} } <span class="kw">else </span>{ <span class="prelude-val">Some </span>(()) } })) . latest () . drop_timestamp () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B , Order &gt; Stream &lt; T , L , B , Order &gt; { <span class="kw">pub fn </span>for_each &lt; F : Fn (T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt;) { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; <span class="self">self </span>. location . flow_state () . borrow_mut () . leaves . as_mut () . expect (FLOW_USED_MESSAGE) . push (HydroLeaf :: ForEach { input : Box :: new (HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , f , }) ; } <span class="kw">pub fn </span>dest_sink &lt; S : Unpin + futures :: Sink &lt; T &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, sink : <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, S , L &gt; ,) { <span class="self">self </span>. location . flow_state () . borrow_mut () . leaves . as_mut () . expect (FLOW_USED_MESSAGE) . push (HydroLeaf :: DestSink { sink : sink . splice_typed_ctx (&amp; <span class="self">self </span>. location) . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , Order &gt; Stream &lt; T , Tick &lt; L &gt; , Bounded , Order &gt; { <span class="kw">pub fn </span>all_ticks (<span class="self">self</span>) -&gt; Stream &lt; T , Timestamped &lt; L &gt; , Unbounded , Order &gt; { Stream :: new (Timestamped { tick : <span class="self">self </span>. location . clone () , } , HydroNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>persist (<span class="self">self</span>) -&gt; Stream &lt; T , Tick &lt; L &gt; , Bounded , Order &gt; <span class="kw">where </span>T : Clone , { Stream :: new (<span class="self">self </span>. location , HydroNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>defer_tick (<span class="self">self</span>) -&gt; Stream &lt; T , Tick &lt; L &gt; , Bounded , Order &gt; { Stream :: new (<span class="self">self </span>. location , HydroNode :: DeferTick (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>delta (<span class="self">self</span>) -&gt; Stream &lt; T , Tick &lt; L &gt; , Bounded , Order &gt; { Stream :: new (<span class="self">self </span>. location , HydroNode :: Delta (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } } <span class="kw">pub fn </span>serialize_bincode &lt; T : Serialize &gt; (is_demux : bool) -&gt; syn :: Expr { <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span>t_type : syn :: Type = stageleft :: quote_type :: &lt; T &gt; () ; <span class="kw">if </span>is_demux { parse_quote ! { | (id , data) : (# root :: ClusterId &lt; <span class="kw">_ </span>&gt;, # t_type) | { (id . raw_id , # root :: runtime_support :: bincode :: serialize ::&lt;# t_type &gt; (&amp; data) . unwrap () . into ()) } } } <span class="kw">else </span>{ parse_quote ! { | data | { # root :: runtime_support :: bincode :: serialize ::&lt;# t_type &gt; (&amp; data) . unwrap () . into () } } } } <span class="kw">pub fn </span>deserialize_bincode &lt; T : DeserializeOwned &gt; (tagged : <span class="prelude-ty">Option </span>&lt; syn :: Type &gt;) -&gt; syn :: Expr { <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span>t_type : syn :: Type = stageleft :: quote_type :: &lt; T &gt; () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(c_type) = tagged { parse_quote ! { | res | { <span class="kw">let </span>(id , b) = res . unwrap () ; (# root :: ClusterId ::&lt;# c_type &gt;:: from_raw (id) , # root :: runtime_support :: bincode :: deserialize ::&lt;# t_type &gt; (&amp; b) . unwrap ()) } } } <span class="kw">else </span>{ parse_quote ! { | res | { # root :: runtime_support :: bincode :: deserialize ::&lt;# t_type &gt; (&amp; res . unwrap ()) . unwrap () } } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , C1 , B , Order &gt; Stream &lt; T , Cluster &lt; <span class="lifetime">'a </span>, C1 &gt; , B , Order &gt; { <span class="kw">pub fn </span>decouple_cluster &lt; C2 : <span class="lifetime">'a </span>, Tag &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; T , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , Unbounded , Order &gt; <span class="kw">where </span>Cluster &lt; <span class="lifetime">'a </span>, C1 &gt; : Location &lt; <span class="lifetime">'a </span>, Root = Cluster &lt; <span class="lifetime">'a </span>, C1 &gt; &gt; , Cluster &lt; <span class="lifetime">'a </span>, C1 &gt; : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; T &gt; = (ClusterId &lt; C2 &gt; , T) , Out &lt; T &gt; = (Tag , T) &gt; , T : Clone + Serialize + DeserializeOwned , Order : MinOrder &lt; &lt; Cluster &lt; <span class="lifetime">'a </span>, C1 &gt; <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; Order &gt; &gt; , { <span class="kw">let </span>sent = <span class="self">self </span>. map (q ! (<span class="kw">move </span>| b | (ClusterId :: from_raw (CLUSTER_SELF_ID . raw_id) , b . clone ()))) . send_bincode_interleaved (other) ; <span class="kw">unsafe </span>{ sent . assume_ordering () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B , Order &gt; Stream &lt; T , L , B , Order &gt; { <span class="kw">pub fn </span>decouple_process &lt; P2 &gt; (<span class="self">self </span>, other : &amp; Process &lt; <span class="lifetime">'a </span>, P2 &gt; ,) -&gt; Stream &lt; T , Process &lt; <span class="lifetime">'a </span>, P2 &gt; , Unbounded , Order &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, Process &lt; <span class="lifetime">'a </span>, P2 &gt; , In &lt; T &gt; = T , Out &lt; T &gt; = T &gt; , T : Clone + Serialize + DeserializeOwned , Order : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Process &lt; <span class="lifetime">'a </span>, P2 &gt; &gt; &gt; :: OutStrongestOrder &lt; Order &gt; , Min = Order , &gt; , { <span class="self">self </span>. send_bincode :: &lt; Process &lt; <span class="lifetime">'a </span>, P2 &gt; , T &gt; (other) } <span class="kw">pub fn </span>send_bincode &lt; L2 : Location &lt; <span class="lifetime">'a </span>&gt; , CoreType &gt; (<span class="self">self </span>, other : &amp; L2 ,) -&gt; Stream &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, L2 &gt; &gt; :: Out &lt; CoreType &gt; , L2 , Unbounded , Order :: Min &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, L2 , In &lt; CoreType &gt; = T &gt; , CoreType : Serialize + DeserializeOwned , Order : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, L2 &gt; &gt; :: OutStrongestOrder &lt; Order &gt; &gt; , { <span class="kw">let </span>serialize_pipeline = <span class="prelude-val">Some </span>(serialize_bincode :: &lt; CoreType &gt; (L :: Root :: is_demux ())) ; <span class="kw">let </span>deserialize_pipeline = <span class="prelude-val">Some </span>(deserialize_bincode :: &lt; CoreType &gt; (L :: Root :: tagged_type ())) ; Stream :: new (other . clone () , HydroNode :: Network { from_location : <span class="self">self </span>. location . root () . id () , from_key : <span class="prelude-val">None </span>, to_location : other . id () , to_key : <span class="prelude-val">None </span>, serialize_fn : serialize_pipeline . map (| e | e . into ()) , instantiate_fn : DebugInstantiate :: Building () , deserialize_fn : deserialize_pipeline . map (| e | e . into ()) , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>send_bincode_external &lt; L2 : <span class="lifetime">'a </span>, CoreType &gt; (<span class="self">self </span>, other : &amp; ExternalProcess &lt; L2 &gt; ,) -&gt; ExternalBincodeStream &lt; L :: Out &lt; CoreType &gt; &gt; <span class="kw">where </span>L : CanSend &lt; <span class="lifetime">'a </span>, ExternalProcess &lt; <span class="lifetime">'a </span>, L2 &gt; , In &lt; CoreType &gt; = T , Out &lt; CoreType &gt; = CoreType &gt; , CoreType : Serialize + DeserializeOwned , { <span class="kw">let </span>serialize_pipeline = <span class="prelude-val">Some </span>(serialize_bincode :: &lt; CoreType &gt; (L :: is_demux ())) ; <span class="kw">let </span><span class="kw-2">mut </span>flow_state_borrow = <span class="self">self </span>. location . flow_state () . borrow_mut () ; <span class="kw">let </span>external_key = flow_state_borrow . next_external_out ; flow_state_borrow . next_external_out += <span class="number">1 </span>; <span class="kw">let </span>leaves = flow_state_borrow . leaves . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled()"</span>) ; <span class="kw">let </span>dummy_f : syn :: Expr = syn :: parse_quote ! (()) ; leaves . push (HydroLeaf :: ForEach { f : dummy_f . into () , input : Box :: new (HydroNode :: Network { from_location : <span class="self">self </span>. location . root () . id () , from_key : <span class="prelude-val">None </span>, to_location : other . id () , to_key : <span class="prelude-val">Some </span>(external_key) , serialize_fn : serialize_pipeline . map (| e | e . into ()) , instantiate_fn : DebugInstantiate :: Building () , deserialize_fn : <span class="prelude-val">None </span>, input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) , }) ; ExternalBincodeStream { process_id : other . id , port_id : external_key , _phantom : PhantomData , } } <span class="kw">pub fn </span>send_bytes &lt; L2 : Location &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, other : &amp; L2 ,) -&gt; Stream &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, L2 &gt; &gt; :: Out &lt; Bytes &gt; , L2 , Unbounded , Order :: Min &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, L2 , In &lt; Bytes &gt; = T &gt; , Order : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, L2 &gt; &gt; :: OutStrongestOrder &lt; Order &gt; &gt; , { <span class="kw">let </span>root = get_this_crate () ; Stream :: new (other . clone () , HydroNode :: Network { from_location : <span class="self">self </span>. location . root () . id () , from_key : <span class="prelude-val">None </span>, to_location : other . id () , to_key : <span class="prelude-val">None </span>, serialize_fn : <span class="prelude-val">None </span>, instantiate_fn : DebugInstantiate :: Building () , deserialize_fn : <span class="kw">if let </span><span class="prelude-val">Some </span>(c_type) = L :: Root :: tagged_type () { <span class="kw">let </span>expr : syn :: Expr = parse_quote ! (| (id , b) | (# root :: ClusterId &lt;# c_type &gt;:: from_raw (id) , b . unwrap () . freeze ())) ; <span class="prelude-val">Some </span>(expr . into ()) } <span class="kw">else </span>{ <span class="kw">let </span>expr : syn :: Expr = parse_quote ! (| b | b . unwrap () . freeze ()) ; <span class="prelude-val">Some </span>(expr . into ()) } , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>send_bytes_external &lt; L2 : <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, other : &amp; ExternalProcess &lt; L2 &gt;) -&gt; ExternalBytesPort <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, ExternalProcess &lt; <span class="lifetime">'a </span>, L2 &gt; , In &lt; Bytes &gt; = T , Out &lt; Bytes &gt; = Bytes &gt; , { <span class="kw">let </span><span class="kw-2">mut </span>flow_state_borrow = <span class="self">self </span>. location . flow_state () . borrow_mut () ; <span class="kw">let </span>external_key = flow_state_borrow . next_external_out ; flow_state_borrow . next_external_out += <span class="number">1 </span>; <span class="kw">let </span>leaves = flow_state_borrow . leaves . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled()"</span>) ; <span class="kw">let </span>dummy_f : syn :: Expr = syn :: parse_quote ! (()) ; leaves . push (HydroLeaf :: ForEach { f : dummy_f . into () , input : Box :: new (HydroNode :: Network { from_location : <span class="self">self </span>. location . root () . id () , from_key : <span class="prelude-val">None </span>, to_location : other . id () , to_key : <span class="prelude-val">Some </span>(external_key) , serialize_fn : <span class="prelude-val">None </span>, instantiate_fn : DebugInstantiate :: Building () , deserialize_fn : <span class="prelude-val">None </span>, input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) , }) ; ExternalBytesPort { process_id : other . id , port_id : external_key , } } <span class="kw">pub fn </span>send_bincode_interleaved &lt; L2 : Location &lt; <span class="lifetime">'a </span>&gt; , Tag , CoreType &gt; (<span class="self">self </span>, other : &amp; L2 ,) -&gt; Stream &lt; CoreType , L2 , Unbounded , Order :: Min &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, L2 , In &lt; CoreType &gt; = T , Out &lt; CoreType &gt; = (Tag , CoreType) &gt; , CoreType : Serialize + DeserializeOwned , Order : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, L2 &gt; &gt; :: OutStrongestOrder &lt; Order &gt; &gt; , { <span class="self">self </span>. send_bincode :: &lt; L2 , CoreType &gt; (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>send_bytes_interleaved &lt; L2 : Location &lt; <span class="lifetime">'a </span>&gt; , Tag &gt; (<span class="self">self </span>, other : &amp; L2 ,) -&gt; Stream &lt; Bytes , L2 , Unbounded , Order :: Min &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, L2 , In &lt; Bytes &gt; = T , Out &lt; Bytes &gt; = (Tag , Bytes) &gt; , Order : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, L2 &gt; &gt; :: OutStrongestOrder &lt; Order &gt; &gt; , { <span class="self">self </span>. send_bytes :: &lt; L2 &gt; (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } # [expect (clippy :: type_complexity , reason = <span class="string">"ordering semantics for broadcast"</span>)] <span class="kw">pub fn </span>broadcast_bincode &lt; C2 : <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: Out &lt; T &gt; , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , Unbounded , Order :: Min , &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; T &gt; = (ClusterId &lt; C2 &gt; , T) &gt; , T : Clone + Serialize + DeserializeOwned , Order : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; Order &gt; &gt; , { <span class="kw">let </span>ids = other . members () ; <span class="self">self </span>. flat_map_ordered (q ! (| b | ids . iter () . map (<span class="kw">move </span>| id | (:: std :: clone :: Clone :: clone (id) , :: std :: clone :: Clone :: clone (&amp; b))))) . send_bincode (other) } <span class="kw">pub fn </span>broadcast_bincode_interleaved &lt; C2 : <span class="lifetime">'a </span>, Tag &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; T , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , Unbounded , Order :: Min &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; T &gt; = (ClusterId &lt; C2 &gt; , T) , Out &lt; T &gt; = (Tag , T) &gt; + <span class="lifetime">'a </span>, T : Clone + Serialize + DeserializeOwned , Order : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; Order &gt; &gt; , { <span class="self">self </span>. broadcast_bincode (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } # [expect (clippy :: type_complexity , reason = <span class="string">"ordering semantics for broadcast"</span>)] <span class="kw">pub fn </span>broadcast_bytes &lt; C2 : <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: Out &lt; Bytes &gt; , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , Unbounded , Order :: Min , &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; Bytes &gt; = (ClusterId &lt; C2 &gt; , T) &gt; + <span class="lifetime">'a </span>, T : Clone , Order : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; Order &gt; &gt; , { <span class="kw">let </span>ids = other . members () ; <span class="self">self </span>. flat_map_ordered (q ! (| b | ids . iter () . map (<span class="kw">move </span>| id | (:: std :: clone :: Clone :: clone (id) , :: std :: clone :: Clone :: clone (&amp; b))))) . send_bytes (other) } <span class="kw">pub fn </span>broadcast_bytes_interleaved &lt; C2 : <span class="lifetime">'a </span>, Tag &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; Bytes , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , Unbounded , Order :: Min &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; Bytes &gt; = (ClusterId &lt; C2 &gt; , T) , Out &lt; Bytes &gt; = (Tag , Bytes) &gt; + <span class="lifetime">'a </span>, T : Clone , Order : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; Order &gt; &gt; , { <span class="self">self </span>. broadcast_bytes (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } } # [cfg (stageleft_macro)] # [expect (clippy :: type_complexity , reason = <span class="string">"ordering semantics for round-robin"</span>)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B &gt; Stream &lt; T , L , B , TotalOrder &gt; { <span class="kw">pub fn </span>round_robin_bincode &lt; C2 : <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: Out &lt; T &gt; , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , Unbounded , &lt; TotalOrder <span class="kw">as </span>MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; TotalOrder &gt; , &gt; &gt; :: Min , &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; T &gt; = (ClusterId &lt; C2 &gt; , T) &gt; , T : Clone + Serialize + DeserializeOwned , TotalOrder : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; TotalOrder &gt; &gt; , { <span class="kw">let </span>ids = other . members () ; <span class="self">self </span>. enumerate () . map (q ! (| (i , w) | (ids [i % ids . len ()] , w))) . send_bincode (other) } <span class="kw">pub fn </span>round_robin_bincode_interleaved &lt; C2 : <span class="lifetime">'a </span>, Tag &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; T , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , Unbounded , &lt; TotalOrder <span class="kw">as </span>MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; TotalOrder &gt; , &gt; &gt; :: Min , &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; T &gt; = (ClusterId &lt; C2 &gt; , T) , Out &lt; T &gt; = (Tag , T) &gt; + <span class="lifetime">'a </span>, T : Clone + Serialize + DeserializeOwned , TotalOrder : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; TotalOrder &gt; &gt; , { <span class="self">self </span>. round_robin_bincode (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>round_robin_bytes &lt; C2 : <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: Out &lt; Bytes &gt; , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , Unbounded , &lt; TotalOrder <span class="kw">as </span>MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; TotalOrder &gt; , &gt; &gt; :: Min , &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; Bytes &gt; = (ClusterId &lt; C2 &gt; , T) &gt; + <span class="lifetime">'a </span>, T : Clone , TotalOrder : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; TotalOrder &gt; &gt; , { <span class="kw">let </span>ids = other . members () ; <span class="self">self </span>. enumerate () . map (q ! (| (i , w) | (ids [i % ids . len ()] , w))) . send_bytes (other) } <span class="kw">pub fn </span>round_robin_bytes_interleaved &lt; C2 : <span class="lifetime">'a </span>, Tag &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; ,) -&gt; Stream &lt; Bytes , Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , Unbounded , &lt; TotalOrder <span class="kw">as </span>MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; TotalOrder &gt; , &gt; &gt; :: Min , &gt; <span class="kw">where </span>L :: Root : CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; , In &lt; Bytes &gt; = (ClusterId &lt; C2 &gt; , T) , Out &lt; Bytes &gt; = (Tag , Bytes) &gt; + <span class="lifetime">'a </span>, T : Clone , TotalOrder : MinOrder &lt; &lt; L :: Root <span class="kw">as </span>CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; &gt; :: OutStrongestOrder &lt; TotalOrder &gt; &gt; , { <span class="self">self </span>. round_robin_bytes (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } } # [cfg (stageleft_macro)] <span class="kw">pub mod </span>tests { <span class="kw">pub use </span>dfir_rs :: futures :: StreamExt ; <span class="kw">pub use </span>hydro_deploy :: Deployment ; <span class="kw">pub use </span>serde :: { Deserialize , Serialize } ; <span class="kw">pub use </span>stageleft :: q ; <span class="kw">pub use crate </span>:: __staged :: location :: Location ; <span class="kw">pub use crate </span>:: __staged :: FlowBuilder ; <span class="kw">pub struct </span>P1 { } <span class="kw">pub struct </span>P2 { } # [derive (Serialize , Deserialize , Debug)] <span class="kw">pub struct </span>SendOverNetwork { <span class="kw">pub </span>n : u32 , } # [tokio :: test] <span class="kw">pub async fn </span>first_ten_distributed () { <span class="kw">let </span><span class="kw-2">mut </span>deployment = Deployment :: new () ; <span class="kw">let </span>flow = FlowBuilder :: new () ; <span class="kw">let </span>first_node = flow . process :: &lt; P1 &gt; () ; <span class="kw">let </span>second_node = flow . process :: &lt; P2 &gt; () ; <span class="kw">let </span>external = flow . external_process :: &lt; P2 &gt; () ; <span class="kw">let </span>numbers = first_node . source_iter (q ! (<span class="number">0 </span>.. <span class="number">10</span>)) ; <span class="kw">let </span>out_port = numbers . map (q ! (| n | SendOverNetwork { n })) . send_bincode (&amp; second_node) . send_bincode_external (&amp; external) ; <span class="kw">let </span>nodes = flow . with_process (&amp; first_node , deployment . Localhost ()) . with_process (&amp; second_node , deployment . Localhost ()) . with_external (&amp; external , deployment . Localhost ()) . deploy (&amp; <span class="kw-2">mut </span>deployment) ; deployment . deploy () . <span class="kw">await </span>. unwrap () ; <span class="kw">let </span><span class="kw-2">mut </span>external_out = nodes . connect_source_bincode (out_port) . <span class="kw">await </span>; deployment . start () . <span class="kw">await </span>. unwrap () ; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10 </span>{ assert_eq ! (external_out . next () . <span class="kw">await </span>. unwrap () . n , i) ; } } } } <span class="kw">pub use </span>stream :: { NoOrder , Stream , TotalOrder } ; <span class="kw">pub mod </span>singleton { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>stageleft :: { q , IntoQuotedMut , QuotedWithContext } ; <span class="kw">pub use crate </span>:: __staged :: builder :: FLOW_USED_MESSAGE ; <span class="kw">pub use crate </span>:: __staged :: cycle :: { CycleCollection , CycleCollectionWithInitial , CycleComplete , DeferTick , ForwardRefMarker , TickCycleMarker , } ; <span class="kw">pub use crate </span>:: __staged :: ir :: { HydroLeaf , HydroNode , TeeNode } ; <span class="kw">pub use crate </span>:: __staged :: location :: tick :: { NoTimestamp , Timestamped } ; <span class="kw">pub use crate </span>:: __staged :: location :: { check_matching_location , Location , LocationId , NoTick , Tick } ; <span class="kw">pub use crate </span>:: __staged :: { Bounded , Optional , Stream , Unbounded } ; <span class="kw">pub use crate </span>:: singleton :: Singleton ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; Singleton &lt; T , L , B &gt; { <span class="kw">pub </span>(<span class="kw">crate</span>) <span class="kw">fn </span>new (location : L , ir_node : HydroNode) -&gt; <span class="self">Self </span>{ Singleton { location , ir_node : RefCell :: new (ir_node) , _phantom : PhantomData , } } <span class="kw">fn </span>location_kind (&amp; <span class="self">self</span>) -&gt; LocationId { <span class="self">self </span>. location . id () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; From &lt; Singleton &lt; T , L , Bounded &gt; &gt; <span class="kw">for </span>Singleton &lt; T , L , Unbounded &gt; { <span class="kw">fn </span>from (singleton : Singleton &lt; T , L , Bounded &gt;) -&gt; <span class="self">Self </span>{ Singleton :: new (singleton . location , singleton . ir_node . into_inner ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; DeferTick <span class="kw">for </span>Singleton &lt; T , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">fn </span>defer_tick (<span class="self">self</span>) -&gt; <span class="self">Self </span>{ Singleton :: defer_tick (<span class="self">self</span>) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleCollectionWithInitial &lt; <span class="lifetime">'a </span>, TickCycleMarker &gt; <span class="kw">for </span>Singleton &lt; T , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">type </span>Location = Tick &lt; L &gt; ; <span class="kw">fn </span>create_source (ident : syn :: Ident , initial : <span class="self">Self </span>, location : Tick &lt; L &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>location_id = location . id () ; Singleton :: new (location , HydroNode :: Chain (Box :: new (HydroNode :: CycleSource { ident , location_kind : location_id , }) , initial . ir_node . into_inner () . into () ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleComplete &lt; <span class="lifetime">'a </span>, TickCycleMarker &gt; <span class="kw">for </span>Singleton &lt; T , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident , expected_location : LocationId) { assert_eq ! (<span class="self">self </span>. location . id () , expected_location , <span class="string">"locations do not match"</span>) ; <span class="self">self </span>. location . flow_state () . borrow_mut () . leaves . as_mut () . expect (FLOW_USED_MESSAGE) . push (HydroLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleCollection &lt; <span class="lifetime">'a </span>, ForwardRefMarker &gt; <span class="kw">for </span>Singleton &lt; T , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">type </span>Location = Tick &lt; L &gt; ; <span class="kw">fn </span>create_source (ident : syn :: Ident , location : Tick &lt; L &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>location_id = location . id () ; Singleton :: new (location , HydroNode :: CycleSource { ident , location_kind : location_id , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleComplete &lt; <span class="lifetime">'a </span>, ForwardRefMarker &gt; <span class="kw">for </span>Singleton &lt; T , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident , expected_location : LocationId) { assert_eq ! (<span class="self">self </span>. location . id () , expected_location , <span class="string">"locations do not match"</span>) ; <span class="self">self </span>. location . flow_state () . borrow_mut () . leaves . as_mut () . expect (FLOW_USED_MESSAGE) . push (HydroLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B &gt; CycleCollection &lt; <span class="lifetime">'a </span>, ForwardRefMarker &gt; <span class="kw">for </span>Singleton &lt; T , L , B &gt; { <span class="kw">type </span>Location = L ; <span class="kw">fn </span>create_source (ident : syn :: Ident , location : L) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>location_id = location . id () ; Singleton :: new (location , HydroNode :: Persist (Box :: new (HydroNode :: CycleSource { ident , location_kind : location_id , })) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B &gt; CycleComplete &lt; <span class="lifetime">'a </span>, ForwardRefMarker &gt; <span class="kw">for </span>Singleton &lt; T , L , B &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident , expected_location : LocationId) { assert_eq ! (<span class="self">self </span>. location . id () , expected_location , <span class="string">"locations do not match"</span>) ; <span class="self">self </span>. location . flow_state () . borrow_mut () . leaves . as_mut () . expect (FLOW_USED_MESSAGE) . push (HydroLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind () , input : Box :: new (HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; Clone <span class="kw">for </span>Singleton &lt; T , L , B &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ <span class="kw">if </span>! matches ! (<span class="self">self </span>. ir_node . borrow () . deref () , HydroNode :: Tee { .. }) { <span class="kw">let </span>orig_ir_node = <span class="self">self </span>. ir_node . replace (HydroNode :: Placeholder) ; * <span class="self">self </span>. ir_node . borrow_mut () = HydroNode :: Tee { inner : TeeNode (Rc :: new (RefCell :: new (orig_ir_node))) , } ; } <span class="kw">if let </span>HydroNode :: Tee { inner } = <span class="self">self </span>. ir_node . borrow () . deref () { Singleton { location : <span class="self">self </span>. location . clone () , ir_node : HydroNode :: Tee { inner : TeeNode (inner . <span class="number">0 </span>. clone ()) , } . into () , _phantom : PhantomData , } } <span class="kw">else </span>{ unreachable ! () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; Singleton &lt; T , L , B &gt; { <span class="kw">pub fn </span>map &lt; U , F : Fn (T) -&gt; U + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt;) -&gt; Singleton &lt; U , L , B &gt; { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; Singleton :: new (<span class="self">self </span>. location , HydroNode :: Map { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map_ordered &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Stream &lt; U , L , B &gt; { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: FlatMap { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map_unordered &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Stream &lt; U , L , B &gt; { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: FlatMap { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter &lt; F : Fn (&amp; T) -&gt; bool + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Optional &lt; T , L , B &gt; { <span class="kw">let </span>f = f . splice_fn1_borrow_ctx (&amp; <span class="self">self </span>. location) . into () ; Optional :: new (<span class="self">self </span>. location , HydroNode :: Filter { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter_map &lt; U , F : Fn (T) -&gt; <span class="prelude-ty">Option </span>&lt; U &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Optional &lt; U , L , B &gt; { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; Optional :: new (<span class="self">self </span>. location , HydroNode :: FilterMap { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>zip &lt; Other &gt; (<span class="self">self </span>, other : Other) -&gt; &lt; <span class="self">Self </span><span class="kw">as </span>ZipResult &lt; <span class="lifetime">'a </span>, Other &gt; &gt; :: Out <span class="kw">where </span><span class="self">Self </span>: ZipResult &lt; <span class="lifetime">'a </span>, Other , Location = L &gt; , { check_matching_location (&amp; <span class="self">self </span>. location , &amp; <span class="self">Self </span>:: other_location (&amp; other)) ; <span class="kw">if </span>L :: is_top_level () { <span class="self">Self </span>:: make (<span class="self">self </span>. location , HydroNode :: Persist (Box :: new (HydroNode :: CrossSingleton (Box :: new (HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , Box :: new (HydroNode :: Unpersist (Box :: new (<span class="self">Self </span>:: other_ir_node (other)))) ,))) ,) } <span class="kw">else </span>{ <span class="self">Self </span>:: make (<span class="self">self </span>. location , HydroNode :: CrossSingleton (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (<span class="self">Self </span>:: other_ir_node (other)) ,) ,) } } <span class="kw">pub fn </span>continue_if &lt; U &gt; (<span class="self">self </span>, signal : Optional &lt; U , L , Bounded &gt;) -&gt; Optional &lt; T , L , Bounded &gt; <span class="kw">where </span><span class="self">Self </span>: ZipResult &lt; <span class="lifetime">'a </span>, Optional &lt; () , L , Bounded &gt; , Location = L , Out = Optional &lt; (T , ()) , L , Bounded &gt; , &gt; , { <span class="self">self </span>. zip (signal . map (q ! (| _u | ()))) . map (q ! (| (d , _signal) | d)) } <span class="kw">pub fn </span>continue_unless &lt; U &gt; (<span class="self">self </span>, other : Optional &lt; U , L , Bounded &gt;) -&gt; Optional &lt; T , L , Bounded &gt; <span class="kw">where </span>Singleton &lt; T , L , B &gt; : ZipResult &lt; <span class="lifetime">'a </span>, Optional &lt; () , L , Bounded &gt; , Location = L , Out = Optional &lt; (T , ()) , L , Bounded &gt; , &gt; , { <span class="self">self </span>. continue_if (other . into_stream () . count () . filter (q ! (| c | * c == <span class="number">0</span>))) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B &gt; Singleton &lt; T , Timestamped &lt; L &gt; , B &gt; { # [doc = <span class="string">" Given a tick, returns a singleton value corresponding to a snapshot of the singleton"</span>] # [doc = <span class="string">" as of that tick. The snapshot at tick `t + 1` is guaranteed to include at least all"</span>] # [doc = <span class="string">" relevant data that contributed to the snapshot at tick `t`."</span>] # [doc = <span class="string">""</span>] # [doc = <span class="string">" # Safety"</span>] # [doc = <span class="string">" Because this picks a snapshot of a singleton whose value is continuously changing,"</span>] # [doc = <span class="string">" the output singleton has a non-deterministic value since the snapshot can be at an"</span>] # [doc = <span class="string">" arbitrary point in time."</span>] <span class="kw">pub unsafe fn </span>latest_tick (<span class="self">self</span>) -&gt; Singleton &lt; T , Tick &lt; L &gt; , Bounded &gt; { Singleton :: new (<span class="self">self </span>. location . tick , HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>drop_timestamp (<span class="self">self</span>) -&gt; Optional &lt; T , L , B &gt; { Optional :: new (<span class="self">self </span>. location . tick . l , <span class="self">self </span>. ir_node . into_inner ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B &gt; Singleton &lt; T , L , B &gt; { <span class="kw">pub fn </span>timestamped (<span class="self">self </span>, tick : &amp; Tick &lt; L &gt;) -&gt; Singleton &lt; T , Timestamped &lt; L &gt; , B &gt; { Singleton :: new (Timestamped { tick : tick . clone () } , <span class="self">self </span>. ir_node . into_inner () ,) } # [doc = <span class="string">" Eagerly samples the singleton as fast as possible, returning a stream of snapshots"</span>] # [doc = <span class="string">" with order corresponding to increasing prefixes of data contributing to the singleton."</span>] # [doc = <span class="string">""</span>] # [doc = <span class="string">" # Safety"</span>] # [doc = <span class="string">" At runtime, the singleton will be arbitrarily sampled as fast as possible, but due"</span>] # [doc = <span class="string">" to non-deterministic batching and arrival of inputs, the output stream is"</span>] # [doc = <span class="string">" non-deterministic."</span>] <span class="kw">pub unsafe fn </span>sample_eager (<span class="self">self</span>) -&gt; Stream &lt; T , L , Unbounded &gt; { <span class="kw">let </span>tick = <span class="self">self </span>. location . tick () ; <span class="kw">unsafe </span>{ <span class="self">self </span>. timestamped (&amp; tick) . latest_tick () . all_ticks () . drop_timestamp () } } # [doc = <span class="string">" Given a time interval, returns a stream corresponding to snapshots of the singleton"</span>] # [doc = <span class="string">" value taken at various points in time. Because the input singleton may be"</span>] # [doc = <span class="string">" [`Unbounded`], there are no guarantees on what these snapshots are other than they"</span>] # [doc = <span class="string">" represent the value of the singleton given some prefix of the streams leading up to"</span>] # [doc = <span class="string">" it."</span>] # [doc = <span class="string">""</span>] # [doc = <span class="string">" # Safety"</span>] # [doc = <span class="string">" The output stream is non-deterministic in which elements are sampled, since this"</span>] # [doc = <span class="string">" is controlled by a clock."</span>] <span class="kw">pub unsafe fn </span>sample_every (<span class="self">self </span>, interval : <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, std :: time :: Duration , L &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; T , L , Unbounded &gt; <span class="kw">where </span>L : NoTimestamp , { <span class="kw">let </span>samples = <span class="kw">unsafe </span>{ <span class="self">self </span>. location . source_interval (interval) } ; <span class="kw">let </span>tick = <span class="self">self </span>. location . tick () ; <span class="kw">unsafe </span>{ <span class="self">self </span>. timestamped (&amp; tick) . latest_tick () . continue_if (samples . timestamped (&amp; tick) . tick_batch () . first ()) . all_ticks () . drop_timestamp () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Singleton &lt; T , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">pub fn </span>all_ticks (<span class="self">self</span>) -&gt; Stream &lt; T , Timestamped &lt; L &gt; , Unbounded &gt; { Stream :: new (Timestamped { tick : <span class="self">self </span>. location , } , HydroNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>latest (<span class="self">self</span>) -&gt; Singleton &lt; T , Timestamped &lt; L &gt; , Unbounded &gt; { Singleton :: new (Timestamped { tick : <span class="self">self </span>. location , } , HydroNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>defer_tick (<span class="self">self</span>) -&gt; Singleton &lt; T , Tick &lt; L &gt; , Bounded &gt; { Singleton :: new (<span class="self">self </span>. location , HydroNode :: DeferTick (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>persist (<span class="self">self</span>) -&gt; Stream &lt; T , Tick &lt; L &gt; , Bounded &gt; { Stream :: new (<span class="self">self </span>. location , HydroNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>delta (<span class="self">self</span>) -&gt; Optional &lt; T , Tick &lt; L &gt; , Bounded &gt; { Optional :: new (<span class="self">self </span>. location , HydroNode :: Delta (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>into_stream (<span class="self">self</span>) -&gt; Stream &lt; T , Tick &lt; L &gt; , Bounded &gt; { Stream :: new (<span class="self">self </span>. location , <span class="self">self </span>. ir_node . into_inner ()) } } <span class="kw">pub use crate </span>:: singleton :: ZipResult ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , U : Clone , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; ZipResult &lt; <span class="lifetime">'a </span>, Singleton &lt; U , Timestamped &lt; L &gt; , B &gt; &gt; <span class="kw">for </span>Singleton &lt; T , Timestamped &lt; L &gt; , B &gt; { <span class="kw">type </span>Out = Singleton &lt; (T , U) , Timestamped &lt; L &gt; , B &gt; ; <span class="kw">type </span>Location = Timestamped &lt; L &gt; ; <span class="kw">fn </span>other_location (other : &amp; Singleton &lt; U , Timestamped &lt; L &gt; , B &gt;) -&gt; Timestamped &lt; L &gt; { other . location . clone () } <span class="kw">fn </span>other_ir_node (other : Singleton &lt; U , Timestamped &lt; L &gt; , B &gt;) -&gt; HydroNode { other . ir_node . into_inner () } <span class="kw">fn </span>make (location : Timestamped &lt; L &gt; , ir_node : HydroNode) -&gt; <span class="self">Self </span>:: Out { Singleton :: new (location , ir_node) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , U : Clone , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; ZipResult &lt; <span class="lifetime">'a </span>, Optional &lt; U , Timestamped &lt; L &gt; , B &gt; &gt; <span class="kw">for </span>Singleton &lt; T , Timestamped &lt; L &gt; , B &gt; { <span class="kw">type </span>Out = Optional &lt; (T , U) , Timestamped &lt; L &gt; , B &gt; ; <span class="kw">type </span>Location = Timestamped &lt; L &gt; ; <span class="kw">fn </span>other_location (other : &amp; Optional &lt; U , Timestamped &lt; L &gt; , B &gt;) -&gt; Timestamped &lt; L &gt; { other . location . clone () } <span class="kw">fn </span>other_ir_node (other : Optional &lt; U , Timestamped &lt; L &gt; , B &gt;) -&gt; HydroNode { other . ir_node . into_inner () } <span class="kw">fn </span>make (location : Timestamped &lt; L &gt; , ir_node : HydroNode) -&gt; <span class="self">Self </span>:: Out { Optional :: new (location , ir_node) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , U : Clone , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; ZipResult &lt; <span class="lifetime">'a </span>, Singleton &lt; U , Tick &lt; L &gt; , B &gt; &gt; <span class="kw">for </span>Singleton &lt; T , Tick &lt; L &gt; , B &gt; { <span class="kw">type </span>Out = Singleton &lt; (T , U) , Tick &lt; L &gt; , B &gt; ; <span class="kw">type </span>Location = Tick &lt; L &gt; ; <span class="kw">fn </span>other_location (other : &amp; Singleton &lt; U , Tick &lt; L &gt; , B &gt;) -&gt; Tick &lt; L &gt; { other . location . clone () } <span class="kw">fn </span>other_ir_node (other : Singleton &lt; U , Tick &lt; L &gt; , B &gt;) -&gt; HydroNode { other . ir_node . into_inner () } <span class="kw">fn </span>make (location : Tick &lt; L &gt; , ir_node : HydroNode) -&gt; <span class="self">Self </span>:: Out { Singleton :: new (location , ir_node) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , U : Clone , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; ZipResult &lt; <span class="lifetime">'a </span>, Optional &lt; U , Tick &lt; L &gt; , B &gt; &gt; <span class="kw">for </span>Singleton &lt; T , Tick &lt; L &gt; , B &gt; { <span class="kw">type </span>Out = Optional &lt; (T , U) , Tick &lt; L &gt; , B &gt; ; <span class="kw">type </span>Location = Tick &lt; L &gt; ; <span class="kw">fn </span>other_location (other : &amp; Optional &lt; U , Tick &lt; L &gt; , B &gt;) -&gt; Tick &lt; L &gt; { other . location . clone () } <span class="kw">fn </span>other_ir_node (other : Optional &lt; U , Tick &lt; L &gt; , B &gt;) -&gt; HydroNode { other . ir_node . into_inner () } <span class="kw">fn </span>make (location : Tick &lt; L &gt; , ir_node : HydroNode) -&gt; <span class="self">Self </span>:: Out { Optional :: new (location , ir_node) } } } <span class="kw">pub use </span>singleton :: Singleton ; <span class="kw">pub mod </span>optional { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>stageleft :: { q , IntoQuotedMut , QuotedWithContext } ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: __staged :: builder :: FLOW_USED_MESSAGE ; <span class="kw">pub use crate </span>:: __staged :: cycle :: { CycleCollection , CycleComplete , DeferTick , ForwardRefMarker , TickCycleMarker } ; <span class="kw">pub use crate </span>:: __staged :: ir :: { HydroLeaf , HydroNode , HydroSource , TeeNode } ; <span class="kw">pub use crate </span>:: __staged :: location :: tick :: { NoTimestamp , Timestamped } ; <span class="kw">pub use crate </span>:: __staged :: location :: { check_matching_location , LocationId , NoTick } ; <span class="kw">pub use crate </span>:: __staged :: singleton :: ZipResult ; <span class="kw">pub use crate </span>:: __staged :: stream :: NoOrder ; <span class="kw">pub use crate </span>:: __staged :: { Bounded , Location , Singleton , Stream , Tick , Unbounded } ; <span class="kw">pub use crate </span>:: optional :: Optional ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; Optional &lt; T , L , B &gt; { <span class="kw">pub </span>(<span class="kw">crate</span>) <span class="kw">fn </span>new (location : L , ir_node : HydroNode) -&gt; <span class="self">Self </span>{ Optional { location , ir_node : RefCell :: new (ir_node) , _phantom : PhantomData , } } <span class="kw">pub fn </span>some (singleton : Singleton &lt; T , L , B &gt;) -&gt; <span class="self">Self </span>{ Optional :: new (singleton . location , singleton . ir_node . into_inner ()) } <span class="kw">fn </span>location_kind (&amp; <span class="self">self</span>) -&gt; LocationId { <span class="self">self </span>. location . id () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; DeferTick <span class="kw">for </span>Optional &lt; T , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">fn </span>defer_tick (<span class="self">self</span>) -&gt; <span class="self">Self </span>{ Optional :: defer_tick (<span class="self">self</span>) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleCollection &lt; <span class="lifetime">'a </span>, TickCycleMarker &gt; <span class="kw">for </span>Optional &lt; T , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">type </span>Location = Tick &lt; L &gt; ; <span class="kw">fn </span>create_source (ident : syn :: Ident , location : Tick &lt; L &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>location_id = location . id () ; Optional :: new (location , HydroNode :: CycleSource { ident , location_kind : location_id , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleComplete &lt; <span class="lifetime">'a </span>, TickCycleMarker &gt; <span class="kw">for </span>Optional &lt; T , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident , expected_location : LocationId) { assert_eq ! (<span class="self">self </span>. location . id () , expected_location , <span class="string">"locations do not match"</span>) ; <span class="self">self </span>. location . flow_state () . borrow_mut () . leaves . as_mut () . expect (FLOW_USED_MESSAGE) . push (HydroLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleCollection &lt; <span class="lifetime">'a </span>, ForwardRefMarker &gt; <span class="kw">for </span>Optional &lt; T , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">type </span>Location = Tick &lt; L &gt; ; <span class="kw">fn </span>create_source (ident : syn :: Ident , location : Tick &lt; L &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>location_id = location . id () ; Optional :: new (location , HydroNode :: CycleSource { ident , location_kind : location_id , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; CycleComplete &lt; <span class="lifetime">'a </span>, ForwardRefMarker &gt; <span class="kw">for </span>Optional &lt; T , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident , expected_location : LocationId) { assert_eq ! (<span class="self">self </span>. location . id () , expected_location , <span class="string">"locations do not match"</span>) ; <span class="self">self </span>. location . flow_state () . borrow_mut () . leaves . as_mut () . expect (FLOW_USED_MESSAGE) . push (HydroLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B &gt; CycleCollection &lt; <span class="lifetime">'a </span>, ForwardRefMarker &gt; <span class="kw">for </span>Optional &lt; T , L , B &gt; { <span class="kw">type </span>Location = L ; <span class="kw">fn </span>create_source (ident : syn :: Ident , location : L) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>location_id = location . id () ; Optional :: new (location , HydroNode :: Persist (Box :: new (HydroNode :: CycleSource { ident , location_kind : location_id , })) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B &gt; CycleComplete &lt; <span class="lifetime">'a </span>, ForwardRefMarker &gt; <span class="kw">for </span>Optional &lt; T , L , B &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident , expected_location : LocationId) { assert_eq ! (<span class="self">self </span>. location . id () , expected_location , <span class="string">"locations do not match"</span>) ; <span class="self">self </span>. location . flow_state () . borrow_mut () . leaves . as_mut () . expect (FLOW_USED_MESSAGE) . push (HydroLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind () , input : Box :: new (HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; From &lt; Optional &lt; T , L , Bounded &gt; &gt; <span class="kw">for </span>Optional &lt; T , L , Unbounded &gt; { <span class="kw">fn </span>from (singleton : Optional &lt; T , L , Bounded &gt;) -&gt; <span class="self">Self </span>{ Optional :: new (singleton . location , singleton . ir_node . into_inner ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; From &lt; Singleton &lt; T , L , B &gt; &gt; <span class="kw">for </span>Optional &lt; T , L , B &gt; { <span class="kw">fn </span>from (singleton : Singleton &lt; T , L , B &gt;) -&gt; <span class="self">Self </span>{ Optional :: some (singleton) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; Clone <span class="kw">for </span>Optional &lt; T , L , B &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ <span class="kw">if </span>! matches ! (<span class="self">self </span>. ir_node . borrow () . deref () , HydroNode :: Tee { .. }) { <span class="kw">let </span>orig_ir_node = <span class="self">self </span>. ir_node . replace (HydroNode :: Placeholder) ; * <span class="self">self </span>. ir_node . borrow_mut () = HydroNode :: Tee { inner : TeeNode (Rc :: new (RefCell :: new (orig_ir_node))) , } ; } <span class="kw">if let </span>HydroNode :: Tee { inner } = <span class="self">self </span>. ir_node . borrow () . deref () { Optional { location : <span class="self">self </span>. location . clone () , ir_node : HydroNode :: Tee { inner : TeeNode (inner . <span class="number">0 </span>. clone ()) , } . into () , _phantom : PhantomData , } } <span class="kw">else </span>{ unreachable ! () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; , B &gt; Optional &lt; T , L , B &gt; { <span class="kw">pub fn </span>map &lt; U , F : Fn (T) -&gt; U + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt;) -&gt; Optional &lt; U , L , B &gt; { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; Optional :: new (<span class="self">self </span>. location , HydroNode :: Map { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map_ordered &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Stream &lt; U , L , B &gt; { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: FlatMap { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map_unordered &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Stream &lt; U , L , B , NoOrder &gt; { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; Stream :: new (<span class="self">self </span>. location , HydroNode :: FlatMap { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flatten_ordered &lt; U &gt; (<span class="self">self</span>) -&gt; Stream &lt; U , L , B &gt; <span class="kw">where </span>T : IntoIterator &lt; Item = U &gt; , { <span class="self">self </span>. flat_map_ordered (q ! (| v | v)) } <span class="kw">pub fn </span>flatten_unordered &lt; U &gt; (<span class="self">self</span>) -&gt; Stream &lt; U , L , B , NoOrder &gt; <span class="kw">where </span>T : IntoIterator &lt; Item = U &gt; , { <span class="self">self </span>. flat_map_unordered (q ! (| v | v)) } <span class="kw">pub fn </span>filter &lt; F : Fn (&amp; T) -&gt; bool + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Optional &lt; T , L , B &gt; { <span class="kw">let </span>f = f . splice_fn1_borrow_ctx (&amp; <span class="self">self </span>. location) . into () ; Optional :: new (<span class="self">self </span>. location , HydroNode :: Filter { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter_map &lt; U , F : Fn (T) -&gt; <span class="prelude-ty">Option </span>&lt; U &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , L &gt; ,) -&gt; Optional &lt; U , L , B &gt; { <span class="kw">let </span>f = f . splice_fn1_ctx (&amp; <span class="self">self </span>. location) . into () ; Optional :: new (<span class="self">self </span>. location , HydroNode :: FilterMap { f , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>union (<span class="self">self </span>, other : Optional &lt; T , L , B &gt;) -&gt; Optional &lt; T , L , B &gt; { check_matching_location (&amp; <span class="self">self </span>. location , &amp; other . location) ; <span class="kw">if </span>L :: is_top_level () { Optional :: new (<span class="self">self </span>. location , HydroNode :: Persist (Box :: new (HydroNode :: Chain (Box :: new (HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , Box :: new (HydroNode :: Unpersist (Box :: new (other . ir_node . into_inner ()))) ,))) ,) } <span class="kw">else </span>{ Optional :: new (<span class="self">self </span>. location , HydroNode :: Chain (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } } <span class="kw">pub fn </span>zip &lt; O &gt; (<span class="self">self </span>, other : <span class="kw">impl </span>Into &lt; Optional &lt; O , L , B &gt; &gt;) -&gt; Optional &lt; (T , O) , L , B &gt; <span class="kw">where </span>O : Clone , { <span class="kw">let </span>other : Optional &lt; O , L , B &gt; = other . into () ; check_matching_location (&amp; <span class="self">self </span>. location , &amp; other . location) ; <span class="kw">if </span>L :: is_top_level () { Optional :: new (<span class="self">self </span>. location , HydroNode :: Persist (Box :: new (HydroNode :: CrossSingleton (Box :: new (HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , Box :: new (HydroNode :: Unpersist (Box :: new (other . ir_node . into_inner ()))) ,))) ,) } <span class="kw">else </span>{ Optional :: new (<span class="self">self </span>. location , HydroNode :: CrossSingleton (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } } <span class="kw">pub fn </span>unwrap_or (<span class="self">self </span>, other : Singleton &lt; T , L , B &gt;) -&gt; Singleton &lt; T , L , B &gt; { check_matching_location (&amp; <span class="self">self </span>. location , &amp; other . location) ; <span class="kw">if </span>L :: is_top_level () { Singleton :: new (<span class="self">self </span>. location , HydroNode :: Persist (Box :: new (HydroNode :: Chain (Box :: new (HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , Box :: new (HydroNode :: Unpersist (Box :: new (other . ir_node . into_inner ()))) ,))) ,) } <span class="kw">else </span>{ Singleton :: new (<span class="self">self </span>. location , HydroNode :: Chain (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } } <span class="kw">pub fn </span>into_singleton (<span class="self">self</span>) -&gt; Singleton &lt; <span class="prelude-ty">Option </span>&lt; T &gt; , L , B &gt; <span class="kw">where </span>T : Clone , { <span class="kw">let </span>none : syn :: Expr = parse_quote ! ([:: std :: option :: <span class="prelude-ty">Option </span>:: <span class="prelude-val">None</span>]) ; <span class="kw">let </span>core_ir = HydroNode :: Persist (Box :: new (HydroNode :: Source { source : HydroSource :: Iter (none . into ()) , location_kind : <span class="self">self </span>. location . id () . root () . clone () , })) ; <span class="kw">let </span>none_singleton = <span class="kw">if </span>L :: is_top_level () { Singleton :: new (<span class="self">self </span>. location . clone () , HydroNode :: Persist (Box :: new (core_ir))) } <span class="kw">else </span>{ Singleton :: new (<span class="self">self </span>. location . clone () , core_ir) } ; <span class="self">self </span>. map (q ! (| v | <span class="prelude-val">Some </span>(v))) . unwrap_or (none_singleton) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Optional &lt; T , L , Bounded &gt; { <span class="kw">pub fn </span>continue_if &lt; U &gt; (<span class="self">self </span>, signal : Optional &lt; U , L , Bounded &gt;) -&gt; Optional &lt; T , L , Bounded &gt; { <span class="self">self </span>. zip (signal . map (q ! (| _u | ()))) . map (q ! (| (d , _signal) | d)) } <span class="kw">pub fn </span>continue_unless &lt; U &gt; (<span class="self">self </span>, other : Optional &lt; U , L , Bounded &gt;) -&gt; Optional &lt; T , L , Bounded &gt; { <span class="self">self </span>. continue_if (other . into_stream () . count () . filter (q ! (| c | * c == <span class="number">0</span>))) } <span class="kw">pub fn </span>then &lt; U &gt; (<span class="self">self </span>, value : Singleton &lt; U , L , Bounded &gt;) -&gt; Optional &lt; U , L , Bounded &gt; <span class="kw">where </span>Singleton &lt; U , L , Bounded &gt; : ZipResult &lt; <span class="lifetime">'a </span>, Optional &lt; () , L , Bounded &gt; , Location = L , Out = Optional &lt; (U , ()) , L , Bounded &gt; , &gt; , { value . continue_if (<span class="self">self</span>) } <span class="kw">pub fn </span>into_stream (<span class="self">self</span>) -&gt; Stream &lt; T , L , Bounded &gt; { <span class="kw">if </span>L :: is_top_level () { panic ! (<span class="string">"Converting an optional to a stream is not yet supported at the top level"</span>) ; } Stream :: new (<span class="self">self </span>. location , <span class="self">self </span>. ir_node . into_inner ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B &gt; Optional &lt; T , Timestamped &lt; L &gt; , B &gt; { # [doc = <span class="string">" Given a tick, returns a optional value corresponding to a snapshot of the optional"</span>] # [doc = <span class="string">" as of that tick. The snapshot at tick `t + 1` is guaranteed to include at least all"</span>] # [doc = <span class="string">" relevant data that contributed to the snapshot at tick `t`."</span>] # [doc = <span class="string">""</span>] # [doc = <span class="string">" # Safety"</span>] # [doc = <span class="string">" Because this picks a snapshot of a optional whose value is continuously changing,"</span>] # [doc = <span class="string">" the output optional has a non-deterministic value since the snapshot can be at an"</span>] # [doc = <span class="string">" arbitrary point in time."</span>] <span class="kw">pub unsafe fn </span>latest_tick (<span class="self">self</span>) -&gt; Optional &lt; T , Tick &lt; L &gt; , Bounded &gt; { Optional :: new (<span class="self">self </span>. location . tick , HydroNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>drop_timestamp (<span class="self">self</span>) -&gt; Optional &lt; T , L , B &gt; { Optional :: new (<span class="self">self </span>. location . tick . l , <span class="self">self </span>. ir_node . into_inner ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , B &gt; Optional &lt; T , L , B &gt; { <span class="kw">pub fn </span>timestamped (<span class="self">self </span>, tick : &amp; Tick &lt; L &gt;) -&gt; Optional &lt; T , Timestamped &lt; L &gt; , B &gt; { Optional :: new (Timestamped { tick : tick . clone () } , <span class="self">self </span>. ir_node . into_inner () ,) } # [doc = <span class="string">" Eagerly samples the optional as fast as possible, returning a stream of snapshots"</span>] # [doc = <span class="string">" with order corresponding to increasing prefixes of data contributing to the optional."</span>] # [doc = <span class="string">""</span>] # [doc = <span class="string">" # Safety"</span>] # [doc = <span class="string">" At runtime, the optional will be arbitrarily sampled as fast as possible, but due"</span>] # [doc = <span class="string">" to non-deterministic batching and arrival of inputs, the output stream is"</span>] # [doc = <span class="string">" non-deterministic."</span>] <span class="kw">pub unsafe fn </span>sample_eager (<span class="self">self</span>) -&gt; Stream &lt; T , L , Unbounded &gt; { <span class="kw">let </span>tick = <span class="self">self </span>. location . tick () ; <span class="kw">unsafe </span>{ <span class="self">self </span>. timestamped (&amp; tick) . latest_tick () . all_ticks () . drop_timestamp () } } # [doc = <span class="string">" Given a time interval, returns a stream corresponding to snapshots of the optional"</span>] # [doc = <span class="string">" value taken at various points in time. Because the input optional may be"</span>] # [doc = <span class="string">" [`Unbounded`], there are no guarantees on what these snapshots are other than they"</span>] # [doc = <span class="string">" represent the value of the optional given some prefix of the streams leading up to"</span>] # [doc = <span class="string">" it."</span>] # [doc = <span class="string">""</span>] # [doc = <span class="string">" # Safety"</span>] # [doc = <span class="string">" The output stream is non-deterministic in which elements are sampled, since this"</span>] # [doc = <span class="string">" is controlled by a clock."</span>] <span class="kw">pub unsafe fn </span>sample_every (<span class="self">self </span>, interval : <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, std :: time :: Duration , L &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; T , L , Unbounded &gt; <span class="kw">where </span>L : NoTimestamp , { <span class="kw">let </span>samples = <span class="kw">unsafe </span>{ <span class="self">self </span>. location . source_interval (interval) } ; <span class="kw">let </span>tick = <span class="self">self </span>. location . tick () ; <span class="kw">unsafe </span>{ <span class="self">self </span>. timestamped (&amp; tick) . latest_tick () . continue_if (samples . timestamped (&amp; tick) . tick_batch () . first ()) . all_ticks () . drop_timestamp () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Optional &lt; T , Tick &lt; L &gt; , Bounded &gt; { <span class="kw">pub fn </span>all_ticks (<span class="self">self</span>) -&gt; Stream &lt; T , Timestamped &lt; L &gt; , Unbounded &gt; { Stream :: new (Timestamped { tick : <span class="self">self </span>. location , } , HydroNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>latest (<span class="self">self</span>) -&gt; Optional &lt; T , Timestamped &lt; L &gt; , Unbounded &gt; { Optional :: new (Timestamped { tick : <span class="self">self </span>. location , } , HydroNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>defer_tick (<span class="self">self</span>) -&gt; Optional &lt; T , Tick &lt; L &gt; , Bounded &gt; { Optional :: new (<span class="self">self </span>. location , HydroNode :: DeferTick (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>persist (<span class="self">self</span>) -&gt; Stream &lt; T , Tick &lt; L &gt; , Bounded &gt; { Stream :: new (<span class="self">self </span>. location , HydroNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>delta (<span class="self">self</span>) -&gt; Optional &lt; T , Tick &lt; L &gt; , Bounded &gt; { Optional :: new (<span class="self">self </span>. location , HydroNode :: Delta (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } } } <span class="kw">pub use </span>optional :: Optional ; <span class="kw">pub mod </span>location { <span class="kw">pub use </span>std :: fmt :: Debug ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: time :: Duration ; <span class="kw">pub use </span>dfir_rs :: futures :: stream :: Stream <span class="kw">as </span>FuturesStream ; <span class="kw">pub use </span>dfir_rs :: { tokio , tokio_stream } ; <span class="kw">pub use </span>proc_macro2 :: Span ; <span class="kw">pub use </span>stageleft :: { q , QuotedWithContext } ; <span class="kw">pub use super </span>:: builder :: FlowState ; <span class="kw">pub use crate </span>:: __staged :: cycle :: { CycleCollection , ForwardRef , ForwardRefMarker } ; <span class="kw">pub use crate </span>:: __staged :: ir :: { HydroNode , HydroSource } ; <span class="kw">pub use crate </span>:: __staged :: { Singleton , Stream , Unbounded } ; <span class="kw">pub mod </span>external_process { <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>dfir_rs :: bytes :: Bytes ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use super </span>:: { Location , LocationId , NoTick } ; <span class="kw">pub use crate </span>:: __staged :: builder :: FlowState ; <span class="kw">pub use crate </span>:: __staged :: ir :: { HydroNode , HydroSource } ; <span class="kw">pub use crate </span>:: __staged :: staging_util :: Invariant ; <span class="kw">pub use crate </span>:: __staged :: { Stream , Unbounded } ; <span class="kw">pub use crate </span>:: location :: external_process :: ExternalBytesPort ; <span class="kw">pub use crate </span>:: location :: external_process :: ExternalBincodeSink ; <span class="kw">pub use crate </span>:: location :: external_process :: ExternalBincodeStream ; <span class="kw">pub use crate </span>:: location :: external_process :: ExternalProcess ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; P &gt; Clone <span class="kw">for </span>ExternalProcess &lt; <span class="lifetime">'_ </span>, P &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ ExternalProcess { id : <span class="self">self </span>. id , flow_state : <span class="self">self </span>. flow_state . clone () , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P &gt; Location &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>ExternalProcess &lt; <span class="lifetime">'a </span>, P &gt; { <span class="kw">type </span>Root = <span class="self">Self </span>; <span class="kw">fn </span>root (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>:: Root { <span class="self">self </span>. clone () } <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; LocationId { LocationId :: ExternalProcess (<span class="self">self </span>. id) } <span class="kw">fn </span>flow_state (&amp; <span class="self">self</span>) -&gt; &amp; FlowState { &amp; <span class="self">self </span>. flow_state } <span class="kw">fn </span>is_top_level () -&gt; bool { <span class="bool-val">true </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P &gt; ExternalProcess &lt; <span class="lifetime">'a </span>, P &gt; { <span class="kw">pub fn </span>source_external_bytes &lt; L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick &gt; (&amp; <span class="self">self </span>, to : &amp; L ,) -&gt; (ExternalBytesPort , Stream &lt; Bytes , L , Unbounded &gt;) { <span class="kw">let </span>next_external_port_id = { <span class="kw">let </span><span class="kw-2">mut </span>flow_state = <span class="self">self </span>. flow_state . borrow_mut () ; <span class="kw">let </span>id = flow_state . next_external_out ; flow_state . next_external_out += <span class="number">1 </span>; id } ; <span class="kw">let </span>deser_expr : syn :: Expr = syn :: parse_quote ! (| b | b . unwrap () . freeze ()) ; (ExternalBytesPort { process_id : <span class="self">self </span>. id , port_id : next_external_port_id , } , Stream :: new (to . clone () , HydroNode :: Persist (Box :: new (HydroNode :: Network { from_location : LocationId :: ExternalProcess (<span class="self">self </span>. id) , from_key : <span class="prelude-val">Some </span>(next_external_port_id) , to_location : to . id () , to_key : <span class="prelude-val">None </span>, serialize_fn : <span class="prelude-val">None </span>, instantiate_fn : <span class="kw">crate </span>:: ir :: DebugInstantiate :: Building () , deserialize_fn : <span class="prelude-val">Some </span>(deser_expr . into ()) , input : Box :: new (HydroNode :: Source { source : HydroSource :: ExternalNetwork () , location_kind : LocationId :: ExternalProcess (<span class="self">self </span>. id) , }) , })) ,) ,) } <span class="kw">pub fn </span>source_external_bincode &lt; L : Location &lt; <span class="lifetime">'a </span>&gt; + NoTick , T : Serialize + DeserializeOwned &gt; (&amp; <span class="self">self </span>, to : &amp; L ,) -&gt; (ExternalBincodeSink &lt; T &gt; , Stream &lt; T , L , Unbounded &gt;) { <span class="kw">let </span>next_external_port_id = { <span class="kw">let </span><span class="kw-2">mut </span>flow_state = <span class="self">self </span>. flow_state . borrow_mut () ; <span class="kw">let </span>id = flow_state . next_external_out ; flow_state . next_external_out += <span class="number">1 </span>; id } ; (ExternalBincodeSink { process_id : <span class="self">self </span>. id , port_id : next_external_port_id , _phantom : PhantomData , } , Stream :: new (to . clone () , HydroNode :: Persist (Box :: new (HydroNode :: Network { from_location : LocationId :: ExternalProcess (<span class="self">self </span>. id) , from_key : <span class="prelude-val">Some </span>(next_external_port_id) , to_location : to . id () , to_key : <span class="prelude-val">None </span>, serialize_fn : <span class="prelude-val">None </span>, instantiate_fn : <span class="kw">crate </span>:: ir :: DebugInstantiate :: Building () , deserialize_fn : <span class="prelude-val">Some </span>(<span class="kw">crate </span>:: stream :: deserialize_bincode :: &lt; T &gt; (<span class="prelude-val">None</span>) . into ()) , input : Box :: new (HydroNode :: Source { source : HydroSource :: ExternalNetwork () , location_kind : LocationId :: ExternalProcess (<span class="self">self </span>. id) , }) , })) ,) ,) } } } <span class="kw">pub use </span>external_process :: ExternalProcess ; <span class="kw">pub mod </span>process { <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use super </span>:: { Location , LocationId } ; <span class="kw">pub use crate </span>:: __staged :: builder :: FlowState ; <span class="kw">pub use crate </span>:: __staged :: staging_util :: Invariant ; <span class="kw">pub use crate </span>:: location :: process :: Process ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; P &gt; Clone <span class="kw">for </span>Process &lt; <span class="lifetime">'_ </span>, P &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ Process { id : <span class="self">self </span>. id , flow_state : <span class="self">self </span>. flow_state . clone () , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P &gt; Location &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Process &lt; <span class="lifetime">'a </span>, P &gt; { <span class="kw">type </span>Root = <span class="self">Self </span>; <span class="kw">fn </span>root (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>:: Root { <span class="self">self </span>. clone () } <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; LocationId { LocationId :: Process (<span class="self">self </span>. id) } <span class="kw">fn </span>flow_state (&amp; <span class="self">self</span>) -&gt; &amp; FlowState { &amp; <span class="self">self </span>. flow_state } <span class="kw">fn </span>is_top_level () -&gt; bool { <span class="bool-val">true </span>} } } <span class="kw">pub use </span>process :: Process ; <span class="kw">pub mod </span>cluster { <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>stageleft :: runtime_support :: FreeVariableWithContext ; <span class="kw">pub use </span>stageleft :: { quote_type , QuotedWithContext } ; <span class="kw">pub use super </span>:: { Location , LocationId } ; <span class="kw">pub use crate </span>:: __staged :: builder :: FlowState ; <span class="kw">pub use crate </span>:: __staged :: staging_util :: { get_this_crate , Invariant } ; <span class="kw">pub mod </span>cluster_id { <span class="kw">pub use </span>std :: fmt :: { Debug , Display } ; <span class="kw">pub use </span>std :: hash :: Hash ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>serde :: { Deserialize , Serialize } ; <span class="kw">pub use crate </span>:: location :: cluster :: cluster_id :: ClusterId ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Debug <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"ClusterId::&lt;{}&gt;({})" </span>, std :: any :: type_name ::&lt; C &gt; () , <span class="self">self </span>. raw_id) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Display <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"ClusterId::&lt;{}&gt;({})" </span>, std :: any :: type_name ::&lt; C &gt; () , <span class="self">self </span>. raw_id) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Clone <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ * <span class="self">self </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Copy <span class="kw">for </span>ClusterId &lt; C &gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Serialize <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>serialize &lt; S &gt; (&amp; <span class="self">self </span>, serializer : S) -&gt; <span class="prelude-ty">Result </span>&lt; S :: <span class="prelude-val">Ok </span>, S :: Error &gt; <span class="kw">where </span>S : serde :: ser :: Serializer , { <span class="self">self </span>. raw_id . serialize (serializer) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'de </span>, C &gt; Deserialize &lt; <span class="lifetime">'de </span>&gt; <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>deserialize &lt; D &gt; (deserializer : D) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, D :: Error &gt; <span class="kw">where </span>D : serde :: de :: Deserializer &lt; <span class="lifetime">'de </span>&gt; , { u32 :: deserialize (deserializer) . map (| id | ClusterId { raw_id : id , _phantom : PhantomData , }) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; PartialEq <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>eq (&amp; <span class="self">self </span>, other : &amp; <span class="self">Self</span>) -&gt; bool { <span class="self">self </span>. raw_id == other . raw_id } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Eq <span class="kw">for </span>ClusterId &lt; C &gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Hash <span class="kw">for </span>ClusterId &lt; C &gt; { <span class="kw">fn </span>hash &lt; H : std :: hash :: Hasher &gt; (&amp; <span class="self">self </span>, state : &amp; <span class="kw-2">mut </span>H) { <span class="self">self </span>. raw_id . hash (state) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; ClusterId &lt; C &gt; { <span class="kw">pub fn </span>from_raw (id : u32) -&gt; <span class="self">Self </span>{ ClusterId { raw_id : id , _phantom : PhantomData , } } } } <span class="kw">pub use </span>cluster_id :: ClusterId ; <span class="kw">pub use crate </span>:: location :: cluster :: Cluster ; <span class="kw">pub use crate </span>:: location :: cluster :: IsCluster ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; IsCluster <span class="kw">for </span>Cluster &lt; <span class="lifetime">'_ </span>, C &gt; { <span class="kw">type </span>Tag = C ; } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; Cluster &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">pub fn </span>members (&amp; <span class="self">self</span>) -&gt; ClusterIds &lt; <span class="lifetime">'a </span>, C &gt; { ClusterIds { id : <span class="self">self </span>. id , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Clone <span class="kw">for </span>Cluster &lt; <span class="lifetime">'_ </span>, C &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ Cluster { id : <span class="self">self </span>. id , flow_state : <span class="self">self </span>. flow_state . clone () , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C &gt; Location &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Cluster &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">type </span>Root = Cluster &lt; <span class="lifetime">'a </span>, C &gt; ; <span class="kw">fn </span>root (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>:: Root { <span class="self">self </span>. clone () } <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; LocationId { LocationId :: Cluster (<span class="self">self </span>. id) } <span class="kw">fn </span>flow_state (&amp; <span class="self">self</span>) -&gt; &amp; FlowState { &amp; <span class="self">self </span>. flow_state } <span class="kw">fn </span>is_top_level () -&gt; bool { <span class="bool-val">true </span>} } <span class="kw">pub use crate </span>:: location :: cluster :: ClusterIds ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Clone <span class="kw">for </span>ClusterIds &lt; <span class="lifetime">'_ </span>, C &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ * <span class="self">self </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Copy <span class="kw">for </span>ClusterIds &lt; <span class="lifetime">'_ </span>, C &gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C : <span class="lifetime">'a </span>, Ctx &gt; FreeVariableWithContext &lt; Ctx &gt; <span class="kw">for </span>ClusterIds &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">type </span>O = &amp; <span class="lifetime">'a </span>Vec &lt; ClusterId &lt; C &gt; &gt; ; <span class="kw">fn </span>to_tokens (<span class="self">self </span>, _ctx : &amp; Ctx) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) <span class="kw">where </span><span class="self">Self </span>: Sized , { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"__hydro_lang_cluster_ids_{}" </span>, <span class="self">self </span>. id) , Span :: call_site () ,) ; <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span>c_type = quote_type :: &lt; C &gt; () ; (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(quote ! { <span class="kw">unsafe </span>{ :: std :: mem :: transmute ::&lt; <span class="kw">_ </span>, <span class="kw-2">&amp;</span>:: std :: vec :: Vec &lt;# root :: ClusterId &lt;# c_type &gt;&gt;&gt; (# ident) } } ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C , Ctx &gt; QuotedWithContext &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; ClusterId &lt; C &gt; &gt; , Ctx &gt; <span class="kw">for </span>ClusterIds &lt; <span class="lifetime">'a </span>, C &gt; { } <span class="kw">pub use crate </span>:: location :: cluster :: CLUSTER_SELF_ID ; <span class="kw">pub use crate </span>:: location :: cluster :: ClusterSelfId ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; FreeVariableWithContext &lt; L &gt; <span class="kw">for </span>ClusterSelfId &lt; <span class="lifetime">'a </span>&gt; <span class="kw">where </span>&lt; L <span class="kw">as </span>Location &lt; <span class="lifetime">'a </span>&gt; &gt; :: Root : IsCluster , { <span class="kw">type </span>O = ClusterId &lt; &lt; &lt; L <span class="kw">as </span>Location &lt; <span class="lifetime">'a </span>&gt; &gt; :: Root <span class="kw">as </span>IsCluster &gt; :: Tag &gt; ; <span class="kw">fn </span>to_tokens (<span class="self">self </span>, ctx : &amp; L) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) <span class="kw">where </span><span class="self">Self </span>: Sized , { <span class="kw">let </span>cluster_id = <span class="kw">if let </span>LocationId :: Cluster (id) = ctx . root () . id () { id } <span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"__hydro_lang_cluster_self_id_{}" </span>, cluster_id) , Span :: call_site () ,) ; <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span>c_type : syn :: Type = quote_type :: &lt; &lt; &lt; L <span class="kw">as </span>Location &lt; <span class="lifetime">'a </span>&gt; &gt; :: Root <span class="kw">as </span>IsCluster &gt; :: Tag &gt; () ; (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(quote ! { # root :: ClusterId ::&lt;# c_type &gt;:: from_raw (# ident) }) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; QuotedWithContext &lt; <span class="lifetime">'a </span>, ClusterId &lt; &lt; &lt; L <span class="kw">as </span>Location &lt; <span class="lifetime">'a </span>&gt; &gt; :: Root <span class="kw">as </span>IsCluster &gt; :: Tag &gt; , L &gt; <span class="kw">for </span>ClusterSelfId &lt; <span class="lifetime">'a </span>&gt; <span class="kw">where </span>&lt; L <span class="kw">as </span>Location &lt; <span class="lifetime">'a </span>&gt; &gt; :: Root : IsCluster , { } } <span class="kw">pub use </span>cluster :: { Cluster , ClusterId } ; <span class="kw">pub mod </span>can_send { <span class="kw">pub use </span>stageleft :: quote_type ; <span class="kw">pub use super </span>:: { Cluster , ClusterId , ExternalProcess , Location , Process } ; <span class="kw">pub use crate </span>:: __staged :: stream :: NoOrder ; <span class="kw">pub use crate </span>:: location :: can_send :: CanSend ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P1 , P2 &gt; CanSend &lt; <span class="lifetime">'a </span>, Process &lt; <span class="lifetime">'a </span>, P2 &gt; &gt; <span class="kw">for </span>Process &lt; <span class="lifetime">'a </span>, P1 &gt; { <span class="kw">type </span>In &lt; T &gt; = T ; <span class="kw">type </span>Out &lt; T &gt; = T ; <span class="kw">type </span>OutStrongestOrder &lt; InOrder &gt; = InOrder ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">false </span>} <span class="kw">fn </span>tagged_type () -&gt; <span class="prelude-ty">Option </span>&lt; syn :: Type &gt; { <span class="prelude-val">None </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P1 , C2 &gt; CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; <span class="kw">for </span>Process &lt; <span class="lifetime">'a </span>, P1 &gt; { <span class="kw">type </span>In &lt; T &gt; = (ClusterId &lt; C2 &gt; , T) ; <span class="kw">type </span>Out &lt; T &gt; = T ; <span class="kw">type </span>OutStrongestOrder &lt; InOrder &gt; = InOrder ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>tagged_type () -&gt; <span class="prelude-ty">Option </span>&lt; syn :: Type &gt; { <span class="prelude-val">None </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C1 , P2 &gt; CanSend &lt; <span class="lifetime">'a </span>, Process &lt; <span class="lifetime">'a </span>, P2 &gt; &gt; <span class="kw">for </span>Cluster &lt; <span class="lifetime">'a </span>, C1 &gt; { <span class="kw">type </span>In &lt; T &gt; = T ; <span class="kw">type </span>Out &lt; T &gt; = (ClusterId &lt; C1 &gt; , T) ; <span class="kw">type </span>OutStrongestOrder &lt; InOrder &gt; = NoOrder ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">false </span>} <span class="kw">fn </span>tagged_type () -&gt; <span class="prelude-ty">Option </span>&lt; syn :: Type &gt; { <span class="prelude-val">Some </span>(quote_type :: &lt; C1 &gt; ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, C1 , C2 &gt; CanSend &lt; <span class="lifetime">'a </span>, Cluster &lt; <span class="lifetime">'a </span>, C2 &gt; &gt; <span class="kw">for </span>Cluster &lt; <span class="lifetime">'a </span>, C1 &gt; { <span class="kw">type </span>In &lt; T &gt; = (ClusterId &lt; C2 &gt; , T) ; <span class="kw">type </span>Out &lt; T &gt; = (ClusterId &lt; C1 &gt; , T) ; <span class="kw">type </span>OutStrongestOrder &lt; InOrder &gt; = NoOrder ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>tagged_type () -&gt; <span class="prelude-ty">Option </span>&lt; syn :: Type &gt; { <span class="prelude-val">Some </span>(quote_type :: &lt; C1 &gt; ()) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, P1 , E2 &gt; CanSend &lt; <span class="lifetime">'a </span>, ExternalProcess &lt; <span class="lifetime">'a </span>, E2 &gt; &gt; <span class="kw">for </span>Process &lt; <span class="lifetime">'a </span>, P1 &gt; { <span class="kw">type </span>In &lt; T &gt; = T ; <span class="kw">type </span>Out &lt; T &gt; = T ; <span class="kw">type </span>OutStrongestOrder &lt; InOrder &gt; = InOrder ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">false </span>} <span class="kw">fn </span>tagged_type () -&gt; <span class="prelude-ty">Option </span>&lt; syn :: Type &gt; { <span class="prelude-val">None </span>} } } <span class="kw">pub use </span>can_send :: CanSend ; <span class="kw">pub mod </span>tick { <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>proc_macro2 :: Span ; <span class="kw">pub use </span>sealed :: sealed ; <span class="kw">pub use </span>stageleft :: { q , QuotedWithContext } ; <span class="kw">pub use super </span>:: { Cluster , Location , LocationId , Process } ; <span class="kw">pub use crate </span>:: __staged :: builder :: FlowState ; <span class="kw">pub use crate </span>:: __staged :: cycle :: { CycleCollection , CycleCollectionWithInitial , DeferTick , ForwardRef , ForwardRefMarker , TickCycle , TickCycleMarker , } ; <span class="kw">pub use crate </span>:: __staged :: ir :: { HydroNode , HydroSource } ; <span class="kw">pub use crate </span>:: __staged :: { Bounded , Optional , Singleton , Stream } ; <span class="kw">pub use crate </span>:: location :: tick :: NoTick ; # [cfg (stageleft_macro)] # [sealed] <span class="kw">impl </span>&lt; T &gt; NoTick <span class="kw">for </span>Process &lt; <span class="lifetime">'_ </span>, T &gt; { } # [cfg (stageleft_macro)] # [sealed] <span class="kw">impl </span>&lt; T &gt; NoTick <span class="kw">for </span>Cluster &lt; <span class="lifetime">'_ </span>, T &gt; { } <span class="kw">pub use crate </span>:: location :: tick :: NoTimestamp ; # [cfg (stageleft_macro)] # [sealed] <span class="kw">impl </span>&lt; T &gt; NoTimestamp <span class="kw">for </span>Process &lt; <span class="lifetime">'_ </span>, T &gt; { } # [cfg (stageleft_macro)] # [sealed] <span class="kw">impl </span>&lt; T &gt; NoTimestamp <span class="kw">for </span>Cluster &lt; <span class="lifetime">'_ </span>, T &gt; { } # [cfg (stageleft_macro)] # [sealed] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; NoTimestamp <span class="kw">for </span>Tick &lt; L &gt; { } <span class="kw">pub use crate </span>:: location :: tick :: Timestamped ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Location &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Timestamped &lt; L &gt; { <span class="kw">type </span>Root = L :: Root ; <span class="kw">fn </span>root (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>:: Root { <span class="self">self </span>. tick . root () } <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; LocationId { <span class="self">self </span>. tick . id () } <span class="kw">fn </span>flow_state (&amp; <span class="self">self</span>) -&gt; &amp; FlowState { <span class="self">self </span>. tick . flow_state () } <span class="kw">fn </span>is_top_level () -&gt; bool { L :: is_top_level () } } # [cfg (stageleft_macro)] # [sealed] <span class="kw">impl </span>&lt; L &gt; NoTick <span class="kw">for </span>Timestamped &lt; L &gt; { } <span class="kw">pub use crate </span>:: location :: tick :: Tick ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Location &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Tick &lt; L &gt; { <span class="kw">type </span>Root = L :: Root ; <span class="kw">fn </span>root (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>:: Root { <span class="self">self </span>. l . root () } <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; LocationId { LocationId :: Tick (<span class="self">self </span>. id , Box :: new (<span class="self">self </span>. l . id ())) } <span class="kw">fn </span>flow_state (&amp; <span class="self">self</span>) -&gt; &amp; FlowState { <span class="self">self </span>. l . flow_state () } <span class="kw">fn </span>is_top_level () -&gt; bool { <span class="bool-val">false </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; Tick &lt; L &gt; { <span class="kw">pub fn </span>outer (&amp; <span class="self">self</span>) -&gt; &amp; L { &amp; <span class="self">self </span>. l } <span class="kw">pub fn </span>spin_batch (&amp; <span class="self">self </span>, batch_size : <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, usize , L &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; () , <span class="self">Self </span>, Bounded &gt; <span class="kw">where </span>L : NoTick + NoTimestamp , { <span class="kw">let </span>out = <span class="self">self </span>. l . spin () . flat_map_ordered (q ! (<span class="kw">move </span>| <span class="kw">_ </span>| <span class="number">0 </span>.. batch_size)) . map (q ! (| <span class="kw">_ </span>| ())) . timestamped (<span class="self">self</span>) ; <span class="kw">unsafe </span>{ out . tick_batch () } } <span class="kw">pub fn </span>singleton &lt; T : Clone &gt; (&amp; <span class="self">self </span>, e : <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, T , L &gt; ,) -&gt; Singleton &lt; T , <span class="self">Self </span>, Bounded &gt; <span class="kw">where </span>L : NoTick , { <span class="kw">unsafe </span>{ <span class="self">self </span>. outer () . singleton (e) . timestamped (<span class="self">self</span>) . latest_tick () } } <span class="kw">pub fn </span>singleton_first_tick &lt; T : Clone &gt; (&amp; <span class="self">self </span>, e : <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, T , Tick &lt; L &gt; &gt; ,) -&gt; Optional &lt; T , <span class="self">Self </span>, Bounded &gt; <span class="kw">where </span>L : NoTick , { <span class="kw">let </span>e_arr = q ! ([e]) ; <span class="kw">let </span>e = e_arr . splice_untyped_ctx (<span class="self">self</span>) ; Optional :: new (<span class="self">self </span>. clone () , HydroNode :: Source { source : HydroSource :: Iter (e . into ()) , location_kind : <span class="self">self </span>. l . id () , } ,) } <span class="kw">pub fn </span>forward_ref &lt; S : CycleCollection &lt; <span class="lifetime">'a </span>, ForwardRefMarker , Location = <span class="self">Self </span>&gt; &gt; (&amp; <span class="self">self </span>,) -&gt; (ForwardRef &lt; <span class="lifetime">'a </span>, S &gt; , S) <span class="kw">where </span>L : NoTick , { <span class="kw">let </span>next_id = { <span class="kw">let </span>on_id = <span class="kw">match </span><span class="self">self </span>. l . id () { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , LocationId :: Tick (<span class="kw">_ </span>, <span class="kw">_</span>) =&gt; panic ! () , LocationId :: ExternalProcess (<span class="kw">_</span>) =&gt; panic ! () , } ; <span class="kw">let </span><span class="kw-2">mut </span>flow_state = <span class="self">self </span>. flow_state () . borrow_mut () ; <span class="kw">let </span>next_id_entry = flow_state . cycle_counts . entry (on_id) . or_default () ; <span class="kw">let </span>id = * next_id_entry ; * next_id_entry += <span class="number">1 </span>; id } ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"cycle_{}" </span>, next_id) , Span :: call_site ()) ; (ForwardRef { ident : ident . clone () , expected_location : <span class="self">self </span>. id () , _phantom : PhantomData , } , S :: create_source (ident , <span class="self">self </span>. clone ()) ,) } <span class="kw">pub fn </span>forward_ref_timestamped &lt; S : CycleCollection &lt; <span class="lifetime">'a </span>, ForwardRefMarker , Location = Timestamped &lt; L &gt; &gt; , &gt; (&amp; <span class="self">self </span>,) -&gt; (ForwardRef &lt; <span class="lifetime">'a </span>, S &gt; , S) { <span class="kw">let </span>next_id = { <span class="kw">let </span>on_id = <span class="kw">match </span><span class="self">self </span>. l . id () { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , LocationId :: Tick (<span class="kw">_ </span>, <span class="kw">_</span>) =&gt; panic ! () , LocationId :: ExternalProcess (<span class="kw">_</span>) =&gt; panic ! () , } ; <span class="kw">let </span><span class="kw-2">mut </span>flow_state = <span class="self">self </span>. flow_state () . borrow_mut () ; <span class="kw">let </span>next_id_entry = flow_state . cycle_counts . entry (on_id) . or_default () ; <span class="kw">let </span>id = * next_id_entry ; * next_id_entry += <span class="number">1 </span>; id } ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"cycle_{}" </span>, next_id) , Span :: call_site ()) ; (ForwardRef { ident : ident . clone () , expected_location : <span class="self">self </span>. id () , _phantom : PhantomData , } , S :: create_source (ident , Timestamped { tick : <span class="self">self </span>. clone () }) ,) } <span class="kw">pub fn </span>cycle &lt; S : CycleCollection &lt; <span class="lifetime">'a </span>, TickCycleMarker , Location = <span class="self">Self </span>&gt; + DeferTick &gt; (&amp; <span class="self">self </span>,) -&gt; (TickCycle &lt; <span class="lifetime">'a </span>, S &gt; , S) <span class="kw">where </span>L : NoTick , { <span class="kw">let </span>next_id = { <span class="kw">let </span>on_id = <span class="kw">match </span><span class="self">self </span>. l . id () { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , LocationId :: Tick (<span class="kw">_ </span>, <span class="kw">_</span>) =&gt; panic ! () , LocationId :: ExternalProcess (<span class="kw">_</span>) =&gt; panic ! () , } ; <span class="kw">let </span><span class="kw-2">mut </span>flow_state = <span class="self">self </span>. flow_state () . borrow_mut () ; <span class="kw">let </span>next_id_entry = flow_state . cycle_counts . entry (on_id) . or_default () ; <span class="kw">let </span>id = * next_id_entry ; * next_id_entry += <span class="number">1 </span>; id } ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"cycle_{}" </span>, next_id) , Span :: call_site ()) ; (TickCycle { ident : ident . clone () , expected_location : <span class="self">self </span>. id () , _phantom : PhantomData , } , S :: create_source (ident , <span class="self">self </span>. clone ()) ,) } <span class="kw">pub fn </span>cycle_with_initial &lt; S : CycleCollectionWithInitial &lt; <span class="lifetime">'a </span>, TickCycleMarker , Location = <span class="self">Self </span>&gt; + DeferTick , &gt; (&amp; <span class="self">self </span>, initial : S ,) -&gt; (TickCycle &lt; <span class="lifetime">'a </span>, S &gt; , S) <span class="kw">where </span>L : NoTick , { <span class="kw">let </span>next_id = { <span class="kw">let </span>on_id = <span class="kw">match </span><span class="self">self </span>. l . id () { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , LocationId :: Tick (<span class="kw">_ </span>, <span class="kw">_</span>) =&gt; panic ! () , LocationId :: ExternalProcess (<span class="kw">_</span>) =&gt; panic ! () , } ; <span class="kw">let </span><span class="kw-2">mut </span>flow_state = <span class="self">self </span>. flow_state () . borrow_mut () ; <span class="kw">let </span>next_id_entry = flow_state . cycle_counts . entry (on_id) . or_default () ; <span class="kw">let </span>id = * next_id_entry ; * next_id_entry += <span class="number">1 </span>; id } ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"cycle_{}" </span>, next_id) , Span :: call_site ()) ; (TickCycle { ident : ident . clone () , expected_location : <span class="self">self </span>. id () , _phantom : PhantomData , } , S :: create_source (ident , initial , <span class="self">self </span>. clone ()) ,) } } } <span class="kw">pub use </span>tick :: { NoTick , Tick , Timestamped } ; <span class="kw">pub use crate </span>:: location :: LocationId ; # [cfg (stageleft_macro)] <span class="kw">impl </span>LocationId { <span class="kw">pub fn </span>root (&amp; <span class="self">self</span>) -&gt; &amp; LocationId { <span class="kw">match </span><span class="self">self </span>{ LocationId :: Process (<span class="kw">_</span>) =&gt; <span class="self">self </span>, LocationId :: Cluster (<span class="kw">_</span>) =&gt; <span class="self">self </span>, LocationId :: Tick (<span class="kw">_ </span>, id) =&gt; id . root () , LocationId :: ExternalProcess (<span class="kw">_</span>) =&gt; <span class="self">self </span>, } } <span class="kw">pub fn </span>raw_id (&amp; <span class="self">self</span>) -&gt; usize { <span class="kw">match </span><span class="self">self </span>{ LocationId :: Process (id) =&gt; * id , LocationId :: Cluster (id) =&gt; * id , LocationId :: Tick (<span class="kw">_ </span>, <span class="kw">_</span>) =&gt; panic ! (<span class="string">"cannot get raw id for tick"</span>) , LocationId :: ExternalProcess (id) =&gt; * id , } } } <span class="kw">pub fn </span>check_matching_location &lt; <span class="lifetime">'a </span>, L : Location &lt; <span class="lifetime">'a </span>&gt; &gt; (l1 : &amp; L , l2 : &amp; L) { assert_eq ! (l1 . id () , l2 . id () , <span class="string">"locations do not match"</span>) ; } <span class="kw">pub use crate </span>:: location :: Location ; } <span class="kw">pub use </span>location :: cluster :: CLUSTER_SELF_ID ; <span class="kw">pub use </span>location :: { Cluster , ClusterId , ExternalProcess , Location , Process , Tick , Timestamped } ; # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub mod </span>deploy { <span class="kw">pub use </span>std :: future :: Future ; <span class="kw">pub use </span>std :: io :: Error ; <span class="kw">pub use </span>std :: pin :: Pin ; <span class="kw">pub use </span>dfir_lang :: graph :: DfirGraph ; <span class="kw">pub use </span>dfir_rs :: bytes :: Bytes ; <span class="kw">pub use </span>dfir_rs :: futures :: { Sink , Stream } ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use </span>stageleft :: QuotedWithContext ; <span class="kw">pub mod </span>macro_runtime { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: future :: Future ; <span class="kw">pub use </span>std :: pin :: Pin ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>dfir_lang :: graph :: DfirGraph ; <span class="kw">pub use </span>dfir_rs :: bytes :: Bytes ; <span class="kw">pub use </span>dfir_rs :: futures :: { Sink , Stream } ; <span class="kw">pub use </span>dfir_rs :: util :: deploy :: DeployPorts ; <span class="kw">pub use </span>stageleft :: { QuotedWithContext , RuntimeData } ; <span class="kw">pub use crate </span>:: __staged :: deploy :: { ClusterSpec , Deploy , ExternalSpec , Node , ProcessSpec , RegisterPort } ; <span class="kw">pub use crate </span>:: __staged :: deploy_runtime :: HydroflowPlusMeta ; <span class="kw">pub use crate </span>:: deploy :: macro_runtime :: DeployRuntime ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Deploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>DeployRuntime { <span class="kw">type </span>InstantiateEnv = () ; <span class="kw">type </span>CompileEnv = RuntimeData &lt; &amp; <span class="lifetime">'a </span>DeployPorts &lt; HydroflowPlusMeta &gt; &gt; ; <span class="kw">type </span>Process = DeployRuntimeNode ; <span class="kw">type </span>Cluster = DeployRuntimeCluster ; <span class="kw">type </span>ExternalProcess = DeployRuntimeNode ; <span class="kw">type </span>Port = String ; <span class="kw">type </span>ExternalRawPort = () ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = usize ; <span class="kw">fn </span>has_trivial_node () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>trivial_process (_id : usize) -&gt; <span class="self">Self </span>:: Process { DeployRuntimeNode { next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , } } <span class="kw">fn </span>trivial_cluster (_id : usize) -&gt; <span class="self">Self </span>:: Cluster { DeployRuntimeCluster { next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , } } <span class="kw">fn </span>allocate_process_port (process : &amp; <span class="self">Self </span>:: Process) -&gt; <span class="self">Self </span>:: Port { process . next_port () } <span class="kw">fn </span>allocate_cluster_port (cluster : &amp; <span class="self">Self </span>:: Cluster) -&gt; <span class="self">Self </span>:: Port { cluster . next_port () } <span class="kw">fn </span>allocate_external_port (_external : &amp; <span class="self">Self </span>:: ExternalProcess) -&gt; <span class="self">Self </span>:: Port { panic ! () ; } <span class="kw">fn </span>o2o_sink_source (env : &amp; <span class="self">Self </span>:: CompileEnv , _p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">crate </span>:: deploy_runtime :: deploy_o2o (* env , p1_port . as_str () , p2_port . as_str ()) } <span class="kw">fn </span>o2o_connect (_p1 : &amp; <span class="self">Self </span>:: Process , _p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , _p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { Box :: new (| | panic ! ()) } <span class="kw">fn </span>o2m_sink_source (env : &amp; <span class="self">Self </span>:: CompileEnv , _p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , _c2 : &amp; <span class="self">Self </span>:: Cluster , c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">crate </span>:: deploy_runtime :: deploy_o2m (* env , p1_port . as_str () , c2_port . as_str ()) } <span class="kw">fn </span>o2m_connect (_p1 : &amp; <span class="self">Self </span>:: Process , _p1_port : &amp; <span class="self">Self </span>:: Port , _c2 : &amp; <span class="self">Self </span>:: Cluster , _c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { Box :: new (| | panic ! ()) } <span class="kw">fn </span>m2o_sink_source (env : &amp; <span class="self">Self </span>:: CompileEnv , _c1 : &amp; <span class="self">Self </span>:: Cluster , c1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">crate </span>:: deploy_runtime :: deploy_m2o (* env , c1_port . as_str () , p2_port . as_str ()) } <span class="kw">fn </span>m2o_connect (_c1 : &amp; <span class="self">Self </span>:: Cluster , _c1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , _p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { Box :: new (| | panic ! ()) } <span class="kw">fn </span>m2m_sink_source (env : &amp; <span class="self">Self </span>:: CompileEnv , _c1 : &amp; <span class="self">Self </span>:: Cluster , c1_port : &amp; <span class="self">Self </span>:: Port , _c2 : &amp; <span class="self">Self </span>:: Cluster , c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">crate </span>:: deploy_runtime :: deploy_m2m (* env , c1_port . as_str () , c2_port . as_str ()) } <span class="kw">fn </span>m2m_connect (_c1 : &amp; <span class="self">Self </span>:: Cluster , _c1_port : &amp; <span class="self">Self </span>:: Port , _c2 : &amp; <span class="self">Self </span>:: Cluster , _c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { Box :: new (| | panic ! ()) } <span class="kw">fn </span>e2o_source (_compile_env : &amp; <span class="self">Self </span>:: CompileEnv , _p1 : &amp; <span class="self">Self </span>:: ExternalProcess , _p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , _p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; syn :: Expr { panic ! () } <span class="kw">fn </span>e2o_connect (_p1 : &amp; <span class="self">Self </span>:: ExternalProcess , _p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , _p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { panic ! () } <span class="kw">fn </span>o2e_sink (_compile_env : &amp; <span class="self">Self </span>:: CompileEnv , _p1 : &amp; <span class="self">Self </span>:: Process , _p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: ExternalProcess , _p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; syn :: Expr { panic ! () } <span class="kw">fn </span>o2e_connect (_p1 : &amp; <span class="self">Self </span>:: Process , _p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: ExternalProcess , _p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { panic ! () } <span class="kw">fn </span>cluster_ids (env : &amp; <span class="self">Self </span>:: CompileEnv , of_cluster : usize ,) -&gt; <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; u32 &gt; , () &gt; + Copy + <span class="lifetime">'a </span>{ <span class="kw">crate </span>:: deploy_runtime :: cluster_members (* env , of_cluster) } <span class="kw">fn </span>cluster_self_id (env : &amp; <span class="self">Self </span>:: CompileEnv) -&gt; <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, u32 , () &gt; + Copy + <span class="lifetime">'a </span>{ <span class="kw">crate </span>:: deploy_runtime :: cluster_self_id (* env) } } <span class="kw">pub use crate </span>:: deploy :: macro_runtime :: DeployRuntimeNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; RegisterPort &lt; <span class="lifetime">'a </span>, DeployRuntime &gt; <span class="kw">for </span>DeployRuntimeNode { <span class="kw">fn </span>register (&amp; <span class="self">self </span>, _key : usize , _port : &lt; DeployRuntime <span class="kw">as </span>Deploy &gt; :: Port) { panic ! () } <span class="kw">fn </span>raw_port (&amp; <span class="self">self </span>, _key : usize) -&gt; &lt; DeployRuntime <span class="kw">as </span>Deploy &gt; :: ExternalRawPort { panic ! () } # [expect (clippy :: manual_async_fn , reason = <span class="string">"buggy Clippy lint for lifetime bounds"</span>)] <span class="kw">fn </span>as_bytes_sink (&amp; <span class="self">self </span>, _key : usize ,) -&gt; <span class="kw">impl </span>Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn </span>Sink &lt; Bytes , Error = std :: io :: Error &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">async </span>{ panic ! () } } # [expect (clippy :: manual_async_fn , reason = <span class="string">"buggy Clippy lint for lifetime bounds"</span>)] <span class="kw">fn </span>as_bincode_sink &lt; T : serde :: Serialize + <span class="lifetime">'static </span>&gt; (&amp; <span class="self">self </span>, _key : usize ,) -&gt; <span class="kw">impl </span>Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn </span>Sink &lt; T , Error = std :: io :: Error &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">async </span>{ panic ! () } } # [expect (clippy :: manual_async_fn , reason = <span class="string">"buggy Clippy lint for lifetime bounds"</span>)] <span class="kw">fn </span>as_bytes_source (&amp; <span class="self">self </span>, _key : usize ,) -&gt; <span class="kw">impl </span>Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn </span>Stream &lt; Item = Bytes &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">async </span>{ panic ! () } } # [expect (clippy :: manual_async_fn , reason = <span class="string">"buggy Clippy lint for lifetime bounds"</span>)] <span class="kw">fn </span>as_bincode_source &lt; T : serde :: de :: DeserializeOwned + <span class="lifetime">'static </span>&gt; (&amp; <span class="self">self </span>, _key : usize ,) -&gt; <span class="kw">impl </span>Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn </span>Stream &lt; Item = T &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">async </span>{ panic ! () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>DeployRuntimeNode { <span class="kw">type </span>Port = String ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>InstantiateEnv = () ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; String { <span class="kw">let </span>next_send_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; format ! (<span class="string">"port_{}" </span>, next_send_port) } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, _env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , _graph : DfirGraph , _extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { panic ! (<span class="string">".deploy() cannot be called on a DeployRuntimeNode"</span>) ; } } <span class="kw">pub use crate </span>:: deploy :: macro_runtime :: DeployRuntimeCluster ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>DeployRuntimeCluster { <span class="kw">type </span>Port = String ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>InstantiateEnv = () ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; String { <span class="kw">let </span>next_send_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; format ! (<span class="string">"port_{}" </span>, next_send_port) } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, _env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , _graph : DfirGraph , _extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { panic ! (<span class="string">".deploy() cannot be called on a DeployRuntimeCluster"</span>) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'_ </span>, DeployRuntime &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; DeployRuntimeNode { DeployRuntimeNode { next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'_ </span>, DeployRuntime &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; DeployRuntimeCluster { DeployRuntimeCluster { next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>ExternalSpec &lt; <span class="lifetime">'_ </span>, DeployRuntime &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; DeployRuntimeNode { panic ! () } } } <span class="kw">pub use </span>macro_runtime :: * ; # [cfg (feature = <span class="string">"deploy"</span>)] <span class="kw">pub mod </span>trybuild { <span class="kw">pub use </span>std :: fs ; <span class="kw">pub use </span>std :: path :: PathBuf ; <span class="kw">pub use </span>dfir_lang :: graph :: { partition_graph , DfirGraph } ; <span class="kw">pub use </span>sha2 :: { Digest , Sha256 } ; <span class="kw">pub use </span>stageleft :: internal :: quote ; <span class="kw">pub use </span>syn :: visit_mut :: VisitMut ; <span class="kw">pub use </span>trybuild_internals_api :: cargo :: { <span class="self">self </span>, Metadata } ; <span class="kw">pub use </span>trybuild_internals_api :: env :: Update ; <span class="kw">pub use </span>trybuild_internals_api :: run :: { PathDependency , Project } ; <span class="kw">pub use </span>trybuild_internals_api :: { dependencies , features , path , Runner } ; <span class="kw">pub use super </span>:: trybuild_rewriters :: { ReplaceCrateNameWithStaged , ReplaceCrateWithOrig } ; <span class="kw">static </span>IS_TEST : std :: sync :: atomic :: AtomicBool = std :: sync :: atomic :: AtomicBool :: new (<span class="bool-val">false</span>) ; <span class="kw">pub fn </span>init_test () { IS_TEST . store (<span class="bool-val">true </span>, std :: sync :: atomic :: Ordering :: Relaxed) ; } <span class="kw">pub fn </span>clean_name_hint (name_hint : &amp; str) -&gt; String { name_hint . replace (<span class="string">"::" </span>, <span class="string">"__"</span>) . replace (<span class="string">" " </span>, <span class="string">"_"</span>) . replace (<span class="string">"," </span>, <span class="string">"_"</span>) . replace (<span class="string">"&lt;" </span>, <span class="string">"_"</span>) . replace (<span class="string">"&gt;" </span>, <span class="string">""</span>) . replace (<span class="string">"(" </span>, <span class="string">""</span>) . replace (<span class="string">")" </span>, <span class="string">""</span>) } <span class="kw">pub fn </span>create_graph_trybuild (graph : DfirGraph , extra_stmts : Vec &lt; syn :: Stmt &gt; , name_hint : &amp; <span class="prelude-ty">Option </span>&lt; String &gt; ,) -&gt; (String , (PathBuf , PathBuf , <span class="prelude-ty">Option </span>&lt; Vec &lt; String &gt; &gt;)) { <span class="kw">let </span>source_dir = cargo :: manifest_dir () . unwrap () ; <span class="kw">let </span>source_manifest = dependencies :: get_manifest (&amp; source_dir) . unwrap () ; <span class="kw">let </span>crate_name = &amp; source_manifest . package . name . to_string () . replace (<span class="string">"-" </span>, <span class="string">"_"</span>) ; <span class="kw">let </span>is_test = IS_TEST . load (std :: sync :: atomic :: Ordering :: Relaxed) ; <span class="kw">let </span><span class="kw-2">mut </span>generated_code = compile_graph_trybuild (graph , extra_stmts) ; ReplaceCrateNameWithStaged { crate_name : crate_name . clone () , } . visit_file_mut (&amp; <span class="kw-2">mut </span>generated_code) ; <span class="kw">let </span><span class="kw-2">mut </span>inlined_staged = stageleft_tool :: gen_staged_trybuild (&amp; path ! (source_dir / <span class="string">"src" </span>/ <span class="string">"lib.rs"</span>) , crate_name . clone () , is_test ,) ; ReplaceCrateWithOrig { crate_name : crate_name . clone () , } . visit_file_mut (&amp; <span class="kw-2">mut </span>inlined_staged) ; <span class="kw">let </span>source = prettyplease :: unparse (&amp; syn :: parse_quote ! { # generated_code # [allow (unused , ambiguous_glob_reexports , clippy :: suspicious_else_formatting , unexpected_cfgs , reason = <span class="string">"generated code"</span>)] <span class="kw">pub mod </span>__staged { # inlined_staged } }) ; <span class="kw">let </span>hash = format ! (<span class="string">"{:X}" </span>, Sha256 :: digest (&amp; source)) . chars () . take (<span class="number">8</span>) . collect :: &lt; String &gt; () ; <span class="kw">let </span>bin_name = <span class="kw">if let </span><span class="prelude-val">Some </span>(name_hint) = &amp; name_hint { format ! (<span class="string">"{}_{}" </span>, clean_name_hint (name_hint) , &amp; hash) } <span class="kw">else </span>{ hash } ; <span class="kw">let </span>trybuild_created = create_trybuild (&amp; source , &amp; bin_name , is_test) . unwrap () ; (bin_name , trybuild_created) } <span class="kw">pub fn </span>compile_graph_trybuild (graph : DfirGraph , extra_stmts : Vec &lt; syn :: Stmt &gt;) -&gt; syn :: File { <span class="kw">let </span>partitioned_graph = partition_graph (graph) . expect (<span class="string">"Failed to partition (cycle detected)."</span>) ; <span class="kw">let </span><span class="kw-2">mut </span>diagnostics = Vec :: new () ; <span class="kw">let </span>tokens = partitioned_graph . as_code (&amp; quote ! { hydro_lang :: dfir_rs } , <span class="bool-val">true </span>, quote ! () , &amp; <span class="kw-2">mut </span>diagnostics ,) ; <span class="kw">let </span>source_ast : syn :: File = syn :: parse_quote ! { #! [allow (unused_imports , unused_crate_dependencies , missing_docs , non_snake_case)] <span class="kw">use </span>hydro_lang ::<span class="kw-2">*</span>; # [allow (unused)] <span class="kw">fn </span>__hydro_runtime &lt;<span class="lifetime">'a </span>&gt; (__hydro_lang_trybuild_cli : <span class="kw-2">&amp;</span><span class="lifetime">'a </span>hydro_lang :: dfir_rs :: util :: deploy :: DeployPorts &lt; hydro_lang :: deploy_runtime :: HydroflowPlusMeta &gt;) -&gt; hydro_lang :: dfir_rs :: scheduled :: graph :: Dfir &lt;<span class="lifetime">'a </span>&gt; { # (# extra_stmts) * # tokens } # [tokio :: main] <span class="kw">async fn </span>main () { <span class="kw">let </span>ports = hydro_lang :: dfir_rs :: util :: deploy :: init_no_ack_start () . <span class="kw">await </span>; <span class="kw">let </span>flow = __hydro_runtime (&amp; ports) ; println ! (<span class="string">"ack start"</span>) ; hydro_lang :: dfir_rs :: util :: deploy :: launch_flow (flow) . <span class="kw">await </span>; } } ; source_ast } <span class="kw">pub fn </span>create_trybuild (source : &amp; str , bin : &amp; str , is_test : bool ,) -&gt; <span class="prelude-ty">Result </span>&lt; (PathBuf , PathBuf , <span class="prelude-ty">Option </span>&lt; Vec &lt; String &gt; &gt;) , trybuild_internals_api :: error :: Error &gt; { <span class="kw">let </span>Metadata { target_directory : target_dir , workspace_root : workspace , packages , } = cargo :: metadata () <span class="question-mark">? </span>; <span class="kw">let </span>source_dir = cargo :: manifest_dir () <span class="question-mark">? </span>; <span class="kw">let </span><span class="kw-2">mut </span>source_manifest = dependencies :: get_manifest (&amp; source_dir) <span class="question-mark">? </span>; <span class="kw">if </span>! is_test { source_manifest . dev_dependencies . clear () ; } <span class="kw">let </span><span class="kw-2">mut </span>features = features :: find () ; <span class="kw">let </span>path_dependencies = source_manifest . dependencies . iter () . filter_map (| (name , dep) | { <span class="kw">let </span>path = dep . path . as_ref () <span class="question-mark">? </span>; <span class="kw">if </span>packages . iter () . any (| p | &amp; p . name == name) { <span class="prelude-val">None </span>} <span class="kw">else </span>{ <span class="prelude-val">Some </span>(PathDependency { name : name . clone () , normalized_path : path . canonicalize () . ok () <span class="question-mark">? </span>, }) } }) . collect () ; <span class="kw">let </span>crate_name = source_manifest . package . name . clone () ; <span class="kw">let </span>project_dir = path ! (target_dir / <span class="string">"hydro_trybuild" </span>/ crate_name /) ; fs :: create_dir_all (&amp; project_dir) <span class="question-mark">? </span>; <span class="kw">let </span>project_name = format ! (<span class="string">"{}-hydro-trybuild" </span>, crate_name) ; <span class="kw">let </span><span class="kw-2">mut </span>manifest = Runner :: make_manifest (&amp; workspace , &amp; project_name , &amp; source_dir , &amp; packages , &amp; [] , source_manifest ,) <span class="question-mark">? </span>; manifest . features . remove (<span class="string">"stageleft_devel"</span>) ; <span class="kw">if let </span><span class="prelude-val">Some </span>(enabled_features) = &amp; <span class="kw-2">mut </span>features { enabled_features . retain (| feature | manifest . features . contains_key (feature) || feature == <span class="string">"default"</span>) ; manifest . features . get_mut (<span class="string">"default"</span>) . iter_mut () . for_each (| v | { v . retain (| f | f != <span class="string">"stageleft_devel"</span>) ; }) ; } <span class="kw">let </span>project = Project { dir : project_dir , source_dir , target_dir , name : project_name , update : Update :: env () <span class="question-mark">? </span>, has_pass : <span class="bool-val">false </span>, has_compile_fail : <span class="bool-val">false </span>, features , workspace , path_dependencies , manifest , keep_going : <span class="bool-val">false </span>, } ; <span class="kw">let </span>manifest_toml = toml :: to_string (&amp; project . manifest) <span class="question-mark">? </span>; fs :: write (path ! (project . dir / <span class="string">"Cargo.toml"</span>) , manifest_toml) <span class="question-mark">? </span>; fs :: create_dir_all (path ! (project . dir / <span class="string">"src" </span>/ <span class="string">"bin"</span>)) <span class="question-mark">? </span>; <span class="kw">let </span>out_path = path ! (project . dir / <span class="string">"src" </span>/ <span class="string">"bin" </span>/ format ! (<span class="string">"{bin}.rs"</span>)) ; <span class="kw">if </span>! out_path . exists () || fs :: read_to_string (&amp; out_path) <span class="question-mark">? </span>!= source { fs :: write (path ! (project . dir / <span class="string">"src" </span>/ <span class="string">"bin" </span>/ format ! (<span class="string">"{bin}.rs"</span>)) , source ,) <span class="question-mark">? </span>; } <span class="kw">let </span>workspace_cargo_lock = path ! (project . workspace / <span class="string">"Cargo.lock"</span>) ; <span class="kw">if </span>workspace_cargo_lock . exists () { <span class="kw">let _ </span>= fs :: copy (workspace_cargo_lock , path ! (project . dir / <span class="string">"Cargo.lock"</span>)) ; } <span class="kw">else </span>{ <span class="kw">let _ </span>= cargo :: cargo (&amp; project) . arg (<span class="string">"generate-lockfile"</span>) . status () ; } <span class="kw">let </span>workspace_dot_cargo_config_toml = path ! (project . workspace / <span class="string">".cargo" </span>/ <span class="string">"config.toml"</span>) ; <span class="kw">if </span>workspace_dot_cargo_config_toml . exists () { <span class="kw">let </span>dot_cargo_folder = path ! (project . dir / <span class="string">".cargo"</span>) ; fs :: create_dir_all (&amp; dot_cargo_folder) <span class="question-mark">? </span>; <span class="kw">let _ </span>= fs :: copy (workspace_dot_cargo_config_toml , path ! (dot_cargo_folder / <span class="string">"config.toml"</span>) ,) ; } <span class="prelude-val">Ok </span>((project . dir . as_ref () . into () , path ! (project . target_dir / <span class="string">"hydro_trybuild"</span>) , project . features ,)) } } # [cfg (feature = <span class="string">"deploy"</span>)] # [doc (hidden)] <span class="kw">pub mod </span>trybuild_rewriters { <span class="kw">pub use </span>syn :: visit_mut :: VisitMut ; <span class="kw">pub use crate </span>:: deploy :: trybuild_rewriters :: ReplaceCrateNameWithStaged ; # [cfg (stageleft_macro)] <span class="kw">impl </span>VisitMut <span class="kw">for </span>ReplaceCrateNameWithStaged { <span class="kw">fn </span>visit_type_path_mut (&amp; <span class="kw-2">mut </span><span class="self">self </span>, i : &amp; <span class="kw-2">mut </span>syn :: TypePath) { <span class="kw">if let </span><span class="prelude-val">Some </span>(first) = i . path . segments . first () { <span class="kw">if </span>first . ident == <span class="self">self </span>. crate_name { <span class="kw">let </span>tail = i . path . segments . iter () . skip (<span class="number">1</span>) . collect :: &lt; Vec &lt; <span class="kw">_ </span>&gt; &gt; () ; * i = syn :: parse_quote ! (<span class="kw">crate </span>:: __staged # (::# tail) <span class="kw-2">*</span>) ; } } syn :: visit_mut :: visit_type_path_mut (<span class="self">self </span>, i) ; } } <span class="kw">pub use crate </span>:: deploy :: trybuild_rewriters :: ReplaceCrateWithOrig ; # [cfg (stageleft_macro)] <span class="kw">impl </span>VisitMut <span class="kw">for </span>ReplaceCrateWithOrig { <span class="kw">fn </span>visit_item_use_mut (&amp; <span class="kw-2">mut </span><span class="self">self </span>, i : &amp; <span class="kw-2">mut </span>syn :: ItemUse) { <span class="kw">if let </span>syn :: UseTree :: Path (p) = &amp; <span class="kw-2">mut </span>i . tree { <span class="kw">if </span>p . ident == <span class="string">"crate" </span>{ p . ident = syn :: Ident :: new (&amp; <span class="self">self </span>. crate_name , p . ident . span ()) ; i . leading_colon = <span class="prelude-val">Some </span>(Default :: default ()) ; } } syn :: visit_mut :: visit_item_use_mut (<span class="self">self </span>, i) ; } } } # [cfg (feature = <span class="string">"deploy"</span>)] <span class="kw">pub use </span>trybuild :: init_test ; # [cfg (feature = <span class="string">"deploy"</span>)] <span class="kw">pub mod </span>deploy_graph { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: HashMap ; <span class="kw">pub use </span>std :: future :: Future ; <span class="kw">pub use </span>std :: io :: Error ; <span class="kw">pub use </span>std :: pin :: Pin ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>std :: sync :: Arc ; <span class="kw">pub use </span>dfir_lang :: graph :: DfirGraph ; <span class="kw">pub use </span>dfir_rs :: bytes :: Bytes ; <span class="kw">pub use </span>dfir_rs :: futures :: { Sink , SinkExt , Stream , StreamExt } ; <span class="kw">pub use </span>dfir_rs :: util :: deploy :: { ConnectedSink , ConnectedSource } ; <span class="kw">pub use </span>hydro_deploy :: custom_service :: CustomClientPort ; <span class="kw">pub use </span>hydro_deploy :: hydroflow_crate :: ports :: { DemuxSink , HydroflowSink , HydroflowSource , TaggedSource , } ; <span class="kw">pub use </span>hydro_deploy :: hydroflow_crate :: tracing_options :: TracingOptions ; <span class="kw">pub use </span>hydro_deploy :: hydroflow_crate :: HydroflowCrateService ; <span class="kw">pub use </span>hydro_deploy :: { CustomService , Deployment , Host , HydroflowCrate } ; <span class="kw">pub use </span>nameof :: name_of ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use </span>stageleft :: { QuotedWithContext , RuntimeData } ; <span class="kw">pub use </span>tokio :: sync :: RwLock ; <span class="kw">pub use super </span>:: trybuild :: create_graph_trybuild ; <span class="kw">pub use super </span>:: { ClusterSpec , Deploy , ExternalSpec , IntoProcessSpec , Node , ProcessSpec , RegisterPort } ; <span class="kw">pub use crate </span>:: __staged :: deploy_runtime :: * ; <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: HydroDeploy ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Deploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>HydroDeploy { <span class="kw">type </span>InstantiateEnv = Deployment ; <span class="kw">type </span>CompileEnv = () ; <span class="kw">type </span>Process = DeployNode ; <span class="kw">type </span>Cluster = DeployCluster ; <span class="kw">type </span>ExternalProcess = DeployExternal ; <span class="kw">type </span>Meta = HashMap &lt; usize , Vec &lt; u32 &gt; &gt; ; <span class="kw">type </span>GraphId = () ; <span class="kw">type </span>Port = String ; <span class="kw">type </span>ExternalRawPort = CustomClientPort ; <span class="kw">fn </span>allocate_process_port (process : &amp; <span class="self">Self </span>:: Process) -&gt; <span class="self">Self </span>:: Port { process . next_port () } <span class="kw">fn </span>allocate_cluster_port (cluster : &amp; <span class="self">Self </span>:: Cluster) -&gt; <span class="self">Self </span>:: Port { cluster . next_port () } <span class="kw">fn </span>allocate_external_port (external : &amp; <span class="self">Self </span>:: ExternalProcess) -&gt; <span class="self">Self </span>:: Port { external . next_port () } <span class="kw">fn </span>o2o_sink_source (_env : &amp; () , _p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">let </span>p1_port = p1_port . as_str () ; <span class="kw">let </span>p2_port = p2_port . as_str () ; deploy_o2o (RuntimeData :: new (<span class="string">"__hydro_lang_trybuild_cli"</span>) , p1_port , p2_port ,) } <span class="kw">fn </span>o2o_connect (p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { <span class="kw">let </span>p1 = p1 . clone () ; <span class="kw">let </span>p1_port = p1_port . clone () ; <span class="kw">let </span>p2 = p2 . clone () ; <span class="kw">let </span>p2_port = p2_port . clone () ; Box :: new (<span class="kw">move </span>| | { <span class="kw">let </span>self_underlying_borrow = p1 . underlying . borrow () ; <span class="kw">let </span>self_underlying = self_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>source_port = self_underlying . try_read () . unwrap () . get_port (p1_port . clone () , self_underlying) ; <span class="kw">let </span>other_underlying_borrow = p2 . underlying . borrow () ; <span class="kw">let </span>other_underlying = other_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>recipient_port = other_underlying . try_read () . unwrap () . get_port (p2_port . clone () , other_underlying) ; source_port . send_to (&amp; recipient_port) }) } <span class="kw">fn </span>o2m_sink_source (_env : &amp; () , _p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , _c2 : &amp; <span class="self">Self </span>:: Cluster , c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">let </span>p1_port = p1_port . as_str () ; <span class="kw">let </span>c2_port = c2_port . as_str () ; deploy_o2m (RuntimeData :: new (<span class="string">"__hydro_lang_trybuild_cli"</span>) , p1_port , c2_port ,) } <span class="kw">fn </span>o2m_connect (p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , c2 : &amp; <span class="self">Self </span>:: Cluster , c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { <span class="kw">let </span>p1 = p1 . clone () ; <span class="kw">let </span>p1_port = p1_port . clone () ; <span class="kw">let </span>c2 = c2 . clone () ; <span class="kw">let </span>c2_port = c2_port . clone () ; Box :: new (<span class="kw">move </span>| | { <span class="kw">let </span>self_underlying_borrow = p1 . underlying . borrow () ; <span class="kw">let </span>self_underlying = self_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>source_port = self_underlying . try_read () . unwrap () . get_port (p1_port . clone () , self_underlying) ; <span class="kw">let </span>recipient_port = DemuxSink { demux : c2 . members . borrow () . iter () . enumerate () . map (| (id , c) | { <span class="kw">let </span>n = c . underlying . try_read () . unwrap () ; (id <span class="kw">as </span>u32 , Arc :: new (n . get_port (c2_port . clone () , &amp; c . underlying)) <span class="kw">as </span>Arc &lt; <span class="kw">dyn </span>HydroflowSink + <span class="lifetime">'static </span>&gt; ,) }) . collect () , } ; source_port . send_to (&amp; recipient_port) }) } <span class="kw">fn </span>m2o_sink_source (_env : &amp; () , _c1 : &amp; <span class="self">Self </span>:: Cluster , c1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">let </span>c1_port = c1_port . as_str () ; <span class="kw">let </span>p2_port = p2_port . as_str () ; deploy_m2o (RuntimeData :: new (<span class="string">"__hydro_lang_trybuild_cli"</span>) , c1_port , p2_port ,) } <span class="kw">fn </span>m2o_connect (c1 : &amp; <span class="self">Self </span>:: Cluster , c1_port : &amp; <span class="self">Self </span>:: Port , p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { <span class="kw">let </span>c1 = c1 . clone () ; <span class="kw">let </span>c1_port = c1_port . clone () ; <span class="kw">let </span>p2 = p2 . clone () ; <span class="kw">let </span>p2_port = p2_port . clone () ; Box :: new (<span class="kw">move </span>| | { <span class="kw">let </span>other_underlying_borrow = p2 . underlying . borrow () ; <span class="kw">let </span>other_underlying = other_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>recipient_port = other_underlying . try_read () . unwrap () . get_port (p2_port . clone () , other_underlying) . merge () ; <span class="kw">for </span>(i , node) <span class="kw">in </span>c1 . members . borrow () . iter () . enumerate () { <span class="kw">let </span>source_port = node . underlying . try_read () . unwrap () . get_port (c1_port . clone () , &amp; node . underlying) ; TaggedSource { source : Arc :: new (source_port) , tag : i <span class="kw">as </span>u32 , } . send_to (&amp; recipient_port) ; } }) } <span class="kw">fn </span>m2m_sink_source (_env : &amp; () , _c1 : &amp; <span class="self">Self </span>:: Cluster , c1_port : &amp; <span class="self">Self </span>:: Port , _c2 : &amp; <span class="self">Self </span>:: Cluster , c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; (syn :: Expr , syn :: Expr) { <span class="kw">let </span>c1_port = c1_port . as_str () ; <span class="kw">let </span>c2_port = c2_port . as_str () ; deploy_m2m (RuntimeData :: new (<span class="string">"__hydro_lang_trybuild_cli"</span>) , c1_port , c2_port ,) } <span class="kw">fn </span>m2m_connect (c1 : &amp; <span class="self">Self </span>:: Cluster , c1_port : &amp; <span class="self">Self </span>:: Port , c2 : &amp; <span class="self">Self </span>:: Cluster , c2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { <span class="kw">let </span>c1 = c1 . clone () ; <span class="kw">let </span>c1_port = c1_port . clone () ; <span class="kw">let </span>c2 = c2 . clone () ; <span class="kw">let </span>c2_port = c2_port . clone () ; Box :: new (<span class="kw">move </span>| | { <span class="kw">for </span>(i , sender) <span class="kw">in </span>c1 . members . borrow () . iter () . enumerate () { <span class="kw">let </span>source_port = sender . underlying . try_read () . unwrap () . get_port (c1_port . clone () , &amp; sender . underlying) ; <span class="kw">let </span>recipient_port = DemuxSink { demux : c2 . members . borrow () . iter () . enumerate () . map (| (id , c) | { <span class="kw">let </span>n = c . underlying . try_read () . unwrap () ; (id <span class="kw">as </span>u32 , Arc :: new (n . get_port (c2_port . clone () , &amp; c . underlying) . merge ()) <span class="kw">as </span>Arc &lt; <span class="kw">dyn </span>HydroflowSink + <span class="lifetime">'static </span>&gt; ,) }) . collect () , } ; TaggedSource { source : Arc :: new (source_port) , tag : i <span class="kw">as </span>u32 , } . send_to (&amp; recipient_port) ; } }) } <span class="kw">fn </span>e2o_source (_compile_env : &amp; <span class="self">Self </span>:: CompileEnv , _p1 : &amp; <span class="self">Self </span>:: ExternalProcess , p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; syn :: Expr { <span class="kw">let </span>p1_port = p1_port . as_str () ; <span class="kw">let </span>p2_port = p2_port . as_str () ; deploy_e2o (RuntimeData :: new (<span class="string">"__hydro_lang_trybuild_cli"</span>) , p1_port , p2_port ,) } <span class="kw">fn </span>e2o_connect (p1 : &amp; <span class="self">Self </span>:: ExternalProcess , p1_port : &amp; <span class="self">Self </span>:: Port , p2 : &amp; <span class="self">Self </span>:: Process , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { <span class="kw">let </span>p1 = p1 . clone () ; <span class="kw">let </span>p1_port = p1_port . clone () ; <span class="kw">let </span>p2 = p2 . clone () ; <span class="kw">let </span>p2_port = p2_port . clone () ; Box :: new (<span class="kw">move </span>| | { <span class="kw">let </span>self_underlying_borrow = p1 . underlying . borrow () ; <span class="kw">let </span>self_underlying = self_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>source_port = self_underlying . try_read () . unwrap () . declare_client (self_underlying) ; <span class="kw">let </span>other_underlying_borrow = p2 . underlying . borrow () ; <span class="kw">let </span>other_underlying = other_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>recipient_port = other_underlying . try_read () . unwrap () . get_port (p2_port . clone () , other_underlying) ; source_port . send_to (&amp; recipient_port) ; p1 . client_ports . borrow_mut () . insert (p1_port . clone () , source_port) ; }) } <span class="kw">fn </span>o2e_sink (_compile_env : &amp; <span class="self">Self </span>:: CompileEnv , _p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , _p2 : &amp; <span class="self">Self </span>:: ExternalProcess , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; syn :: Expr { <span class="kw">let </span>p1_port = p1_port . as_str () ; <span class="kw">let </span>p2_port = p2_port . as_str () ; deploy_o2e (RuntimeData :: new (<span class="string">"__hydro_lang_trybuild_cli"</span>) , p1_port , p2_port ,) } <span class="kw">fn </span>o2e_connect (p1 : &amp; <span class="self">Self </span>:: Process , p1_port : &amp; <span class="self">Self </span>:: Port , p2 : &amp; <span class="self">Self </span>:: ExternalProcess , p2_port : &amp; <span class="self">Self </span>:: Port ,) -&gt; Box &lt; <span class="kw">dyn </span>FnOnce () &gt; { <span class="kw">let </span>p1 = p1 . clone () ; <span class="kw">let </span>p1_port = p1_port . clone () ; <span class="kw">let </span>p2 = p2 . clone () ; <span class="kw">let </span>p2_port = p2_port . clone () ; Box :: new (<span class="kw">move </span>| | { <span class="kw">let </span>self_underlying_borrow = p1 . underlying . borrow () ; <span class="kw">let </span>self_underlying = self_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>source_port = self_underlying . try_read () . unwrap () . get_port (p1_port . clone () , self_underlying) ; <span class="kw">let </span>other_underlying_borrow = p2 . underlying . borrow () ; <span class="kw">let </span>other_underlying = other_underlying_borrow . as_ref () . unwrap () ; <span class="kw">let </span>recipient_port = other_underlying . try_read () . unwrap () . declare_client (other_underlying) ; source_port . send_to (&amp; recipient_port) ; p2 . client_ports . borrow_mut () . insert (p2_port . clone () , recipient_port) ; }) } <span class="kw">fn </span>cluster_ids (_env : &amp; <span class="self">Self </span>:: CompileEnv , of_cluster : usize ,) -&gt; <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; u32 &gt; , () &gt; + Copy + <span class="lifetime">'a </span>{ cluster_members (RuntimeData :: new (<span class="string">"__hydro_lang_trybuild_cli"</span>) , of_cluster) } <span class="kw">fn </span>cluster_self_id (_env : &amp; <span class="self">Self </span>:: CompileEnv) -&gt; <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, u32 , () &gt; + Copy + <span class="lifetime">'a </span>{ cluster_self_id (RuntimeData :: new (<span class="string">"__hydro_lang_trybuild_cli"</span>)) } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployCrateWrapper ; <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: TrybuildHost ; # [cfg (stageleft_macro)] <span class="kw">impl </span>From &lt; Arc &lt; <span class="kw">dyn </span>Host &gt; &gt; <span class="kw">for </span>TrybuildHost { <span class="kw">fn </span>from (host : Arc &lt; <span class="kw">dyn </span>Host &gt;) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{ host , display_name : <span class="prelude-val">None </span>, rustflags : <span class="prelude-val">None </span>, tracing : <span class="prelude-val">None </span>, name_hint : <span class="prelude-val">None </span>, cluster_idx : <span class="prelude-val">None </span>, } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; H : Host + <span class="lifetime">'static </span>&gt; From &lt; Arc &lt; H &gt; &gt; <span class="kw">for </span>TrybuildHost { <span class="kw">fn </span>from (host : Arc &lt; H &gt;) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{ host , display_name : <span class="prelude-val">None </span>, rustflags : <span class="prelude-val">None </span>, tracing : <span class="prelude-val">None </span>, name_hint : <span class="prelude-val">None </span>, cluster_idx : <span class="prelude-val">None </span>, } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>TrybuildHost { <span class="kw">pub fn </span>new (host : Arc &lt; <span class="kw">dyn </span>Host &gt;) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{ host , display_name : <span class="prelude-val">None </span>, rustflags : <span class="prelude-val">None </span>, tracing : <span class="prelude-val">None </span>, name_hint : <span class="prelude-val">None </span>, cluster_idx : <span class="prelude-val">None </span>, } } <span class="kw">pub fn </span>display_name (<span class="self">self </span>, display_name : <span class="kw">impl </span>Into &lt; String &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">if </span><span class="self">self </span>. display_name . is_some () { panic ! (<span class="string">"{} already set" </span>, name_of ! (display_name <span class="kw">in </span><span class="self">Self</span>)) ; } <span class="self">Self </span>{ display_name : <span class="prelude-val">Some </span>(display_name . into ()) , .. <span class="self">self </span>} } <span class="kw">pub fn </span>rustflags (<span class="self">self </span>, rustflags : <span class="kw">impl </span>Into &lt; String &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">if </span><span class="self">self </span>. rustflags . is_some () { panic ! (<span class="string">"{} already set" </span>, name_of ! (rustflags <span class="kw">in </span><span class="self">Self</span>)) ; } <span class="self">Self </span>{ rustflags : <span class="prelude-val">Some </span>(rustflags . into ()) , .. <span class="self">self </span>} } <span class="kw">pub fn </span>tracing (<span class="self">self </span>, tracing : TracingOptions) -&gt; <span class="self">Self </span>{ <span class="kw">if </span><span class="self">self </span>. tracing . is_some () { panic ! (<span class="string">"{} already set" </span>, name_of ! (tracing <span class="kw">in </span><span class="self">Self</span>)) ; } <span class="self">Self </span>{ tracing : <span class="prelude-val">Some </span>(tracing) , .. <span class="self">self </span>} } } # [cfg (stageleft_macro)] <span class="kw">impl </span>IntoProcessSpec &lt; <span class="lifetime">'_ </span>, HydroDeploy &gt; <span class="kw">for </span>Arc &lt; <span class="kw">dyn </span>Host &gt; { <span class="kw">type </span>ProcessSpec = TrybuildHost ; <span class="kw">fn </span>into_process_spec (<span class="self">self</span>) -&gt; TrybuildHost { TrybuildHost { host : <span class="self">self </span>, display_name : <span class="prelude-val">None </span>, rustflags : <span class="prelude-val">None </span>, tracing : <span class="prelude-val">None </span>, name_hint : <span class="prelude-val">None </span>, cluster_idx : <span class="prelude-val">None </span>, } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; H : Host + <span class="lifetime">'static </span>&gt; IntoProcessSpec &lt; <span class="lifetime">'_ </span>, HydroDeploy &gt; <span class="kw">for </span>Arc &lt; H &gt; { <span class="kw">type </span>ProcessSpec = TrybuildHost ; <span class="kw">fn </span>into_process_spec (<span class="self">self</span>) -&gt; TrybuildHost { TrybuildHost { host : <span class="self">self </span>, display_name : <span class="prelude-val">None </span>, rustflags : <span class="prelude-val">None </span>, tracing : <span class="prelude-val">None </span>, name_hint : <span class="prelude-val">None </span>, cluster_idx : <span class="prelude-val">None </span>, } } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployExternal ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployExternal { <span class="kw">pub fn </span>take_port (&amp; <span class="self">self </span>, key : usize) -&gt; CustomClientPort { <span class="self">self </span>. client_ports . borrow_mut () . remove (<span class="self">self </span>. allocated_ports . borrow () . get (&amp; key) . unwrap ()) . unwrap () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; RegisterPort &lt; <span class="lifetime">'a </span>, HydroDeploy &gt; <span class="kw">for </span>DeployExternal { <span class="kw">fn </span>register (&amp; <span class="self">self </span>, key : usize , port : &lt; HydroDeploy <span class="kw">as </span>Deploy &gt; :: Port) { <span class="self">self </span>. allocated_ports . borrow_mut () . insert (key , port) ; } <span class="kw">fn </span>raw_port (&amp; <span class="self">self </span>, key : usize) -&gt; &lt; HydroDeploy <span class="kw">as </span>Deploy &gt; :: ExternalRawPort { <span class="self">self </span>. client_ports . borrow_mut () . remove (<span class="self">self </span>. allocated_ports . borrow () . get (&amp; key) . unwrap ()) . unwrap () } <span class="kw">fn </span>as_bytes_sink (&amp; <span class="self">self </span>, key : usize ,) -&gt; <span class="kw">impl </span>Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn </span>Sink &lt; Bytes , Error = Error &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">let </span>port = <span class="self">self </span>. raw_port (key) ; <span class="kw">async move </span>{ <span class="kw">let </span>sink = port . connect () . <span class="kw">await </span>. into_sink () ; sink <span class="kw">as </span>Pin &lt; Box &lt; <span class="kw">dyn </span>Sink &lt; Bytes , Error = Error &gt; &gt; &gt; } } <span class="kw">fn </span>as_bincode_sink &lt; T : Serialize + <span class="lifetime">'static </span>&gt; (&amp; <span class="self">self </span>, key : usize ,) -&gt; <span class="kw">impl </span>Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn </span>Sink &lt; T , Error = Error &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">let </span>port = <span class="self">self </span>. raw_port (key) ; <span class="kw">async move </span>{ <span class="kw">let </span>sink = port . connect () . <span class="kw">await </span>. into_sink () ; Box :: pin (sink . with (| item | <span class="kw">async move </span>{ <span class="prelude-val">Ok </span>(bincode :: serialize (&amp; item) . unwrap () . into ()) })) <span class="kw">as </span>Pin &lt; Box &lt; <span class="kw">dyn </span>Sink &lt; T , Error = Error &gt; &gt; &gt; } } <span class="kw">fn </span>as_bytes_source (&amp; <span class="self">self </span>, key : usize ,) -&gt; <span class="kw">impl </span>Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn </span>Stream &lt; Item = Bytes &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">let </span>port = <span class="self">self </span>. raw_port (key) ; <span class="kw">async move </span>{ <span class="kw">let </span>source = port . connect () . <span class="kw">await </span>. into_source () ; Box :: pin (source . map (| r | r . unwrap () . freeze ())) <span class="kw">as </span>Pin &lt; Box &lt; <span class="kw">dyn </span>Stream &lt; Item = Bytes &gt; &gt; &gt; } } <span class="kw">fn </span>as_bincode_source &lt; T : DeserializeOwned + <span class="lifetime">'static </span>&gt; (&amp; <span class="self">self </span>, key : usize ,) -&gt; <span class="kw">impl </span>Future &lt; Output = Pin &lt; Box &lt; <span class="kw">dyn </span>Stream &lt; Item = T &gt; &gt; &gt; &gt; + <span class="lifetime">'a </span>{ <span class="kw">let </span>port = <span class="self">self </span>. raw_port (key) ; <span class="kw">async move </span>{ <span class="kw">let </span>source = port . connect () . <span class="kw">await </span>. into_source () ; Box :: pin (source . map (| item | bincode :: deserialize (&amp; item . unwrap ()) . unwrap ())) <span class="kw">as </span>Pin &lt; Box &lt; <span class="kw">dyn </span>Stream &lt; Item = T &gt; &gt; &gt; } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>DeployExternal { <span class="kw">type </span>Port = String ; <span class="kw">type </span>Meta = HashMap &lt; usize , Vec &lt; u32 &gt; &gt; ; <span class="kw">type </span>InstantiateEnv = Deployment ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>:: Port { <span class="kw">let </span>next_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; format ! (<span class="string">"port_{}" </span>, next_port) } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , _graph : DfirGraph , _extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { <span class="kw">let </span>service = env . CustomService (<span class="self">self </span>. host . clone () , vec ! []) ; * <span class="self">self </span>. underlying . borrow_mut () = <span class="prelude-val">Some </span>(service) ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } } # [cfg (stageleft_macro)] <span class="kw">impl </span>ExternalSpec &lt; <span class="lifetime">'_ </span>, HydroDeploy &gt; <span class="kw">for </span>Arc &lt; <span class="kw">dyn </span>Host &gt; { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; DeployExternal { DeployExternal { next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , host : <span class="self">self </span>, underlying : Rc :: new (RefCell :: new (<span class="prelude-val">None</span>)) , allocated_ports : Rc :: new (RefCell :: new (HashMap :: new ())) , client_ports : Rc :: new (RefCell :: new (HashMap :: new ())) , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; H : Host + <span class="lifetime">'static </span>&gt; ExternalSpec &lt; <span class="lifetime">'_ </span>, HydroDeploy &gt; <span class="kw">for </span>Arc &lt; H &gt; { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; DeployExternal { DeployExternal { next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , host : <span class="self">self </span>, underlying : Rc :: new (RefCell :: new (<span class="prelude-val">None</span>)) , allocated_ports : Rc :: new (RefCell :: new (HashMap :: new ())) , client_ports : Rc :: new (RefCell :: new (HashMap :: new ())) , } } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: CrateOrTrybuild ; <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployCrateWrapper <span class="kw">for </span>DeployNode { <span class="kw">fn </span>underlying (&amp; <span class="self">self</span>) -&gt; Arc &lt; RwLock &lt; HydroflowCrateService &gt; &gt; { <span class="self">self </span>. underlying . borrow () . as_ref () . unwrap () . clone () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>DeployNode { <span class="kw">type </span>Port = String ; <span class="kw">type </span>Meta = HashMap &lt; usize , Vec &lt; u32 &gt; &gt; ; <span class="kw">type </span>InstantiateEnv = Deployment ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; String { <span class="kw">let </span>next_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; format ! (<span class="string">"port_{}" </span>, next_port) } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, meta : &amp; <span class="self">Self </span>:: Meta) { <span class="kw">let </span>underlying_node = <span class="self">self </span>. underlying . borrow () ; <span class="kw">let </span><span class="kw-2">mut </span>n = underlying_node . as_ref () . unwrap () . try_write () . unwrap () ; n . update_meta (HydroflowPlusMeta { clusters : meta . clone () , cluster_id : <span class="prelude-val">None </span>, subgraph_id : <span class="self">self </span>. id , }) ; } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , graph : DfirGraph , extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { <span class="kw">let </span>service = <span class="kw">match </span><span class="self">self </span>. service_spec . borrow_mut () . take () . unwrap () { CrateOrTrybuild :: Crate (c) =&gt; c , CrateOrTrybuild :: Trybuild (trybuild) =&gt; { <span class="kw">let </span>(bin_name , (dir , target_dir , features)) = create_graph_trybuild (graph , extra_stmts , &amp; trybuild . name_hint) ; create_trybuild_service (trybuild , &amp; dir , &amp; target_dir , &amp; features , &amp; bin_name) } } ; * <span class="self">self </span>. underlying . borrow_mut () = <span class="prelude-val">Some </span>(env . add_service (service)) ; } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployClusterNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployCrateWrapper <span class="kw">for </span>DeployClusterNode { <span class="kw">fn </span>underlying (&amp; <span class="self">self</span>) -&gt; Arc &lt; RwLock &lt; HydroflowCrateService &gt; &gt; { <span class="self">self </span>. underlying . clone () } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployCluster ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployCluster { <span class="kw">pub fn </span>members (&amp; <span class="self">self</span>) -&gt; Vec &lt; DeployClusterNode &gt; { <span class="self">self </span>. members . borrow () . clone () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>DeployCluster { <span class="kw">type </span>Port = String ; <span class="kw">type </span>Meta = HashMap &lt; usize , Vec &lt; u32 &gt; &gt; ; <span class="kw">type </span>InstantiateEnv = Deployment ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) -&gt; String { <span class="kw">let </span>next_port = * <span class="self">self </span>. next_port . borrow () ; * <span class="self">self </span>. next_port . borrow_mut () += <span class="number">1 </span>; format ! (<span class="string">"port_{}" </span>, next_port) } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , graph : DfirGraph , extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { <span class="kw">let </span>has_trybuild = <span class="self">self </span>. cluster_spec . borrow () . as_ref () . unwrap () . iter () . any (| spec | matches ! (spec , CrateOrTrybuild :: Trybuild { .. })) ; <span class="kw">let </span>maybe_trybuild = <span class="kw">if </span>has_trybuild { <span class="prelude-val">Some </span>(create_graph_trybuild (graph , extra_stmts , &amp; <span class="self">self </span>. name_hint)) } <span class="kw">else </span>{ <span class="prelude-val">None </span>} ; <span class="kw">let </span>cluster_nodes = <span class="self">self </span>. cluster_spec . borrow_mut () . take () . unwrap () . into_iter () . map (| spec | { <span class="kw">let </span>service = <span class="kw">match </span>spec { CrateOrTrybuild :: Crate (c) =&gt; c , CrateOrTrybuild :: Trybuild (trybuild) =&gt; { <span class="kw">let </span>(bin_name , (dir , target_dir , features)) = maybe_trybuild . as_ref () . unwrap () ; create_trybuild_service (trybuild , dir , target_dir , features , bin_name) } } ; env . add_service (service) }) . collect :: &lt; Vec &lt; <span class="kw">_ </span>&gt; &gt; () ; meta . insert (<span class="self">self </span>. id , (<span class="number">0 </span>.. (cluster_nodes . len () <span class="kw">as </span>u32)) . collect ()) ; * <span class="self">self </span>. members . borrow_mut () = cluster_nodes . into_iter () . map (| n | DeployClusterNode { underlying : n }) . collect () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, meta : &amp; <span class="self">Self </span>:: Meta) { <span class="kw">for </span>(cluster_id , node) <span class="kw">in </span><span class="self">self </span>. members . borrow () . iter () . enumerate () { <span class="kw">let </span><span class="kw-2">mut </span>n = node . underlying . try_write () . unwrap () ; n . update_meta (HydroflowPlusMeta { clusters : meta . clone () , cluster_id : <span class="prelude-val">Some </span>(cluster_id <span class="kw">as </span>u32) , subgraph_id : <span class="self">self </span>. id , }) ; } } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployProcessSpec ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployProcessSpec { <span class="kw">pub fn </span>new (t : HydroflowCrate) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>(t) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'_ </span>, HydroDeploy &gt; <span class="kw">for </span>DeployProcessSpec { <span class="kw">fn </span>build (<span class="self">self </span>, id : usize , _name_hint : &amp; str) -&gt; DeployNode { DeployNode { id , next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , service_spec : Rc :: new (RefCell :: new (<span class="prelude-val">Some </span>(CrateOrTrybuild :: Crate (<span class="self">self </span>. <span class="number">0</span>)))) , underlying : Rc :: new (RefCell :: new (<span class="prelude-val">None</span>)) , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'_ </span>, HydroDeploy &gt; <span class="kw">for </span>TrybuildHost { <span class="kw">fn </span>build (<span class="kw-2">mut </span><span class="self">self </span>, id : usize , name_hint : &amp; str) -&gt; DeployNode { <span class="self">self </span>. name_hint = <span class="prelude-val">Some </span>(format ! (<span class="string">"{} (process {id})" </span>, name_hint)) ; DeployNode { id , next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , service_spec : Rc :: new (RefCell :: new (<span class="prelude-val">Some </span>(CrateOrTrybuild :: Trybuild (<span class="self">self</span>)))) , underlying : Rc :: new (RefCell :: new (<span class="prelude-val">None</span>)) , } } } <span class="kw">pub use crate </span>:: deploy :: deploy_graph :: DeployClusterSpec ; # [cfg (stageleft_macro)] <span class="kw">impl </span>DeployClusterSpec { <span class="kw">pub fn </span>new (crates : Vec &lt; HydroflowCrate &gt;) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>(crates) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'_ </span>, HydroDeploy &gt; <span class="kw">for </span>DeployClusterSpec { <span class="kw">fn </span>build (<span class="self">self </span>, id : usize , _name_hint : &amp; str) -&gt; DeployCluster { DeployCluster { id , next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , cluster_spec : Rc :: new (RefCell :: new (<span class="prelude-val">Some </span>(<span class="self">self </span>. <span class="number">0 </span>. into_iter () . map (CrateOrTrybuild :: Crate) . collect () ,))) , members : Rc :: new (RefCell :: new (vec ! [])) , name_hint : <span class="prelude-val">None </span>, } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; T : Into &lt; TrybuildHost &gt; , I : IntoIterator &lt; Item = T &gt; &gt; ClusterSpec &lt; <span class="lifetime">'_ </span>, HydroDeploy &gt; <span class="kw">for </span>I { <span class="kw">fn </span>build (<span class="self">self </span>, id : usize , name_hint : &amp; str) -&gt; DeployCluster { <span class="kw">let </span>name_hint = format ! (<span class="string">"{} (cluster {id})" </span>, name_hint) ; DeployCluster { id , next_port : Rc :: new (RefCell :: new (<span class="number">0</span>)) , cluster_spec : Rc :: new (RefCell :: new (<span class="prelude-val">Some </span>(<span class="self">self </span>. into_iter () . enumerate () . map (| (idx , b) | { <span class="kw">let </span><span class="kw-2">mut </span>b = b . into () ; b . name_hint = <span class="prelude-val">Some </span>(name_hint . clone ()) ; b . cluster_idx = <span class="prelude-val">Some </span>(idx) ; CrateOrTrybuild :: Trybuild (b) }) . collect () ,))) , members : Rc :: new (RefCell :: new (vec ! [])) , name_hint : <span class="prelude-val">Some </span>(name_hint) , } } } <span class="kw">pub fn </span>create_trybuild_service (trybuild : TrybuildHost , dir : &amp; std :: path :: PathBuf , target_dir : &amp; std :: path :: PathBuf , features : &amp; <span class="prelude-ty">Option </span>&lt; Vec &lt; String &gt; &gt; , bin_name : &amp; str ,) -&gt; HydroflowCrate { <span class="kw">let </span><span class="kw-2">mut </span>ret = HydroflowCrate :: new (dir , trybuild . host) . target_dir (target_dir) . bin (bin_name) . no_default_features () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(display_name) = trybuild . display_name { ret = ret . display_name (display_name) ; } <span class="kw">else if let </span><span class="prelude-val">Some </span>(name_hint) = trybuild . name_hint { <span class="kw">if let </span><span class="prelude-val">Some </span>(cluster_idx) = trybuild . cluster_idx { ret = ret . display_name (format ! (<span class="string">"{} / {}" </span>, name_hint , cluster_idx)) ; } <span class="kw">else </span>{ ret = ret . display_name (name_hint) ; } } <span class="kw">if let </span><span class="prelude-val">Some </span>(rustflags) = trybuild . rustflags { ret = ret . rustflags (rustflags) ; } <span class="kw">if let </span><span class="prelude-val">Some </span>(tracing) = trybuild . tracing { ret = ret . tracing (tracing) ; } <span class="kw">if let </span><span class="prelude-val">Some </span>(features) = features { ret = ret . features (features . clone ()) ; } ret } } # [cfg (feature = <span class="string">"deploy"</span>)] <span class="kw">pub use </span>deploy_graph :: * ; <span class="kw">pub mod </span>in_memory_graph { <span class="kw">pub use </span>dfir_lang :: graph :: DfirGraph ; <span class="kw">pub use super </span>:: { LocalDeploy , Node , ProcessSpec } ; <span class="kw">pub use crate </span>:: deploy :: in_memory_graph :: SingleProcessGraph ; # [cfg (stageleft_macro)] <span class="kw">impl </span>LocalDeploy &lt; <span class="lifetime">'_ </span>&gt; <span class="kw">for </span>SingleProcessGraph { <span class="kw">type </span>Process = SingleNode ; <span class="kw">type </span>Cluster = SingleNode ; <span class="kw">type </span>ExternalProcess = SingleNode ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = () ; <span class="kw">fn </span>has_trivial_node () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>trivial_process (_id : usize) -&gt; <span class="self">Self </span>:: Process { SingleNode { } } <span class="kw">fn </span>trivial_cluster (_id : usize) -&gt; <span class="self">Self </span>:: Cluster { SingleNode { } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'_ </span>, SingleProcessGraph &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; SingleNode { SingleNode { } } } <span class="kw">pub use crate </span>:: deploy :: in_memory_graph :: SingleNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>SingleNode { <span class="kw">type </span>Port = () ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>InstantiateEnv = () ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) { panic ! () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, _env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , _graph : DfirGraph , _extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { } } <span class="kw">pub use crate </span>:: deploy :: in_memory_graph :: MultiGraph ; # [cfg (stageleft_macro)] <span class="kw">impl </span>LocalDeploy &lt; <span class="lifetime">'_ </span>&gt; <span class="kw">for </span>MultiGraph { <span class="kw">type </span>Process = MultiNode ; <span class="kw">type </span>Cluster = MultiNode ; <span class="kw">type </span>ExternalProcess = MultiNode ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = usize ; <span class="kw">fn </span>has_trivial_node () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>trivial_process (_id : usize) -&gt; <span class="self">Self </span>:: Process { MultiNode { } } <span class="kw">fn </span>trivial_cluster (_id : usize) -&gt; <span class="self">Self </span>:: Cluster { MultiNode { } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'_ </span>, MultiGraph &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; MultiNode { MultiNode { } } } <span class="kw">pub use crate </span>:: deploy :: in_memory_graph :: MultiNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>MultiNode { <span class="kw">type </span>Port = () ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>InstantiateEnv = () ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) { panic ! () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, _env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , _graph : DfirGraph , _extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { } } } <span class="kw">pub use </span>in_memory_graph :: * ; <span class="kw">pub use crate </span>:: deploy :: LocalDeploy ; <span class="kw">pub use crate </span>:: deploy :: Deploy ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Deploy &lt; <span class="lifetime">'a </span>, Process = N , Cluster = C , ExternalProcess = E , Meta = M , GraphId = R &gt; , N : Node &lt; Meta = M &gt; , C : Node &lt; Meta = M &gt; , E : Node &lt; Meta = M &gt; , M : Default , R , &gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>T { <span class="kw">type </span>Process = N ; <span class="kw">type </span>Cluster = C ; <span class="kw">type </span>ExternalProcess = E ; <span class="kw">type </span>Meta = M ; <span class="kw">type </span>GraphId = R ; <span class="kw">fn </span>has_trivial_node () -&gt; bool { &lt; T <span class="kw">as </span>Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; :: has_trivial_node () } <span class="kw">fn </span>trivial_process (id : usize) -&gt; <span class="self">Self </span>:: Process { &lt; T <span class="kw">as </span>Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; :: trivial_process (id) } <span class="kw">fn </span>trivial_cluster (id : usize) -&gt; <span class="self">Self </span>:: Cluster { &lt; T <span class="kw">as </span>Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; :: trivial_cluster (id) } } <span class="kw">pub use crate </span>:: deploy :: ProcessSpec ; <span class="kw">pub use crate </span>:: deploy :: IntoProcessSpec ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; + <span class="question-mark">? </span>Sized , T : ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; &gt; IntoProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; <span class="kw">for </span>T { <span class="kw">type </span>ProcessSpec = T ; <span class="kw">fn </span>into_process_spec (<span class="self">self</span>) -&gt; <span class="self">Self </span>:: ProcessSpec { <span class="self">self </span>} } <span class="kw">pub use crate </span>:: deploy :: ClusterSpec ; <span class="kw">pub use crate </span>:: deploy :: ExternalSpec ; <span class="kw">pub use crate </span>:: deploy :: Node ; <span class="kw">pub use crate </span>:: deploy :: RegisterPort ; } <span class="kw">pub mod </span>deploy_runtime { <span class="kw">pub use </span>std :: collections :: HashMap ; <span class="kw">pub use </span>dfir_rs :: util :: deploy :: { ConnectedDemux , ConnectedDirect , ConnectedSink , ConnectedSource , ConnectedTagged , DeployPorts , } ; <span class="kw">pub use </span>serde :: { Deserialize , Serialize } ; <span class="kw">pub use </span>stageleft :: { q , QuotedWithContext , RuntimeData } ; <span class="kw">pub use crate </span>:: deploy_runtime :: HydroflowPlusMeta ; <span class="kw">pub fn </span>cluster_members (cli : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , of_cluster : usize ,) -&gt; <span class="kw">impl </span>QuotedWithContext &lt; &amp; Vec &lt; u32 &gt; , () &gt; + Copy { q ! (cli . meta . clusters . get (&amp; of_cluster) . unwrap ()) } <span class="kw">pub fn </span>cluster_self_id (cli : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; ,) -&gt; <span class="kw">impl </span>QuotedWithContext &lt; u32 , () &gt; + Copy { q ! (cli . meta . cluster_id . expect (<span class="string">"Tried to read Cluster ID on a non-cluster node"</span>)) } <span class="kw">pub fn </span>deploy_o2o (env : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , p1_port : &amp; str , p2_port : &amp; str ,) -&gt; (syn :: Expr , syn :: Expr) { ({ q ! ({ env . port (p1_port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_sink () }) . splice_untyped_ctx (&amp; ()) } , { q ! ({ env . port (p2_port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_source () }) . splice_untyped_ctx (&amp; ()) } ,) } <span class="kw">pub fn </span>deploy_o2m (env : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , p1_port : &amp; str , c2_port : &amp; str ,) -&gt; (syn :: Expr , syn :: Expr) { ({ q ! ({ env . port (p1_port) . connect_local_blocking ::&lt; ConnectedDemux &lt; ConnectedDirect &gt;&gt; () . into_sink () }) . splice_untyped_ctx (&amp; ()) } , { q ! ({ env . port (c2_port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_source () }) . splice_untyped_ctx (&amp; ()) } ,) } <span class="kw">pub fn </span>deploy_m2o (env : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , c1_port : &amp; str , p2_port : &amp; str ,) -&gt; (syn :: Expr , syn :: Expr) { ({ q ! ({ env . port (c1_port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_sink () }) . splice_untyped_ctx (&amp; ()) } , { q ! ({ env . port (p2_port) . connect_local_blocking ::&lt; ConnectedTagged &lt; ConnectedDirect &gt;&gt; () . into_source () }) . splice_untyped_ctx (&amp; ()) } ,) } <span class="kw">pub fn </span>deploy_m2m (env : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , c1_port : &amp; str , c2_port : &amp; str ,) -&gt; (syn :: Expr , syn :: Expr) { ({ q ! ({ env . port (c1_port) . connect_local_blocking ::&lt; ConnectedDemux &lt; ConnectedDirect &gt;&gt; () . into_sink () }) . splice_untyped_ctx (&amp; ()) } , { q ! ({ env . port (c2_port) . connect_local_blocking ::&lt; ConnectedTagged &lt; ConnectedDirect &gt;&gt; () . into_source () }) . splice_untyped_ctx (&amp; ()) } ,) } <span class="kw">pub fn </span>deploy_e2o (env : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , _e1_port : &amp; str , p2_port : &amp; str ,) -&gt; syn :: Expr { q ! ({ env . port (p2_port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_source () }) . splice_untyped_ctx (&amp; ()) } <span class="kw">pub fn </span>deploy_o2e (env : RuntimeData &lt; &amp; DeployPorts &lt; HydroflowPlusMeta &gt; &gt; , p1_port : &amp; str , _e2_port : &amp; str ,) -&gt; syn :: Expr { q ! ({ env . port (p1_port) . connect_local_blocking ::&lt; ConnectedDirect &gt; () . into_sink () }) . splice_untyped_ctx (&amp; ()) } } <span class="kw">pub mod </span>cycle { <span class="kw">pub use crate </span>:: __staged :: location :: { Location , LocationId } ; <span class="kw">pub use crate </span>:: __staged :: staging_util :: Invariant ; <span class="kw">pub use crate </span>:: cycle :: ForwardRefMarker ; <span class="kw">pub use crate </span>:: cycle :: TickCycleMarker ; <span class="kw">pub use crate </span>:: cycle :: DeferTick ; <span class="kw">pub use crate </span>:: cycle :: CycleComplete ; <span class="kw">pub use crate </span>:: cycle :: CycleCollection ; <span class="kw">pub use crate </span>:: cycle :: CycleCollectionWithInitial ; <span class="kw">pub use crate </span>:: cycle :: ForwardRef ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, S : CycleComplete &lt; <span class="lifetime">'a </span>, ForwardRefMarker &gt; &gt; ForwardRef &lt; <span class="lifetime">'a </span>, S &gt; { <span class="kw">pub fn </span>complete (<span class="self">self </span>, stream : S) { <span class="kw">let </span>ident = <span class="self">self </span>. ident ; S :: complete (stream , ident , <span class="self">self </span>. expected_location) } } <span class="kw">pub use crate </span>:: cycle :: TickCycle ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, S : CycleComplete &lt; <span class="lifetime">'a </span>, TickCycleMarker &gt; + DeferTick &gt; TickCycle &lt; <span class="lifetime">'a </span>, S &gt; { <span class="kw">pub fn </span>complete_next_tick (<span class="self">self </span>, stream : S) { <span class="kw">let </span>ident = <span class="self">self </span>. ident ; S :: complete (stream . defer_tick () , ident , <span class="self">self </span>. expected_location) } } } <span class="kw">pub mod </span>builder { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: HashMap ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: rc :: Rc ; # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub use </span>compiled :: CompiledFlow ; # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub use </span>deploy :: { DeployFlow , DeployResult } ; <span class="kw">pub use </span>stageleft :: * ; # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub use crate </span>:: __staged :: deploy :: { ClusterSpec , Deploy , ExternalSpec , IntoProcessSpec , LocalDeploy } ; <span class="kw">pub use crate </span>:: __staged :: ir :: HydroLeaf ; <span class="kw">pub use crate </span>:: __staged :: location :: { Cluster , ExternalProcess , Process } ; <span class="kw">pub use crate </span>:: __staged :: staging_util :: Invariant ; # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub mod </span>built { <span class="kw">pub use </span>std :: collections :: { BTreeMap , HashMap } ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>dfir_lang :: graph :: { eliminate_extra_unions_tees , DfirGraph } ; <span class="kw">pub use super </span>:: compiled :: CompiledFlow ; <span class="kw">pub use super </span>:: deploy :: { DeployFlow , DeployResult } ; <span class="kw">pub use crate </span>:: __staged :: deploy :: { ClusterSpec , Deploy , ExternalSpec , IntoProcessSpec , LocalDeploy } ; <span class="kw">pub use crate </span>:: __staged :: ir :: HydroLeaf ; <span class="kw">pub use crate </span>:: __staged :: location :: { Cluster , ExternalProcess , Process } ; <span class="kw">pub use crate </span>:: __staged :: staging_util :: Invariant ; <span class="kw">pub use crate </span>:: builder :: built :: BuiltFlow ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Drop <span class="kw">for </span>BuiltFlow &lt; <span class="lifetime">'_ </span>&gt; { <span class="kw">fn </span>drop (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { <span class="kw">if </span>! <span class="self">self </span>. used { panic ! (<span class="string">"Dropped BuiltFlow without instantiating, you may have forgotten to call `compile` or `deploy`."</span>) ; } } } <span class="kw">pub fn </span>build_inner (ir : &amp; <span class="kw-2">mut </span>Vec &lt; HydroLeaf &gt;) -&gt; BTreeMap &lt; usize , DfirGraph &gt; { <span class="kw">let </span><span class="kw-2">mut </span>builders = BTreeMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>built_tees = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>next_stmt_id = <span class="number">0 </span>; <span class="kw">for </span>leaf <span class="kw">in </span>ir { leaf . emit (&amp; <span class="kw-2">mut </span>builders , &amp; <span class="kw-2">mut </span>built_tees , &amp; <span class="kw-2">mut </span>next_stmt_id) ; } builders . into_iter () . map (| (k , v) | { <span class="kw">let </span>(<span class="kw-2">mut </span>flat_graph , <span class="kw">_ </span>, <span class="kw">_</span>) = v . build () ; eliminate_extra_unions_tees (&amp; <span class="kw-2">mut </span>flat_graph) ; (k , flat_graph) }) . collect () } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">pub fn </span>ir (&amp; <span class="self">self</span>) -&gt; &amp; Vec &lt; HydroLeaf &gt; { &amp; <span class="self">self </span>. ir } <span class="kw">pub fn </span>optimize_with (<span class="kw-2">mut </span><span class="self">self </span>, f : <span class="kw">impl </span>FnOnce (Vec &lt; HydroLeaf &gt;) -&gt; Vec &lt; HydroLeaf &gt;) -&gt; <span class="self">Self </span>{ <span class="self">self </span>. used = <span class="bool-val">true </span>; BuiltFlow { ir : f (std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir)) , processes : std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. processes) , clusters : std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. clusters) , used : <span class="bool-val">false </span>, _phantom : PhantomData , } } <span class="kw">pub fn </span>with_default_optimize &lt; D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self</span>) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. optimize_with (<span class="kw">crate </span>:: rewrites :: persist_pullup :: persist_pullup) . into_deploy () } <span class="kw">fn </span>into_deploy &lt; D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="kw-2">mut </span><span class="self">self</span>) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; <span class="kw">let </span>processes = <span class="kw">if </span>D :: has_trivial_node () { <span class="self">self </span>. processes . iter () . map (| id | (* id , D :: trivial_process (* id))) . collect () } <span class="kw">else </span>{ HashMap :: new () } ; <span class="kw">let </span>clusters = <span class="kw">if </span>D :: has_trivial_node () { <span class="self">self </span>. clusters . iter () . map (| id | (* id , D :: trivial_cluster (* id))) . collect () } <span class="kw">else </span>{ HashMap :: new () } ; DeployFlow { ir : std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir) , nodes : processes , clusters , externals : HashMap :: new () , used : <span class="bool-val">false </span>, _phantom : PhantomData , } } <span class="kw">pub fn </span>with_process &lt; P , D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, process : &amp; Process &lt; P &gt; , spec : <span class="kw">impl </span>IntoProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. into_deploy () . with_process (process , spec) } <span class="kw">pub fn </span>with_external &lt; P , D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, process : &amp; ExternalProcess &lt; P &gt; , spec : <span class="kw">impl </span>ExternalSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. into_deploy () . with_external (process , spec) } <span class="kw">pub fn </span>with_cluster &lt; C , D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, cluster : &amp; Cluster &lt; C &gt; , spec : <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. into_deploy () . with_cluster (cluster , spec) } <span class="kw">pub fn </span>compile &lt; D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, env : &amp; D :: CompileEnv) -&gt; CompiledFlow &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. into_deploy :: &lt; D &gt; () . compile (env) } <span class="kw">pub fn </span>compile_no_network &lt; D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self</span>) -&gt; CompiledFlow &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. into_deploy :: &lt; D &gt; () . compile_no_network () } <span class="kw">pub fn </span>deploy &lt; D : Deploy &lt; <span class="lifetime">'a </span>, CompileEnv = () &gt; &gt; (<span class="self">self </span>, env : &amp; <span class="kw-2">mut </span>D :: InstantiateEnv ,) -&gt; DeployResult &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. into_deploy :: &lt; D &gt; () . deploy (env) } } } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub mod </span>compiled { <span class="kw">pub use </span>std :: collections :: BTreeMap ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>dfir_lang :: graph :: { partition_graph , DfirGraph } ; <span class="kw">pub use </span>dfir_rs :: scheduled :: graph :: Dfir ; <span class="kw">pub use </span>proc_macro2 :: TokenStream ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>stageleft :: runtime_support :: FreeVariableWithContext ; <span class="kw">pub use </span>stageleft :: QuotedWithContext ; <span class="kw">pub use crate </span>:: __staged :: staging_util :: Invariant ; <span class="kw">pub use crate </span>:: builder :: compiled :: CompiledFlow ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; ID &gt; CompiledFlow &lt; <span class="lifetime">'_ </span>, ID &gt; { <span class="kw">pub fn </span>hydroflow_ir (&amp; <span class="self">self</span>) -&gt; &amp; BTreeMap &lt; usize , DfirGraph &gt; { &amp; <span class="self">self </span>. hydroflow_ir } <span class="kw">pub fn </span>take_ir (<span class="self">self</span>) -&gt; BTreeMap &lt; usize , DfirGraph &gt; { <span class="self">self </span>. hydroflow_ir } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; CompiledFlow &lt; <span class="lifetime">'a </span>, usize &gt; { <span class="kw">pub fn </span>with_dynamic_id (<span class="self">self </span>, id : <span class="kw">impl </span>QuotedWithContext &lt; <span class="lifetime">'a </span>, usize , () &gt; ,) -&gt; CompiledFlowWithId &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydro_lang"</span>) . expect (<span class="string">"hydro_lang should be present in `Cargo.toml`"</span>) ; <span class="kw">let </span>root = <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydro_lang :: dfir_rs } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , proc_macro2 :: Span :: call_site ()) ; quote ! { # ident :: dfir_rs } } } ; <span class="kw">let </span><span class="kw-2">mut </span>conditioned_tokens = <span class="prelude-val">None </span>; <span class="kw">for </span>(subgraph_id , flat_graph) <span class="kw">in </span><span class="self">self </span>. hydroflow_ir { <span class="kw">let </span>partitioned_graph = partition_graph (flat_graph) . expect (<span class="string">"Failed to partition (cycle detected)."</span>) ; <span class="kw">let </span><span class="kw-2">mut </span>diagnostics = Vec :: new () ; <span class="kw">let </span>tokens = partitioned_graph . as_code (&amp; root , <span class="bool-val">true </span>, quote :: quote ! () , &amp; <span class="kw-2">mut </span>diagnostics) ; <span class="kw">let </span>my_extra_stmts = <span class="self">self </span>. extra_stmts . get (&amp; subgraph_id) . cloned () . unwrap_or_default () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(conditioned_tokens) = conditioned_tokens . as_mut () { * conditioned_tokens = syn :: parse_quote ! { # conditioned_tokens <span class="kw">else if </span>__given_id == # subgraph_id { # (# my_extra_stmts) * # tokens } } ; } <span class="kw">else </span>{ conditioned_tokens = <span class="prelude-val">Some </span>(syn :: parse_quote ! { <span class="kw">if </span>__given_id == # subgraph_id { # (# my_extra_stmts) * # tokens } }) ; } } <span class="kw">let </span>conditioned_tokens : TokenStream = conditioned_tokens . unwrap () ; <span class="kw">let </span>id = id . splice_untyped () ; CompiledFlowWithId { tokens : syn :: parse_quote ! ({ <span class="kw">let </span>__given_id = # id ; # conditioned_tokens <span class="kw">else </span>{ panic ! (<span class="string">"Invalid node id: {}" </span>, __given_id) ; } }) , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, Ctx &gt; QuotedWithContext &lt; <span class="lifetime">'a </span>, Dfir &lt; <span class="lifetime">'a </span>&gt; , Ctx &gt; <span class="kw">for </span>CompiledFlow &lt; <span class="lifetime">'a </span>, () &gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, Ctx &gt; FreeVariableWithContext &lt; Ctx &gt; <span class="kw">for </span>CompiledFlow &lt; <span class="lifetime">'a </span>, () &gt; { <span class="kw">type </span>O = Dfir &lt; <span class="lifetime">'a </span>&gt; ; <span class="kw">fn </span>to_tokens (<span class="kw-2">mut </span><span class="self">self </span>, _ctx : &amp; Ctx) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydro_lang"</span>) . expect (<span class="string">"hydro_lang should be present in `Cargo.toml`"</span>) ; <span class="kw">let </span>root = <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydro_lang :: dfir_rs } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , proc_macro2 :: Span :: call_site ()) ; quote ! { # ident :: dfir_rs } } } ; <span class="kw">if </span><span class="self">self </span>. hydroflow_ir . len () != <span class="number">1 </span>{ panic ! (<span class="string">"Expected exactly one subgraph in the Hydroflow IR"</span>) ; } <span class="kw">let </span>flat_graph = <span class="self">self </span>. hydroflow_ir . remove (&amp; <span class="number">0</span>) . unwrap () ; <span class="kw">let </span>partitioned_graph = partition_graph (flat_graph) . expect (<span class="string">"Failed to partition (cycle detected)."</span>) ; <span class="kw">let </span><span class="kw-2">mut </span>diagnostics = Vec :: new () ; <span class="kw">let </span>tokens = partitioned_graph . as_code (&amp; root , <span class="bool-val">true </span>, quote :: quote ! () , &amp; <span class="kw-2">mut </span>diagnostics) ; (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(tokens)) } } <span class="kw">pub use crate </span>:: builder :: compiled :: CompiledFlowWithId ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, Ctx &gt; QuotedWithContext &lt; <span class="lifetime">'a </span>, Dfir &lt; <span class="lifetime">'a </span>&gt; , Ctx &gt; <span class="kw">for </span>CompiledFlowWithId &lt; <span class="lifetime">'a </span>&gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, Ctx &gt; FreeVariableWithContext &lt; Ctx &gt; <span class="kw">for </span>CompiledFlowWithId &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">type </span>O = Dfir &lt; <span class="lifetime">'a </span>&gt; ; <span class="kw">fn </span>to_tokens (<span class="self">self </span>, _ctx : &amp; Ctx) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(<span class="self">self </span>. tokens)) } } } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub mod </span>deploy { <span class="kw">pub use </span>std :: collections :: { BTreeMap , HashMap } ; <span class="kw">pub use </span>std :: io :: Error ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: pin :: Pin ; <span class="kw">pub use </span>dfir_rs :: bytes :: Bytes ; <span class="kw">pub use </span>dfir_rs :: futures :: { Sink , Stream } ; <span class="kw">pub use </span>proc_macro2 :: Span ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use </span>stageleft :: QuotedWithContext ; <span class="kw">pub use super </span>:: built :: build_inner ; <span class="kw">pub use super </span>:: compiled :: CompiledFlow ; <span class="kw">pub use crate </span>:: __staged :: deploy :: { ClusterSpec , Deploy , ExternalSpec , IntoProcessSpec , LocalDeploy , Node , ProcessSpec , RegisterPort , } ; <span class="kw">pub use crate </span>:: __staged :: ir :: HydroLeaf ; <span class="kw">pub use crate </span>:: __staged :: location :: external_process :: { ExternalBincodeSink , ExternalBincodeStream , ExternalBytesPort , } ; <span class="kw">pub use crate </span>:: __staged :: location :: { Cluster , ExternalProcess , Location , LocationId , Process } ; <span class="kw">pub use crate </span>:: __staged :: staging_util :: Invariant ; <span class="kw">pub use crate </span>:: builder :: deploy :: DeployFlow ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; Drop <span class="kw">for </span>DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">fn </span>drop (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { <span class="kw">if </span>! <span class="self">self </span>. used { panic ! (<span class="string">"Dropped DeployFlow without instantiating, you may have forgotten to call `compile` or `deploy`."</span>) ; } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>ir (&amp; <span class="self">self</span>) -&gt; &amp; Vec &lt; HydroLeaf &gt; { &amp; <span class="self">self </span>. ir } <span class="kw">pub fn </span>with_process &lt; P &gt; (<span class="kw-2">mut </span><span class="self">self </span>, process : &amp; Process &lt; P &gt; , spec : <span class="kw">impl </span>IntoProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>tag_name = std :: any :: type_name :: &lt; P &gt; () . to_string () ; <span class="self">self </span>. nodes . insert (process . id , spec . into_process_spec () . build (process . id , &amp; tag_name) ,) ; <span class="self">self </span>} <span class="kw">pub fn </span>with_external &lt; P &gt; (<span class="kw-2">mut </span><span class="self">self </span>, process : &amp; ExternalProcess &lt; P &gt; , spec : <span class="kw">impl </span>ExternalSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>tag_name = std :: any :: type_name :: &lt; P &gt; () . to_string () ; <span class="self">self </span>. externals . insert (process . id , spec . build (process . id , &amp; tag_name)) ; <span class="self">self </span>} <span class="kw">pub fn </span>with_cluster &lt; C &gt; (<span class="kw-2">mut </span><span class="self">self </span>, cluster : &amp; Cluster &lt; C &gt; , spec : <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>tag_name = std :: any :: type_name :: &lt; C &gt; () . to_string () ; <span class="self">self </span>. clusters . insert (cluster . id , spec . build (cluster . id , &amp; tag_name)) ; <span class="self">self </span>} <span class="kw">pub fn </span>compile_no_network (<span class="kw-2">mut </span><span class="self">self</span>) -&gt; CompiledFlow &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; CompiledFlow { hydroflow_ir : build_inner (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir) , extra_stmts : BTreeMap :: new () , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>compile (<span class="kw-2">mut </span><span class="self">self </span>, env : &amp; D :: CompileEnv) -&gt; CompiledFlow &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; <span class="kw">let </span><span class="kw-2">mut </span>seen_tees : HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>flow_state_networked : Vec &lt; HydroLeaf &gt; = std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir) . into_iter () . map (| leaf | { leaf . compile_network :: &lt; D &gt; (env , &amp; <span class="kw-2">mut </span>seen_tees , &amp; <span class="self">self </span>. nodes , &amp; <span class="self">self </span>. clusters , &amp; <span class="self">self </span>. externals ,) }) . collect () ; <span class="kw">let </span>extra_stmts = <span class="self">self </span>. extra_stmts (env) ; CompiledFlow { hydroflow_ir : build_inner (&amp; <span class="kw-2">mut </span>flow_state_networked) , extra_stmts , _phantom : PhantomData , } } <span class="kw">fn </span>extra_stmts (&amp; <span class="self">self </span>, env : &amp; &lt; D <span class="kw">as </span>Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; :: CompileEnv) -&gt; BTreeMap &lt; usize , Vec &lt; syn :: Stmt &gt; &gt; { <span class="kw">let </span>all_locations_count = <span class="self">self </span>. nodes . len () + <span class="self">self </span>. clusters . len () ; <span class="kw">let </span><span class="kw-2">mut </span>extra_stmts : BTreeMap &lt; usize , Vec &lt; syn :: Stmt &gt; &gt; = BTreeMap :: new () ; <span class="kw">for </span>&amp; c_id <span class="kw">in </span><span class="self">self </span>. clusters . keys () { <span class="kw">let </span>self_id_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"__hydro_lang_cluster_self_id_{}" </span>, c_id) , Span :: call_site () ,) ; <span class="kw">let </span>self_id_expr = D :: cluster_self_id (env) . splice_untyped () ; extra_stmts . entry (c_id) . or_default () . push (syn :: parse_quote ! { <span class="kw">let </span># self_id_ident = # self_id_expr ; }) ; <span class="kw">for </span>other_location <span class="kw">in </span><span class="number">0 </span>.. all_locations_count { <span class="kw">let </span>other_id_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"__hydro_lang_cluster_ids_{}" </span>, c_id) , Span :: call_site () ,) ; <span class="kw">let </span>other_id_expr = D :: cluster_ids (env , c_id) . splice_untyped () ; extra_stmts . entry (other_location) . or_default () . push (syn :: parse_quote ! { <span class="kw">let </span># other_id_ident = # other_id_expr ; }) ; } } extra_stmts } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>, CompileEnv = () &gt; &gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { # [must_use] <span class="kw">pub fn </span>deploy (<span class="kw-2">mut </span><span class="self">self </span>, env : &amp; <span class="kw-2">mut </span>D :: InstantiateEnv) -&gt; DeployResult &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; <span class="kw">let </span><span class="kw-2">mut </span>seen_tees_instantiate : HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>flow_state_networked : Vec &lt; HydroLeaf &gt; = std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir) . into_iter () . map (| leaf | { leaf . compile_network :: &lt; D &gt; (&amp; () , &amp; <span class="kw-2">mut </span>seen_tees_instantiate , &amp; <span class="self">self </span>. nodes , &amp; <span class="self">self </span>. clusters , &amp; <span class="self">self </span>. externals ,) }) . collect () ; <span class="kw">let </span><span class="kw-2">mut </span>compiled = build_inner (&amp; <span class="kw-2">mut </span>flow_state_networked) ; <span class="kw">let </span><span class="kw-2">mut </span>extra_stmts = <span class="self">self </span>. extra_stmts (&amp; ()) ; <span class="kw">let </span><span class="kw-2">mut </span>meta = D :: Meta :: default () ; <span class="kw">let </span>(<span class="kw-2">mut </span>processes , <span class="kw-2">mut </span>clusters , <span class="kw-2">mut </span>externals) = (std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. nodes) . into_iter () . map (| (node_id , node) | { node . instantiate (env , &amp; <span class="kw-2">mut </span>meta , compiled . remove (&amp; node_id) . unwrap () , extra_stmts . remove (&amp; node_id) . unwrap_or_default () ,) ; (node_id , node) }) . collect :: &lt; HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; &gt; () , std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. clusters) . into_iter () . map (| (cluster_id , cluster) | { cluster . instantiate (env , &amp; <span class="kw-2">mut </span>meta , compiled . remove (&amp; cluster_id) . unwrap () , extra_stmts . remove (&amp; cluster_id) . unwrap_or_default () ,) ; (cluster_id , cluster) }) . collect :: &lt; HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; &gt; () , std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. externals) . into_iter () . map (| (external_id , external) | { external . instantiate (env , &amp; <span class="kw-2">mut </span>meta , compiled . remove (&amp; external_id) . unwrap () , extra_stmts . remove (&amp; external_id) . unwrap_or_default () ,) ; (external_id , external) }) . collect :: &lt; HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; &gt; () ,) ; <span class="kw">for </span>node <span class="kw">in </span>processes . values_mut () { node . update_meta (&amp; meta) ; } <span class="kw">for </span>cluster <span class="kw">in </span>clusters . values_mut () { cluster . update_meta (&amp; meta) ; } <span class="kw">for </span>external <span class="kw">in </span>externals . values_mut () { external . update_meta (&amp; meta) ; } <span class="kw">let </span><span class="kw-2">mut </span>seen_tees_connect = HashMap :: new () ; <span class="kw">for </span>leaf <span class="kw">in </span>flow_state_networked { leaf . connect_network (&amp; <span class="kw-2">mut </span>seen_tees_connect) ; } DeployResult { processes , clusters , externals , } } } <span class="kw">pub use crate </span>:: builder :: deploy :: DeployResult ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; DeployResult &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>get_process &lt; P &gt; (&amp; <span class="self">self </span>, p : &amp; Process &lt; P &gt;) -&gt; &amp; D :: Process { <span class="kw">let </span>id = <span class="kw">match </span>p . id () { LocationId :: Process (id) =&gt; id , <span class="kw">_ </span>=&gt; panic ! (<span class="string">"Process ID expected"</span>) , } ; <span class="self">self </span>. processes . get (&amp; id) . unwrap () } <span class="kw">pub fn </span>get_cluster &lt; C &gt; (&amp; <span class="self">self </span>, c : &amp; Cluster &lt; <span class="lifetime">'a </span>, C &gt;) -&gt; &amp; D :: Cluster { <span class="kw">let </span>id = <span class="kw">match </span>c . id () { LocationId :: Cluster (id) =&gt; id , <span class="kw">_ </span>=&gt; panic ! (<span class="string">"Cluster ID expected"</span>) , } ; <span class="self">self </span>. clusters . get (&amp; id) . unwrap () } <span class="kw">pub fn </span>get_external &lt; P &gt; (&amp; <span class="self">self </span>, p : &amp; ExternalProcess &lt; P &gt;) -&gt; &amp; D :: ExternalProcess { <span class="self">self </span>. externals . get (&amp; p . id) . unwrap () } <span class="kw">pub fn </span>raw_port (&amp; <span class="self">self </span>, port : ExternalBytesPort) -&gt; D :: ExternalRawPort { <span class="self">self </span>. externals . get (&amp; port . process_id) . unwrap () . raw_port (port . port_id) } <span class="kw">pub async fn </span>connect_sink_bytes (&amp; <span class="self">self </span>, port : ExternalBytesPort ,) -&gt; Pin &lt; Box &lt; <span class="kw">dyn </span>Sink &lt; Bytes , Error = Error &gt; &gt; &gt; { <span class="self">self </span>. externals . get (&amp; port . process_id) . unwrap () . as_bytes_sink (port . port_id) . <span class="kw">await </span>} <span class="kw">pub async fn </span>connect_sink_bincode &lt; T : Serialize + DeserializeOwned + <span class="lifetime">'static </span>&gt; (&amp; <span class="self">self </span>, port : ExternalBincodeSink &lt; T &gt; ,) -&gt; Pin &lt; Box &lt; <span class="kw">dyn </span>Sink &lt; T , Error = Error &gt; &gt; &gt; { <span class="self">self </span>. externals . get (&amp; port . process_id) . unwrap () . as_bincode_sink (port . port_id) . <span class="kw">await </span>} <span class="kw">pub async fn </span>connect_source_bytes (&amp; <span class="self">self </span>, port : ExternalBytesPort ,) -&gt; Pin &lt; Box &lt; <span class="kw">dyn </span>Stream &lt; Item = Bytes &gt; &gt; &gt; { <span class="self">self </span>. externals . get (&amp; port . process_id) . unwrap () . as_bytes_source (port . port_id) . <span class="kw">await </span>} <span class="kw">pub async fn </span>connect_source_bincode &lt; T : Serialize + DeserializeOwned + <span class="lifetime">'static </span>&gt; (&amp; <span class="self">self </span>, port : ExternalBincodeStream &lt; T &gt; ,) -&gt; Pin &lt; Box &lt; <span class="kw">dyn </span>Stream &lt; Item = T &gt; &gt; &gt; { <span class="self">self </span>. externals . get (&amp; port . process_id) . unwrap () . as_bincode_source (port . port_id) . <span class="kw">await </span>} } } <span class="kw">pub use crate </span>:: builder :: FlowStateInner ; <span class="kw">pub type </span>FlowState = Rc &lt; RefCell &lt; FlowStateInner &gt; &gt; ; <span class="kw">pub use crate </span>:: builder :: FLOW_USED_MESSAGE ; <span class="kw">pub use crate </span>:: builder :: FlowBuilder ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Drop <span class="kw">for </span>FlowBuilder &lt; <span class="lifetime">'_ </span>&gt; { <span class="kw">fn </span>drop (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { <span class="kw">if </span>! <span class="self">self </span>. finalized { panic ! (<span class="string">"Dropped FlowBuilder without finalizing, you may have forgotten to call `with_default_optimize`, `optimize_with`, or `finalize`."</span>) ; } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>QuotedContext <span class="kw">for </span>FlowBuilder &lt; <span class="lifetime">'_ </span>&gt; { <span class="kw">fn </span>create () -&gt; <span class="self">Self </span>{ FlowBuilder :: new () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FlowBuilder &lt; <span class="lifetime">'a </span>&gt; { # [expect (clippy :: new_without_default , reason = <span class="string">"call `new` explicitly, not `default`"</span>)] <span class="kw">pub fn </span>new () -&gt; FlowBuilder &lt; <span class="lifetime">'a </span>&gt; { FlowBuilder { flow_state : Rc :: new (RefCell :: new (FlowStateInner { leaves : <span class="prelude-val">Some </span>(vec ! []) , next_external_out : <span class="number">0 </span>, cycle_counts : HashMap :: new () , next_clock_id : <span class="number">0 </span>, })) , nodes : RefCell :: new (vec ! []) , clusters : RefCell :: new (vec ! []) , next_node_id : RefCell :: new (<span class="number">0</span>) , finalized : <span class="bool-val">false </span>, _phantom : PhantomData , } } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>finalize (<span class="kw-2">mut </span><span class="self">self</span>) -&gt; built :: BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. finalized = <span class="bool-val">true </span>; built :: BuiltFlow { ir : <span class="self">self </span>. flow_state . borrow_mut () . leaves . take () . unwrap () , processes : <span class="self">self </span>. nodes . replace (vec ! []) , clusters : <span class="self">self </span>. clusters . replace (vec ! []) , used : <span class="bool-val">false </span>, _phantom : PhantomData , } } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>with_default_optimize &lt; D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self</span>) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. finalize () . with_default_optimize () } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>optimize_with (<span class="self">self </span>, f : <span class="kw">impl </span>FnOnce (Vec &lt; HydroLeaf &gt;) -&gt; Vec &lt; HydroLeaf &gt; ,) -&gt; built :: BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. finalize () . optimize_with (f) } <span class="kw">pub fn </span>flow_state (&amp; <span class="self">self</span>) -&gt; &amp; FlowState { &amp; <span class="self">self </span>. flow_state } <span class="kw">pub fn </span>process &lt; P &gt; (&amp; <span class="self">self</span>) -&gt; Process &lt; <span class="lifetime">'a </span>, P &gt; { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="self">self </span>. nodes . borrow_mut () . push (id) ; Process { id , flow_state : <span class="self">self </span>. flow_state () . clone () , _phantom : PhantomData , } } <span class="kw">pub fn </span>external_process &lt; P &gt; (&amp; <span class="self">self</span>) -&gt; ExternalProcess &lt; <span class="lifetime">'a </span>, P &gt; { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="self">self </span>. nodes . borrow_mut () . push (id) ; ExternalProcess { id , flow_state : <span class="self">self </span>. flow_state () . clone () , _phantom : PhantomData , } } <span class="kw">pub fn </span>cluster &lt; C &gt; (&amp; <span class="self">self</span>) -&gt; Cluster &lt; <span class="lifetime">'a </span>, C &gt; { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="self">self </span>. clusters . borrow_mut () . push (id) ; Cluster { id , flow_state : <span class="self">self </span>. flow_state () . clone () , _phantom : PhantomData , } } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>with_process &lt; P , D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, process : &amp; Process &lt; P &gt; , spec : <span class="kw">impl </span>IntoProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. with_default_optimize () . with_process (process , spec) } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>with_external &lt; P , D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, process : &amp; ExternalProcess &lt; P &gt; , spec : <span class="kw">impl </span>ExternalSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. with_default_optimize () . with_external (process , spec) } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>with_cluster &lt; C , D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, cluster : &amp; Cluster &lt; C &gt; , spec : <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. with_default_optimize () . with_cluster (cluster , spec) } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>compile &lt; D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, env : &amp; D :: CompileEnv) -&gt; CompiledFlow &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. with_default_optimize :: &lt; D &gt; () . compile (env) } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>compile_no_network &lt; D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self</span>) -&gt; CompiledFlow &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. with_default_optimize :: &lt; D &gt; () . compile_no_network () } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>deploy &lt; D : Deploy &lt; <span class="lifetime">'a </span>, CompileEnv = () &gt; &gt; (<span class="self">self </span>, env : &amp; <span class="kw-2">mut </span>D :: InstantiateEnv ,) -&gt; DeployResult &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. with_default_optimize () . deploy (env) } } } <span class="kw">pub use </span>builder :: FlowBuilder ; <span class="kw">pub mod </span>ir { <span class="kw">pub use </span>core :: panic ; <span class="kw">pub use </span>std :: cell :: RefCell ; # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub use </span>std :: collections :: BTreeMap ; <span class="kw">pub use </span>std :: collections :: HashMap ; <span class="kw">pub use </span>std :: fmt :: Debug ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub use </span>dfir_lang :: graph :: FlatGraphBuilder ; # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub use </span>proc_macro2 :: Span ; <span class="kw">pub use </span>proc_macro2 :: TokenStream ; <span class="kw">pub use </span>quote :: ToTokens ; # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub use </span>syn :: parse_quote ; # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub use crate </span>:: __staged :: deploy :: { Deploy , RegisterPort } ; <span class="kw">pub use crate </span>:: __staged :: location :: LocationId ; <span class="kw">pub use crate </span>:: ir :: DebugExpr ; # [cfg (stageleft_macro)] <span class="kw">impl </span>From &lt; syn :: Expr &gt; <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>from (expr : syn :: Expr) -&gt; DebugExpr { DebugExpr (expr) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Deref <span class="kw">for </span>DebugExpr { <span class="kw">type </span>Target = syn :: Expr ; <span class="kw">fn </span>deref (&amp; <span class="self">self</span>) -&gt; &amp; <span class="self">Self </span>:: Target { &amp; <span class="self">self </span>. <span class="number">0 </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>ToTokens <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>to_tokens (&amp; <span class="self">self </span>, tokens : &amp; <span class="kw-2">mut </span>TokenStream) { <span class="self">self </span>. <span class="number">0 </span>. to_tokens (tokens) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Debug <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"{}" </span>, <span class="self">self </span>. <span class="number">0 </span>. to_token_stream ()) } } <span class="kw">pub use crate </span>:: ir :: DebugInstantiate ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Debug <span class="kw">for </span>DebugInstantiate { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"&lt;network instantiate&gt;"</span>) } } <span class="kw">pub use crate </span>:: ir :: HydroSource ; <span class="kw">pub use crate </span>:: ir :: HydroLeaf ; # [cfg (stageleft_macro)] <span class="kw">impl </span>HydroLeaf { # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>compile_network &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, compile_env : &amp; D :: CompileEnv , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees , nodes : &amp; HashMap &lt; usize , D :: Process &gt; , clusters : &amp; HashMap &lt; usize , D :: Cluster &gt; , externals : &amp; HashMap &lt; usize , D :: ExternalProcess &gt; ,) -&gt; HydroLeaf { <span class="self">self </span>. transform_children (| n , s | { n . compile_network :: &lt; D &gt; (compile_env , s , nodes , clusters , externals) ; } , seen_tees ,) } <span class="kw">pub fn </span>connect_network (<span class="self">self </span>, seen_tees : &amp; <span class="kw-2">mut </span>SeenTees) -&gt; HydroLeaf { <span class="self">self </span>. transform_children (| n , s | { n . connect_network (s) ; } , seen_tees ,) } <span class="kw">pub fn </span>transform_children (<span class="self">self </span>, <span class="kw-2">mut </span>transform : <span class="kw">impl </span>FnMut (&amp; <span class="kw-2">mut </span>HydroNode , &amp; <span class="kw-2">mut </span>SeenTees) , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees ,) -&gt; HydroLeaf { <span class="kw">match </span><span class="self">self </span>{ HydroLeaf :: ForEach { f , <span class="kw-2">mut </span>input } =&gt; { transform (&amp; <span class="kw-2">mut </span>input , seen_tees) ; HydroLeaf :: ForEach { f , input } } HydroLeaf :: DestSink { sink , <span class="kw-2">mut </span>input } =&gt; { transform (&amp; <span class="kw-2">mut </span>input , seen_tees) ; HydroLeaf :: DestSink { sink , input } } HydroLeaf :: CycleSink { ident , location_kind , <span class="kw-2">mut </span>input , } =&gt; { transform (&amp; <span class="kw-2">mut </span>input , seen_tees) ; HydroLeaf :: CycleSink { ident , location_kind , input , } } } } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>emit (&amp; <span class="self">self </span>, graph_builders : &amp; <span class="kw-2">mut </span>BTreeMap &lt; usize , FlatGraphBuilder &gt; , built_tees : &amp; <span class="kw-2">mut </span>HashMap &lt; * <span class="kw">const </span>RefCell &lt; HydroNode &gt; , (syn :: Ident , usize) &gt; , next_stmt_id : &amp; <span class="kw-2">mut </span>usize ,) { <span class="kw">match </span><span class="self">self </span>{ HydroLeaf :: ForEach { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; graph_builders . entry (input_location_id) . or_default () . add_statement (parse_quote ! { # input_ident -&gt; for_each (# f) ; }) ; } HydroLeaf :: DestSink { sink , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; graph_builders . entry (input_location_id) . or_default () . add_statement (parse_quote ! { # input_ident -&gt; dest_sink (# sink) ; }) ; } HydroLeaf :: CycleSink { ident , location_kind , input , } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>location_id = <span class="kw">match </span>location_kind . root () { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , LocationId :: Tick (<span class="kw">_ </span>, <span class="kw">_</span>) =&gt; panic ! () , LocationId :: ExternalProcess (<span class="kw">_</span>) =&gt; panic ! () , } ; assert_eq ! (input_location_id , * location_id , <span class="string">"cycle_sink location mismatch"</span>) ; graph_builders . entry (* location_id) . or_default () . add_statement (parse_quote ! { # ident = # input_ident ; }) ; } } } } <span class="kw">type </span>PrintedTees = RefCell &lt; <span class="prelude-ty">Option </span>&lt; (usize , HashMap &lt; * <span class="kw">const </span>RefCell &lt; HydroNode &gt; , usize &gt;) &gt; &gt; ; thread_local ! { <span class="kw">static </span>PRINTED_TEES : PrintedTees = <span class="kw">const </span>{ RefCell :: new (<span class="prelude-val">None</span>) } ; } <span class="kw">pub fn </span>dbg_dedup_tee &lt; T &gt; (f : <span class="kw">impl </span>FnOnce () -&gt; T) -&gt; T { PRINTED_TEES . with (| printed_tees | { <span class="kw">let </span><span class="kw-2">mut </span>printed_tees_mut = printed_tees . borrow_mut () ; * printed_tees_mut = <span class="prelude-val">Some </span>((<span class="number">0 </span>, HashMap :: new ())) ; drop (printed_tees_mut) ; <span class="kw">let </span>ret = f () ; <span class="kw">let </span><span class="kw-2">mut </span>printed_tees_mut = printed_tees . borrow_mut () ; * printed_tees_mut = <span class="prelude-val">None </span>; ret }) } <span class="kw">pub use crate </span>:: ir :: TeeNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Debug <span class="kw">for </span>TeeNode { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ PRINTED_TEES . with (| printed_tees | { <span class="kw">let </span><span class="kw-2">mut </span>printed_tees_mut_borrow = printed_tees . borrow_mut () ; <span class="kw">let </span>printed_tees_mut = printed_tees_mut_borrow . as_mut () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(printed_tees_mut) = printed_tees_mut { <span class="kw">if let </span><span class="prelude-val">Some </span>(existing) = printed_tees_mut . <span class="number">1 </span>. get (&amp; (<span class="self">self </span>. <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HydroNode &gt;)) { write ! (f , <span class="string">"&lt;tee {}&gt;" </span>, existing) } <span class="kw">else </span>{ <span class="kw">let </span>next_id = printed_tees_mut . <span class="number">0 </span>; printed_tees_mut . <span class="number">0 </span>+= <span class="number">1 </span>; printed_tees_mut . <span class="number">1 </span>. insert (<span class="self">self </span>. <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HydroNode &gt; , next_id) ; drop (printed_tees_mut_borrow) ; write ! (f , <span class="string">"&lt;tee {}&gt;: " </span>, next_id) <span class="question-mark">? </span>; Debug :: fmt (&amp; <span class="self">self </span>. <span class="number">0 </span>. borrow () , f) } } <span class="kw">else </span>{ drop (printed_tees_mut_borrow) ; write ! (f , <span class="string">"&lt;tee&gt;: "</span>) <span class="question-mark">? </span>; Debug :: fmt (&amp; <span class="self">self </span>. <span class="number">0 </span>. borrow () , f) } }) } } <span class="kw">pub use crate </span>:: ir :: HydroNode ; <span class="kw">pub type </span>SeenTees = HashMap &lt; * <span class="kw">const </span>RefCell &lt; HydroNode &gt; , Rc &lt; RefCell &lt; HydroNode &gt; &gt; &gt; ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; HydroNode { # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>compile_network &lt; D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (&amp; <span class="kw-2">mut </span><span class="self">self </span>, compile_env : &amp; D :: CompileEnv , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees , nodes : &amp; HashMap &lt; usize , D :: Process &gt; , clusters : &amp; HashMap &lt; usize , D :: Cluster &gt; , externals : &amp; HashMap &lt; usize , D :: ExternalProcess &gt; ,) { <span class="self">self </span>. transform_children (| n , s | n . compile_network :: &lt; D &gt; (compile_env , s , nodes , clusters , externals) , seen_tees ,) ; <span class="kw">if let </span>HydroNode :: Network { from_location , from_key , to_location , to_key , instantiate_fn , .. } = <span class="self">self </span>{ <span class="kw">let </span>(sink_expr , source_expr , connect_fn) = <span class="kw">match </span>instantiate_fn { DebugInstantiate :: Building () =&gt; instantiate_network :: &lt; D &gt; (from_location , * from_key , to_location , * to_key , nodes , clusters , externals , compile_env ,) , DebugInstantiate :: Finalized (<span class="kw">_ </span>, <span class="kw">_ </span>, <span class="kw">_</span>) =&gt; panic ! (<span class="string">"network already finalized"</span>) , } ; * instantiate_fn = DebugInstantiate :: Finalized (sink_expr , source_expr , <span class="prelude-val">Some </span>(connect_fn)) ; } } <span class="kw">pub fn </span>connect_network (&amp; <span class="kw-2">mut </span><span class="self">self </span>, seen_tees : &amp; <span class="kw-2">mut </span>SeenTees) { <span class="self">self </span>. transform_children (| n , s | n . connect_network (s) , seen_tees) ; <span class="kw">if let </span>HydroNode :: Network { instantiate_fn , .. } = <span class="self">self </span>{ <span class="kw">match </span>instantiate_fn { DebugInstantiate :: Building () =&gt; panic ! (<span class="string">"network not built"</span>) , DebugInstantiate :: Finalized (<span class="kw">_ </span>, <span class="kw">_ </span>, connect_fn) =&gt; { connect_fn . take () . unwrap () () ; } } } } <span class="kw">pub fn </span>transform_bottom_up &lt; C &gt; (&amp; <span class="kw-2">mut </span><span class="self">self </span>, <span class="kw-2">mut </span>transform : <span class="kw">impl </span>FnMut (&amp; <span class="kw-2">mut </span>HydroNode , &amp; <span class="kw-2">mut </span>C) + Copy , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees , ctx : &amp; <span class="kw-2">mut </span>C ,) { <span class="self">self </span>. transform_children (| n , s | n . transform_bottom_up (transform , s , ctx) , seen_tees) ; transform (<span class="self">self </span>, ctx) } # [inline (always)] <span class="kw">pub fn </span>transform_children (&amp; <span class="kw-2">mut </span><span class="self">self </span>, <span class="kw-2">mut </span>transform : <span class="kw">impl </span>FnMut (&amp; <span class="kw-2">mut </span>HydroNode , &amp; <span class="kw-2">mut </span>SeenTees) , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees ,) { <span class="kw">match </span><span class="self">self </span>{ HydroNode :: Placeholder =&gt; { panic ! () ; } HydroNode :: Source { .. } =&gt; { } HydroNode :: CycleSource { .. } =&gt; { } HydroNode :: Tee { inner } =&gt; { <span class="kw">if let </span><span class="prelude-val">Some </span>(transformed) = seen_tees . get (&amp; (inner . <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HydroNode &gt;)) { * inner = TeeNode (transformed . clone ()) ; } <span class="kw">else </span>{ <span class="kw">let </span>transformed_cell = Rc :: new (RefCell :: new (HydroNode :: Placeholder)) ; seen_tees . insert (inner . <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HydroNode &gt; , transformed_cell . clone () ,) ; <span class="kw">let </span><span class="kw-2">mut </span>orig = inner . <span class="number">0 </span>. replace (HydroNode :: Placeholder) ; transform (&amp; <span class="kw-2">mut </span>orig , seen_tees) ; * transformed_cell . borrow_mut () = orig ; * inner = TeeNode (transformed_cell) ; } } HydroNode :: Persist (inner) =&gt; transform (inner . as_mut () , seen_tees) , HydroNode :: Unpersist (inner) =&gt; transform (inner . as_mut () , seen_tees) , HydroNode :: Delta (inner) =&gt; transform (inner . as_mut () , seen_tees) , HydroNode :: Chain (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HydroNode :: CrossProduct (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HydroNode :: CrossSingleton (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HydroNode :: Join (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HydroNode :: Difference (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HydroNode :: AntiJoin (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HydroNode :: Map { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: FlatMap { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: Filter { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: FilterMap { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: Sort (input) =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: DeferTick (input) =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: Enumerate { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: Inspect { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: Unique (input) =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: Fold { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: FoldKeyed { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: Reduce { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: ReduceKeyed { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HydroNode :: Network { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } } } # [cfg (feature = <span class="string">"build"</span>)] <span class="kw">pub fn </span>emit (&amp; <span class="self">self </span>, graph_builders : &amp; <span class="kw-2">mut </span>BTreeMap &lt; usize , FlatGraphBuilder &gt; , built_tees : &amp; <span class="kw-2">mut </span>HashMap &lt; * <span class="kw">const </span>RefCell &lt; HydroNode &gt; , (syn :: Ident , usize) &gt; , next_stmt_id : &amp; <span class="kw-2">mut </span>usize ,) -&gt; (syn :: Ident , usize) { <span class="kw">match </span><span class="self">self </span>{ HydroNode :: Placeholder =&gt; { panic ! () } HydroNode :: Persist (inner) =&gt; { <span class="kw">let </span>(inner_ident , location) = inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>persist_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>persist_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, persist_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (location) . or_default () ; builder . add_statement (parse_quote ! { # persist_ident = # inner_ident -&gt; persist ::&lt;<span class="lifetime">'static </span>&gt; () ; }) ; (persist_ident , location) } HydroNode :: Unpersist (<span class="kw">_</span>) =&gt; { panic ! (<span class="string">"Unpersist is a marker node and should have been optimized away. This is likely a compiler bug."</span>) } HydroNode :: Delta (inner) =&gt; { <span class="kw">let </span>(inner_ident , location) = inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>delta_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>delta_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, delta_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (location) . or_default () ; builder . add_statement (parse_quote ! { # delta_ident = # inner_ident -&gt; multiset_delta () ; }) ; (delta_ident , location) } HydroNode :: Source { source , location_kind , } =&gt; { <span class="kw">let </span>location_id = <span class="kw">match </span>location_kind { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , LocationId :: Tick (<span class="kw">_ </span>, <span class="kw">_</span>) =&gt; panic ! () , LocationId :: ExternalProcess (id) =&gt; id , } ; <span class="kw">if let </span>HydroSource :: ExternalNetwork () = source { (syn :: Ident :: new (<span class="string">"DUMMY" </span>, Span :: call_site ()) , * location_id) } <span class="kw">else </span>{ <span class="kw">let </span>source_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>source_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, source_id) , Span :: call_site ()) ; <span class="kw">let </span>source_stmt = <span class="kw">match </span>source { HydroSource :: Stream (expr) =&gt; { parse_quote ! { # source_ident = source_stream (# expr) ; } } HydroSource :: ExternalNetwork () =&gt; { unreachable ! () } HydroSource :: Iter (expr) =&gt; { parse_quote ! { # source_ident = source_iter (# expr) ; } } HydroSource :: Spin () =&gt; { parse_quote ! { # source_ident = spin () ; } } } ; graph_builders . entry (* location_id) . or_default () . add_statement (source_stmt) ; (source_ident , * location_id) } } HydroNode :: CycleSource { ident , location_kind , } =&gt; { <span class="kw">let </span>location_id = <span class="kw">match </span>location_kind . root () { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , LocationId :: Tick (<span class="kw">_ </span>, <span class="kw">_</span>) =&gt; panic ! () , LocationId :: ExternalProcess (<span class="kw">_</span>) =&gt; panic ! () , } ; (ident . clone () , * location_id) } HydroNode :: Tee { inner } =&gt; { <span class="kw">if let </span><span class="prelude-val">Some </span>(ret) = built_tees . get (&amp; (inner . <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HydroNode &gt;)) { ret . clone () } <span class="kw">else </span>{ <span class="kw">let </span>(inner_ident , inner_location_id) = inner . <span class="number">0 </span>. borrow () . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>tee_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>tee_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, tee_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (inner_location_id) . or_default () ; builder . add_statement (parse_quote ! { # tee_ident = # inner_ident -&gt; tee () ; }) ; built_tees . insert (inner . <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HydroNode &gt; , (tee_ident . clone () , inner_location_id) ,) ; (tee_ident , inner_location_id) } } HydroNode :: Chain (left , right) =&gt; { <span class="kw">let </span>(left_ident , left_location_id) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"chain inputs must be in the same location"</span>) ; <span class="kw">let </span>union_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>chain_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, union_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; builder . add_statement (parse_quote ! { # chain_ident = chain () ; }) ; builder . add_statement (parse_quote ! { # left_ident -&gt; [<span class="number">0</span>] # chain_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [<span class="number">1</span>] # chain_ident ; }) ; (chain_ident , left_location_id) } HydroNode :: CrossSingleton (left , right) =&gt; { <span class="kw">let </span>(left_ident , left_location_id) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"cross_singleton inputs must be in the same location"</span>) ; <span class="kw">let </span>union_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>cross_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, union_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; builder . add_statement (parse_quote ! { # cross_ident = cross_singleton () ; }) ; builder . add_statement (parse_quote ! { # left_ident -&gt; [input] # cross_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [single] # cross_ident ; }) ; (cross_ident , left_location_id) } HydroNode :: CrossProduct (..) | HydroNode :: Join (..) =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HydroNode :: CrossProduct (..)) { parse_quote ! (cross_join_multiset) } <span class="kw">else </span>{ parse_quote ! (join_multiset) } ; <span class="kw">let </span>(HydroNode :: CrossProduct (left , right) | HydroNode :: Join (left , right)) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(left_inner , left_was_persist) = <span class="kw">if let </span>HydroNode :: Persist (left) = left . as_ref () { (left , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (left , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(right_inner , right_was_persist) = <span class="kw">if let </span>HydroNode :: Persist (right) = right . as_ref () { (right , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (right , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(left_ident , left_location_id) = left_inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right_inner . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"join / cross product inputs must be in the same location"</span>) ; <span class="kw">let </span>stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, stream_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; <span class="kw">match </span>(left_was_persist , right_was_persist) { (<span class="bool-val">true </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'static </span>, <span class="lifetime">'static </span>&gt; () ; }) ; } (<span class="bool-val">true </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'static </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; } (<span class="bool-val">false </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'static </span>&gt; () ; }) ; } (<span class="bool-val">false </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; } } ; builder . add_statement (parse_quote ! { # left_ident -&gt; [<span class="number">0</span>] # stream_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [<span class="number">1</span>] # stream_ident ; }) ; (stream_ident , left_location_id) } HydroNode :: Difference (..) | HydroNode :: AntiJoin (..) =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HydroNode :: Difference (..)) { parse_quote ! (difference_multiset) } <span class="kw">else </span>{ parse_quote ! (anti_join_multiset) } ; <span class="kw">let </span>(HydroNode :: Difference (left , right) | HydroNode :: AntiJoin (left , right)) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(right , right_was_persist) = <span class="kw">if let </span>HydroNode :: Persist (right) = right . as_ref () { (right , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (right , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(left_ident , left_location_id) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"difference / anti join inputs must be in the same location"</span>) ; <span class="kw">let </span>stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, stream_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; <span class="kw">if </span>right_was_persist { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'static </span>&gt; () ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; } builder . add_statement (parse_quote ! { # left_ident -&gt; [pos] # stream_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [neg] # stream_ident ; }) ; (stream_ident , left_location_id) } HydroNode :: Map { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # map_ident = # input_ident -&gt; map (# f) ; }) ; (map_ident , input_location_id) } HydroNode :: FlatMap { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>flat_map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>flat_map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, flat_map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # flat_map_ident = # input_ident -&gt; flat_map (# f) ; }) ; (flat_map_ident , input_location_id) } HydroNode :: Filter { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>filter_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>filter_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, filter_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # filter_ident = # input_ident -&gt; filter (# f) ; }) ; (filter_ident , input_location_id) } HydroNode :: FilterMap { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>filter_map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>filter_map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, filter_map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # filter_map_ident = # input_ident -&gt; filter_map (# f) ; }) ; (filter_map_ident , input_location_id) } HydroNode :: Sort (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>sort_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>sort_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, sort_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # sort_ident = # input_ident -&gt; sort () ; }) ; (sort_ident , input_location_id) } HydroNode :: DeferTick (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>defer_tick_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>defer_tick_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, defer_tick_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # defer_tick_ident = # input_ident -&gt; defer_tick_lazy () ; }) ; (defer_tick_ident , input_location_id) } HydroNode :: Enumerate { is_static , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>enumerate_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>enumerate_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, enumerate_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if </span>* is_static { builder . add_statement (parse_quote ! { # enumerate_ident = # input_ident -&gt; enumerate ::&lt;<span class="lifetime">'static </span>&gt; () ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # enumerate_ident = # input_ident -&gt; enumerate ::&lt;<span class="lifetime">'tick </span>&gt; () ; }) ; } (enumerate_ident , input_location_id) } HydroNode :: Inspect { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>inspect_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>inspect_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, inspect_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # inspect_ident = # input_ident -&gt; inspect (# f) ; }) ; (inspect_ident , input_location_id) } HydroNode :: Unique (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>unique_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>unique_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, unique_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # unique_ident = # input_ident -&gt; unique ::&lt;<span class="lifetime">'tick </span>&gt; () ; }) ; (unique_ident , input_location_id) } HydroNode :: Fold { .. } | HydroNode :: FoldKeyed { .. } =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HydroNode :: Fold { .. }) { parse_quote ! (fold) } <span class="kw">else </span>{ parse_quote ! (fold_keyed) } ; <span class="kw">let </span>(HydroNode :: Fold { init , acc , input } | HydroNode :: FoldKeyed { init , acc , input }) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(input , input_was_persist) = <span class="kw">if let </span>HydroNode :: Persist (input) = input . as_ref () { (input , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (input , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>reduce_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>fold_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, reduce_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if </span>input_was_persist { builder . add_statement (parse_quote ! { # fold_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'static </span>&gt; (# init , # acc) ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # fold_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'tick </span>&gt; (# init , # acc) ; }) ; } (fold_ident , input_location_id) } HydroNode :: Reduce { .. } | HydroNode :: ReduceKeyed { .. } =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HydroNode :: Reduce { .. }) { parse_quote ! (reduce) } <span class="kw">else </span>{ parse_quote ! (reduce_keyed) } ; <span class="kw">let </span>(HydroNode :: Reduce { f , input } | HydroNode :: ReduceKeyed { f , input }) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(input , input_was_persist) = <span class="kw">if let </span>HydroNode :: Persist (input) = input . as_ref () { (input , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (input , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>reduce_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>reduce_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, reduce_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if </span>input_was_persist { builder . add_statement (parse_quote ! { # reduce_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'static </span>&gt; (# f) ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # reduce_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'tick </span>&gt; (# f) ; }) ; } (reduce_ident , input_location_id) } HydroNode :: Network { from_location : <span class="kw">_ </span>, from_key : <span class="kw">_ </span>, to_location , to_key : <span class="kw">_ </span>, serialize_fn : serialize_pipeline , instantiate_fn , deserialize_fn : deserialize_pipeline , input , } =&gt; { <span class="kw">let </span>(sink_expr , source_expr , _connect_fn) = <span class="kw">match </span>instantiate_fn { DebugInstantiate :: Building () =&gt; { panic ! (<span class="string">"Expected the network to be finalized"</span>) } DebugInstantiate :: Finalized (sink , source , connect_fn) =&gt; { (sink , source , connect_fn) } } ; <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>sender_builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(serialize_pipeline) = serialize_pipeline { sender_builder . add_statement (parse_quote ! { # input_ident -&gt; map (# serialize_pipeline) -&gt; dest_sink (# sink_expr) ; }) ; } <span class="kw">else </span>{ sender_builder . add_statement (parse_quote ! { # input_ident -&gt; dest_sink (# sink_expr) ; }) ; } <span class="kw">let </span>to_id = <span class="kw">match </span>to_location { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , LocationId :: Tick (<span class="kw">_ </span>, <span class="kw">_</span>) =&gt; panic ! () , LocationId :: ExternalProcess (id) =&gt; id , } ; <span class="kw">let </span>receiver_builder = graph_builders . entry (* to_id) . or_default () ; <span class="kw">let </span>receiver_stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>receiver_stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, receiver_stream_id) , Span :: call_site ()) ; <span class="kw">if let </span><span class="prelude-val">Some </span>(deserialize_pipeline) = deserialize_pipeline { receiver_builder . add_statement (parse_quote ! { # receiver_stream_ident = source_stream (# source_expr) -&gt; map (# deserialize_pipeline) ; }) ; } <span class="kw">else </span>{ receiver_builder . add_statement (parse_quote ! { # receiver_stream_ident = source_stream (# source_expr) ; }) ; } (receiver_stream_ident , * to_id) } } } } # [cfg (feature = <span class="string">"build"</span>)] # [expect (clippy :: too_many_arguments , reason = <span class="string">"networking internals"</span>)] <span class="kw">pub fn </span>instantiate_network &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (from_location : &amp; <span class="kw-2">mut </span>LocationId , from_key : <span class="prelude-ty">Option </span>&lt; usize &gt; , to_location : &amp; <span class="kw-2">mut </span>LocationId , to_key : <span class="prelude-ty">Option </span>&lt; usize &gt; , nodes : &amp; HashMap &lt; usize , D :: Process &gt; , clusters : &amp; HashMap &lt; usize , D :: Cluster &gt; , externals : &amp; HashMap &lt; usize , D :: ExternalProcess &gt; , compile_env : &amp; D :: CompileEnv ,) -&gt; (syn :: Expr , syn :: Expr , Box &lt; <span class="kw">dyn </span>FnOnce () &gt;) { <span class="kw">let </span>((sink , source) , connect_fn) = <span class="kw">match </span>(from_location , to_location) { (LocationId :: Process (from) , LocationId :: Process (to)) =&gt; { <span class="kw">let </span>from_node = nodes . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A process used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = nodes . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A process used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_process_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_process_port (&amp; to_node) ; (D :: o2o_sink_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) , D :: o2o_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) } (LocationId :: Process (from) , LocationId :: Cluster (to)) =&gt; { <span class="kw">let </span>from_node = nodes . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A process used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = clusters . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A cluster used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_process_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_cluster_port (&amp; to_node) ; (D :: o2m_sink_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) , D :: o2m_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) } (LocationId :: Cluster (from) , LocationId :: Process (to)) =&gt; { <span class="kw">let </span>from_node = clusters . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A cluster used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = nodes . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A process used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_cluster_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_process_port (&amp; to_node) ; (D :: m2o_sink_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) , D :: m2o_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) } (LocationId :: Cluster (from) , LocationId :: Cluster (to)) =&gt; { <span class="kw">let </span>from_node = clusters . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A cluster used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = clusters . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A cluster used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_cluster_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_cluster_port (&amp; to_node) ; (D :: m2m_sink_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) , D :: m2m_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) } (LocationId :: ExternalProcess (from) , LocationId :: Process (to)) =&gt; { <span class="kw">let </span>from_node = externals . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A external used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = nodes . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A process used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_external_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_process_port (&amp; to_node) ; from_node . register (from_key . unwrap () , sink_port . clone ()) ; ((parse_quote ! (DUMMY) , D :: e2o_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) , D :: e2o_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) } (LocationId :: ExternalProcess (_from) , LocationId :: Cluster (_to)) =&gt; { todo ! (<span class="string">"NYI"</span>) } (LocationId :: ExternalProcess (<span class="kw">_</span>) , LocationId :: ExternalProcess (<span class="kw">_</span>)) =&gt; { panic ! (<span class="string">"Cannot send from external to external"</span>) } (LocationId :: Process (from) , LocationId :: ExternalProcess (to)) =&gt; { <span class="kw">let </span>from_node = nodes . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A process used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = externals . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A external used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_process_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_external_port (&amp; to_node) ; to_node . register (to_key . unwrap () , source_port . clone ()) ; ((D :: o2e_sink (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) , parse_quote ! (DUMMY) ,) , D :: o2e_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) ,) } (LocationId :: Cluster (_from) , LocationId :: ExternalProcess (_to)) =&gt; { todo ! (<span class="string">"NYI"</span>) } (LocationId :: Tick (<span class="kw">_ </span>, <span class="kw">_</span>) , <span class="kw">_</span>) =&gt; panic ! () , (<span class="kw">_ </span>, LocationId :: Tick (<span class="kw">_ </span>, <span class="kw">_</span>)) =&gt; panic ! () , } ; (sink , source , connect_fn) } } <span class="kw">pub mod </span>rewrites { <span class="kw">pub mod </span>persist_pullup { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: HashSet ; <span class="kw">pub use crate </span>:: __staged :: ir :: * ; <span class="kw">pub fn </span>persist_pullup_node (node : &amp; <span class="kw-2">mut </span>HydroNode , persist_pulled_tees : &amp; <span class="kw-2">mut </span>HashSet &lt; * <span class="kw">const </span>RefCell &lt; HydroNode &gt; &gt; ,) { * node = match_box :: match_box ! { <span class="kw">match </span>std :: mem :: replace (node , HydroNode :: Placeholder) { HydroNode :: Unpersist (mb ! (* HydroNode :: Persist (mb ! (* behind_persist)))) =&gt; behind_persist , HydroNode :: Delta (mb ! (* HydroNode :: Persist (mb ! (* behind_persist)))) =&gt; behind_persist , HydroNode :: Tee { inner } =&gt; { <span class="kw">if </span>persist_pulled_tees . contains (&amp; (inner . <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HydroNode &gt;)) { HydroNode :: Persist (Box :: new (HydroNode :: Tee { inner : TeeNode (inner . <span class="number">0 </span>. clone ()) , })) } <span class="kw">else if </span>matches ! (* inner . <span class="number">0 </span>. borrow () , HydroNode :: Persist (<span class="kw">_</span>)) { persist_pulled_tees . insert (inner . <span class="number">0 </span>. as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HydroNode &gt;) ; <span class="kw">if let </span>HydroNode :: Persist (behind_persist) = inner . <span class="number">0 </span>. replace (HydroNode :: Placeholder) { * inner . <span class="number">0 </span>. borrow_mut () = * behind_persist ; } <span class="kw">else </span>{ unreachable ! () } HydroNode :: Persist (Box :: new (HydroNode :: Tee { inner : TeeNode (inner . <span class="number">0 </span>. clone ()) , })) } <span class="kw">else </span>{ HydroNode :: Tee { inner } } } HydroNode :: Map { f , input : mb ! (* HydroNode :: Persist (behind_persist)) , } =&gt; HydroNode :: Persist (Box :: new (HydroNode :: Map { f , input : behind_persist , })) , HydroNode :: FilterMap { f , input : mb ! (* HydroNode :: Persist (behind_persist)) , } =&gt; HydroNode :: Persist (Box :: new (HydroNode :: FilterMap { f , input : behind_persist , })) , HydroNode :: FlatMap { f , input : mb ! (* HydroNode :: Persist (behind_persist)) , } =&gt; HydroNode :: Persist (Box :: new (HydroNode :: FlatMap { f , input : behind_persist , })) , HydroNode :: Filter { f , input : mb ! (* HydroNode :: Persist (behind_persist)) , } =&gt; HydroNode :: Persist (Box :: new (HydroNode :: Filter { f , input : behind_persist , })) , HydroNode :: Network { from_location , from_key , to_location , to_key , serialize_fn , instantiate_fn , deserialize_fn , input : mb ! (* HydroNode :: Persist (behind_persist)) , .. } =&gt; HydroNode :: Persist (Box :: new (HydroNode :: Network { from_location , from_key , to_location , to_key , serialize_fn , instantiate_fn , deserialize_fn , input : behind_persist , })) , HydroNode :: Chain (mb ! (* HydroNode :: Persist (left)) , mb ! (* HydroNode :: Persist (right))) =&gt; { HydroNode :: Persist (Box :: new (HydroNode :: Chain (left , right))) } HydroNode :: CrossProduct (mb ! (* HydroNode :: Persist (left)) , mb ! (* HydroNode :: Persist (right))) =&gt; { HydroNode :: Persist (Box :: new (HydroNode :: Delta (Box :: new (HydroNode :: CrossProduct (Box :: new (HydroNode :: Persist (left)) , Box :: new (HydroNode :: Persist (right)) ,) ,)))) } HydroNode :: Join (mb ! (* HydroNode :: Persist (left)) , mb ! (* HydroNode :: Persist (right))) =&gt; { HydroNode :: Persist (Box :: new (HydroNode :: Delta (Box :: new (HydroNode :: Join (Box :: new (HydroNode :: Persist (left)) , Box :: new (HydroNode :: Persist (right)) ,))))) } HydroNode :: Unique (mb ! (* HydroNode :: Persist (inner))) =&gt; { HydroNode :: Persist (Box :: new (HydroNode :: Delta (Box :: new (HydroNode :: Unique (Box :: new (HydroNode :: Persist (inner)) ,))))) } node =&gt; node , } } ; } <span class="kw">pub fn </span>persist_pullup (ir : Vec &lt; HydroLeaf &gt;) -&gt; Vec &lt; HydroLeaf &gt; { <span class="kw">let </span><span class="kw-2">mut </span>seen_tees = Default :: default () ; <span class="kw">let </span><span class="kw-2">mut </span>persist_pulled_tees = Default :: default () ; ir . into_iter () . map (| l | { l . transform_children (| n , s | n . transform_bottom_up (persist_pullup_node , s , &amp; <span class="kw-2">mut </span>persist_pulled_tees) , &amp; <span class="kw-2">mut </span>seen_tees ,) }) . collect () } # [cfg (stageleft_macro)] <span class="kw">pub mod </span>tests { <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use crate </span>:: __staged :: deploy :: MultiGraph ; <span class="kw">pub use crate </span>:: __staged :: location :: Location ; # [test] <span class="kw">pub fn </span>persist_pullup_through_map () { <span class="kw">let </span>flow = <span class="kw">crate </span>:: builder :: FlowBuilder :: new () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; process . source_iter (q ! (<span class="number">0 </span>.. <span class="number">10</span>)) . map (q ! (| v | v + <span class="number">1</span>)) . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; <span class="kw">let </span>built = flow . finalize () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">let </span>optimized = built . optimize_with (<span class="kw">super </span>:: persist_pullup) ; insta :: assert_debug_snapshot ! (optimized . ir ()) ; <span class="kw">for </span>(id , graph) <span class="kw">in </span>optimized . compile_no_network :: &lt; MultiGraph &gt; () . hydroflow_ir () { insta :: with_settings ! ({ snapshot_suffix =&gt; format ! (<span class="string">"surface_graph_{id}"</span>) } , { insta :: assert_snapshot ! (graph . surface_syntax_string ()) ; }) ; } } # [test] <span class="kw">pub fn </span>persist_pullup_behind_tee () { <span class="kw">let </span>flow = <span class="kw">crate </span>:: builder :: FlowBuilder :: new () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; <span class="kw">let </span>tick = process . tick () ; <span class="kw">let </span>before_tee = <span class="kw">unsafe </span>{ process . source_iter (q ! (<span class="number">0 </span>.. <span class="number">10</span>)) . timestamped (&amp; tick) . tick_batch () . persist () } ; before_tee . clone () . map (q ! (| v | v + <span class="number">1</span>)) . all_ticks () . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; before_tee . clone () . map (q ! (| v | v + <span class="number">1</span>)) . all_ticks () . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; <span class="kw">let </span>built = flow . finalize () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">let </span>optimized = built . optimize_with (<span class="kw">super </span>:: persist_pullup) ; insta :: assert_debug_snapshot ! (optimized . ir ()) ; <span class="kw">for </span>(id , graph) <span class="kw">in </span>optimized . compile_no_network :: &lt; MultiGraph &gt; () . hydroflow_ir () { insta :: with_settings ! ({ snapshot_suffix =&gt; format ! (<span class="string">"surface_graph_{id}"</span>) } , { insta :: assert_snapshot ! (graph . surface_syntax_string ()) ; }) ; } } } } <span class="kw">pub mod </span>profiler { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>dfir_rs :: futures :: channel :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use super </span>:: profiler <span class="kw">as </span>myself ; <span class="kw">pub use crate </span>:: __staged :: ir :: * ; <span class="kw">pub fn </span>increment_counter (count : &amp; <span class="kw-2">mut </span>u64) { * count += <span class="number">1 </span>; } <span class="kw">pub fn </span>quoted_any_fn &lt; <span class="lifetime">'a </span>, F : Fn (&amp; usize) + <span class="lifetime">'a </span>, Q : IntoQuotedMut &lt; <span class="lifetime">'a </span>, F , () &gt; &gt; (q : Q) -&gt; Q { q } # [doc = <span class="string">" Add a profiling node before each node to count the cardinality of its input"</span>] <span class="kw">pub fn </span>add_profiling_node &lt; <span class="lifetime">'a </span>&gt; (node : &amp; <span class="kw-2">mut </span>HydroNode , counters : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; u64 &gt; &gt; &gt; , counter_queue : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; UnboundedSender &lt; (usize , u64) &gt; &gt; &gt; , id : &amp; <span class="kw-2">mut </span>u32 , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees ,) { <span class="kw">let </span>my_id = * id ; * id += <span class="number">1 </span>; node . transform_children (| node , seen_tees | add_profiling_node (node , counters , counter_queue , id , seen_tees) , seen_tees ,) ; <span class="kw">let </span>orig_node = std :: mem :: replace (node , HydroNode :: Placeholder) ; * node = HydroNode :: Inspect { f : quoted_any_fn (q ! ({ counter_queue . borrow () . unbounded_send ((my_id <span class="kw">as </span>usize , counters . borrow () [my_id <span class="kw">as </span>usize])) . unwrap () ; counters . borrow_mut () [my_id <span class="kw">as </span>usize] = <span class="number">0 </span>; <span class="kw">move </span>| <span class="kw">_ </span>| { myself :: increment_counter (&amp; <span class="kw-2">mut </span>counters . borrow_mut () [my_id <span class="kw">as </span>usize]) ; } })) . splice_untyped () . into () , input : Box :: new (orig_node) , } } # [doc = <span class="string">" Count the cardinality of each input and periodically output to a file"</span>] <span class="kw">pub fn </span>profiling &lt; <span class="lifetime">'a </span>&gt; (ir : Vec &lt; HydroLeaf &gt; , counters : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; u64 &gt; &gt; &gt; , counter_queue : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; UnboundedSender &lt; (usize , u64) &gt; &gt; &gt; ,) -&gt; Vec &lt; HydroLeaf &gt; { <span class="kw">let </span><span class="kw-2">mut </span>id = <span class="number">0 </span>; <span class="kw">let </span><span class="kw-2">mut </span>seen_tees = Default :: default () ; ir . into_iter () . map (| l | { l . transform_children (| node , seen_tees | { add_profiling_node (node , counters , counter_queue , &amp; <span class="kw-2">mut </span>id , seen_tees) } , &amp; <span class="kw-2">mut </span>seen_tees ,) }) . collect () } # [cfg (stageleft_macro)] <span class="kw">pub mod </span>tests { <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use crate </span>:: __staged :: deploy :: MultiGraph ; <span class="kw">pub use crate </span>:: __staged :: location :: Location ; # [test] <span class="kw">pub fn </span>profiler_wrapping_all_operators () { <span class="kw">let </span>flow = <span class="kw">crate </span>:: builder :: FlowBuilder :: new () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; process . source_iter (q ! (<span class="number">0 </span>.. <span class="number">10</span>)) . map (q ! (| v | v + <span class="number">1</span>)) . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; <span class="kw">let </span>built = flow . finalize () ; insta :: assert_debug_snapshot ! (&amp; built . ir ()) ; <span class="kw">let </span>counters = RuntimeData :: new (<span class="string">"Fake"</span>) ; <span class="kw">let </span>counter_queue = RuntimeData :: new (<span class="string">"Fake"</span>) ; <span class="kw">let </span>pushed_down = built . optimize_with (<span class="kw">crate </span>:: rewrites :: persist_pullup :: persist_pullup) . optimize_with (| ir | <span class="kw">super </span>:: profiling (ir , counters , counter_queue)) ; insta :: assert_debug_snapshot ! (&amp; pushed_down . ir ()) ; <span class="kw">let _ </span>= pushed_down . compile_no_network :: &lt; MultiGraph &gt; () ; } } } <span class="kw">pub mod </span>properties { <span class="kw">pub use </span>std :: collections :: HashSet ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use crate </span>:: __staged :: ir :: { HydroLeaf , HydroNode , SeenTees } ; <span class="kw">pub use crate </span>:: rewrites :: properties :: PropertyDatabase ; # [doc = <span class="string">" Allows us to convert the dfir datatype for folds to a binary operation for the algebra"</span>] # [doc = <span class="string">" property tests."</span>] # [allow (clippy :: allow_attributes , dead_code , reason = <span class="string">"staged programming"</span>)] <span class="kw">pub fn </span>convert_hf_to_binary &lt; I , A : Default , F : Fn (&amp; <span class="kw-2">mut </span>A , I) &gt; (f : F) -&gt; <span class="kw">impl </span>Fn (I , I) -&gt; A { <span class="kw">move </span>| a , b | { <span class="kw">let </span><span class="kw-2">mut </span>acc = Default :: default () ; f (&amp; <span class="kw-2">mut </span>acc , a) ; f (&amp; <span class="kw-2">mut </span>acc , b) ; acc } } # [cfg (stageleft_macro)] <span class="kw">impl </span>PropertyDatabase { # [doc = <span class="string">" Tags the expression as commutative."</span>] <span class="kw">pub fn </span>add_commutative_tag &lt; <span class="lifetime">'a </span>, I , A , F : Fn (&amp; <span class="kw-2">mut </span>A , I) , Ctx , Q : QuotedWithContext &lt; <span class="lifetime">'a </span>, F , Ctx &gt; + Clone , &gt; (&amp; <span class="kw-2">mut </span><span class="self">self </span>, expr : Q , ctx : &amp; Ctx ,) -&gt; Q { <span class="kw">let </span>expr_clone = expr . clone () ; <span class="self">self </span>. commutative . insert (expr_clone . splice_untyped_ctx (ctx)) ; expr } <span class="kw">pub fn </span>is_tagged_commutative (&amp; <span class="self">self </span>, expr : &amp; syn :: Expr) -&gt; bool { <span class="self">self </span>. commutative . contains (expr) } } <span class="kw">pub fn </span>properties_optimize_node (node : &amp; <span class="kw-2">mut </span>HydroNode , db : &amp; PropertyDatabase , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees) { node . transform_children (| node , seen_tees | properties_optimize_node (node , db , seen_tees) , seen_tees ,) ; <span class="kw">match </span>node { HydroNode :: ReduceKeyed { f , .. } <span class="kw">if </span>db . is_tagged_commutative (&amp; f . <span class="number">0</span>) =&gt; { dbg ! (<span class="string">"IDENTIFIED COMMUTATIVE OPTIMIZATION for {:?}" </span>, &amp; f) ; } <span class="kw">_ </span>=&gt; { } } } <span class="kw">pub fn </span>properties_optimize (ir : Vec &lt; HydroLeaf &gt; , db : &amp; PropertyDatabase) -&gt; Vec &lt; HydroLeaf &gt; { <span class="kw">let </span><span class="kw-2">mut </span>seen_tees = Default :: default () ; ir . into_iter () . map (| l | { l . transform_children (| node , seen_tees | properties_optimize_node (node , db , seen_tees) , &amp; <span class="kw-2">mut </span>seen_tees ,) }) . collect () } # [cfg (stageleft_macro)] <span class="kw">pub mod </span>tests { <span class="kw">pub use super </span>:: * ; <span class="kw">pub use crate </span>:: __staged :: deploy :: SingleProcessGraph ; <span class="kw">pub use crate </span>:: __staged :: location :: Location ; <span class="kw">pub use crate </span>:: __staged :: FlowBuilder ; # [test] <span class="kw">pub fn </span>test_property_database () { <span class="kw">let </span><span class="kw-2">mut </span>db = PropertyDatabase :: default () ; assert ! (! db . is_tagged_commutative (&amp; (q ! (| a : &amp; <span class="kw-2">mut </span>i32 , b : i32 | * a += b) . splice_untyped_ctx (&amp; ())))) ; <span class="kw">let _ </span>= db . add_commutative_tag (q ! (| a : &amp; <span class="kw-2">mut </span>i32 , b : i32 | * a += b) , &amp; ()) ; assert ! (db . is_tagged_commutative (&amp; (q ! (| a : &amp; <span class="kw-2">mut </span>i32 , b : i32 | * a += b) . splice_untyped_ctx (&amp; ())))) ; } # [test] <span class="kw">pub fn </span>test_property_optimized () { <span class="kw">let </span>flow = FlowBuilder :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>database = PropertyDatabase :: default () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; <span class="kw">let </span>tick = process . tick () ; <span class="kw">let </span>counter_func = q ! (| count : &amp; <span class="kw-2">mut </span>i32 , <span class="kw">_ </span>| * count += <span class="number">1</span>) ; <span class="kw">let _ </span>= database . add_commutative_tag (counter_func , &amp; tick) ; <span class="kw">unsafe </span>{ process . source_iter (q ! (vec ! [])) . map (q ! (| string : String | (string , ()))) . timestamped (&amp; tick) . tick_batch () } . fold_keyed (q ! (|| <span class="number">0</span>) , counter_func) . all_ticks () . for_each (q ! (| (string , count) | println ! (<span class="string">"{}: {}" </span>, string , count))) ; <span class="kw">let </span>built = flow . optimize_with (| ir | properties_optimize (ir , &amp; database)) . with_default_optimize :: &lt; SingleProcessGraph &gt; () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">let _ </span>= built . compile_no_network () ; } } } } <span class="kw">pub mod </span>staging_util { <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub type </span>Invariant &lt; <span class="lifetime">'a </span>, D = () &gt; = PhantomData &lt; (<span class="kw">fn </span>(&amp; <span class="lifetime">'a </span>()) -&gt; &amp; <span class="lifetime">'a </span>() , D) &gt; ; <span class="kw">pub fn </span>get_this_crate () -&gt; TokenStream { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydro_lang"</span>) . expect (<span class="string">"hydro_lang should be present in `Cargo.toml`"</span>) ; <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydro_lang } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , Span :: call_site ()) ; quote ! { # ident } } } } } # [cfg (feature = <span class="string">"deploy"</span>)] <span class="kw">pub mod </span>test_util { <span class="kw">pub use </span>std :: future :: Future ; <span class="kw">pub use </span>std :: pin :: Pin ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use crate </span>:: __staged :: { FlowBuilder , Process , Stream , Unbounded } ; <span class="kw">pub async fn </span>stream_transform_test &lt; <span class="lifetime">'a </span>, O : Serialize + DeserializeOwned + <span class="lifetime">'static </span>, C : Future &lt; Output = () &gt; , &gt; (thunk : <span class="kw">impl </span>FnOnce (&amp; Process &lt; <span class="lifetime">'a </span>&gt;) -&gt; Stream &lt; O , Process &lt; <span class="lifetime">'a </span>&gt; , Unbounded &gt; , check : <span class="kw">impl </span>FnOnce (Pin &lt; Box &lt; <span class="kw">dyn </span>dfir_rs :: futures :: Stream &lt; Item = O &gt; &gt; &gt;) -&gt; C ,) { <span class="kw">let </span><span class="kw-2">mut </span>deployment = hydro_deploy :: Deployment :: new () ; <span class="kw">let </span>flow = FlowBuilder :: new () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; <span class="kw">let </span>external = flow . external_process :: &lt; () &gt; () ; <span class="kw">let </span>out = thunk (&amp; process) ; <span class="kw">let </span>out_port = out . send_bincode_external (&amp; external) ; <span class="kw">let </span>nodes = flow . with_process (&amp; process , deployment . Localhost ()) . with_external (&amp; external , deployment . Localhost ()) . deploy (&amp; <span class="kw-2">mut </span>deployment) ; deployment . deploy () . <span class="kw">await </span>. unwrap () ; <span class="kw">let </span>external_out = nodes . connect_source_bincode (out_port) . <span class="kw">await </span>; deployment . start () . <span class="kw">await </span>. unwrap () ; check (external_out) . <span class="kw">await </span>; } } # [ctor :: ctor] <span class="kw">fn </span>add_private_reexports () { stageleft :: add_private_reexport (vec ! [<span class="string">"tokio" </span>, <span class="string">"time" </span>, <span class="string">"instant"</span>] , vec ! [<span class="string">"tokio" </span>, <span class="string">"time"</span>]) ; stageleft :: add_private_reexport (vec ! [<span class="string">"bytes" </span>, <span class="string">"bytes"</span>] , vec ! [<span class="string">"bytes"</span>]) ; } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { # [ctor :: ctor] <span class="kw">fn </span>init () { <span class="kw">crate </span>:: deploy :: init_test () ; } }</code></pre></div></section></main></body></html>