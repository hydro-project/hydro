<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/hydroflow/hydroflow/target/debug/build/hydroflow_plus_test-5d2637aff9f86bf5/out/lib_pub.rs`."><title>lib_pub.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-fecee23daa4e8a6d.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="hydroflow_plus_test" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0-nightly (4ac7bcbaa 2024-09-04)" data-channel="nightly" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../../../../../../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../../../../../../../../../../../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
</pre></div><pre class="rust"><code># [cfg (stageleft_macro)] <span class="kw">pub mod </span>cluster { <span class="kw">pub mod </span>compute_pi { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: time :: Duration ; <span class="kw">pub use </span>futures :: channel :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>hydroflow_plus :: profiler :: profiling ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub fn </span>compute_pi &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; , cluster_spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; , batch_size : RuntimeData &lt; &amp; <span class="lifetime">'a </span>usize &gt; ,) -&gt; D :: Process { <span class="kw">let </span>cluster = flow . cluster (cluster_spec) ; <span class="kw">let </span>process = flow . process (process_spec) ; <span class="kw">let </span>trials = flow . spin_batch (&amp; cluster , q ! (* batch_size)) . map (q ! (| <span class="kw">_ </span>| rand :: random ::&lt; (f64 , f64) &gt; ())) . map (q ! (| (x , y) | x * x + y * y &lt; <span class="number">1.0</span>)) . fold (q ! (|| (<span class="number">0u64 </span>, <span class="number">0u64</span>)) , q ! (| (inside , total) , sample_inside | { <span class="kw">if </span>sample_inside { * inside += <span class="number">1 </span>; } * total += <span class="number">1 </span>; }) ,) ; trials . send_bincode_interleaved (&amp; process) . all_ticks () . reduce (q ! (| (inside , total) , (inside_batch , total_batch) | { * inside += inside_batch ; * total += total_batch ; })) . sample_every (q ! (Duration :: from_secs (<span class="number">1</span>))) . for_each (q ! (| (inside , total) | { println ! (<span class="string">"pi: {} ({} trials)" </span>, <span class="number">4.0 </span>* inside <span class="kw">as </span>f64 / total <span class="kw">as </span>f64 , total) ; })) ; process } <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: HydroCLI ; <span class="kw">pub use </span>hydroflow_plus_cli_integration :: { CLIRuntime , HydroflowPlusMeta } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>compute_pi_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; , batch_size : RuntimeData &lt; &amp; <span class="lifetime">'a </span>usize &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= compute_pi (&amp; flow , &amp; cli , &amp; cli , batch_size) ; flow . extract () . optimize_default () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>cardinality_compute_pi_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; , batch_size : RuntimeData &lt; &amp; <span class="lifetime">'a </span>usize &gt; , counters : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; u64 &gt; &gt; &gt; , counter_queue : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; UnboundedSender &lt; (usize , u64) &gt; &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= compute_pi (&amp; flow , &amp; cli , &amp; cli , batch_size) ; <span class="kw">let </span>runtime_context = flow . runtime_context () ; flow . extract () . optimize_with (| ir | profiling (ir , runtime_context , counters , counter_queue)) . no_optimize () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>stageleft :: RuntimeData ; # [test] <span class="kw">fn </span>compute_pi_ir () { <span class="kw">let </span>builder = hydroflow_plus :: FlowBuilder :: new () ; <span class="kw">let _ </span>= <span class="kw">super </span>:: compute_pi (&amp; builder , &amp; RuntimeData :: new (<span class="string">"FAKE"</span>) , &amp; RuntimeData :: new (<span class="string">"FAKE"</span>) , RuntimeData :: new (<span class="string">"FAKE"</span>) ,) ; <span class="kw">let </span>built = builder . extract () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">for </span>(id , ir) <span class="kw">in </span>built . optimize_default () . hydroflow_ir () { insta :: with_settings ! ({ snapshot_suffix =&gt; format ! (<span class="string">"surface_graph_{id}"</span>) } , { insta :: assert_display_snapshot ! (ir . surface_syntax_string ()) ; }) ; } } } } <span class="kw">pub mod </span>many_to_many { <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub fn </span>many_to_many &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , cluster_spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; D :: Cluster <span class="kw">where </span>D :: ClusterId : std :: fmt :: Debug , { <span class="kw">let </span>cluster = flow . cluster (cluster_spec) ; flow . source_iter (&amp; cluster , q ! (<span class="number">0 </span>.. <span class="number">2</span>)) . broadcast_bincode (&amp; cluster) . for_each (q ! (| n | println ! (<span class="string">"cluster received: {:?}" </span>, n))) ; cluster } <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: HydroCLI ; <span class="kw">pub use </span>hydroflow_plus_cli_integration :: { CLIRuntime , HydroflowPlusMeta } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>many_to_many_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= many_to_many (&amp; flow , &amp; cli) ; flow . extract () . optimize_default () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>std :: cell :: RefCell ; <span class="kw">use </span>hydro_deploy :: { Deployment , HydroflowCrate } ; <span class="kw">use </span>hydroflow_plus_cli_integration :: { DeployClusterSpec , DeployCrateWrapper } ; # [tokio :: test] <span class="kw">async fn </span>many_to_many () { <span class="kw">let </span>deployment = RefCell :: new (Deployment :: new ()) ; <span class="kw">let </span>localhost = deployment . borrow_mut () . Localhost () ; <span class="kw">let </span>builder = hydroflow_plus :: FlowBuilder :: new () ; <span class="kw">let </span>cluster = <span class="kw">super </span>:: many_to_many (&amp; builder , &amp; DeployClusterSpec :: new (| | { (<span class="number">0 </span>.. <span class="number">2</span>) . map (| <span class="kw">_ </span>| { deployment . borrow_mut () . add_service (HydroflowCrate :: new (<span class="string">"." </span>, localhost . clone ()) . bin (<span class="string">"many_to_many"</span>) . profile (<span class="string">"dev"</span>) ,) }) . collect () }) ,) ; insta :: assert_debug_snapshot ! (builder . extract () . ir ()) ; <span class="kw">let </span><span class="kw-2">mut </span>deployment = deployment . into_inner () ; deployment . deploy () . <span class="kw">await </span>. unwrap () ; <span class="kw">let </span>cluster_stdouts = futures :: future :: join_all (cluster . members . iter () . map (| node | node . stdout ())) . <span class="kw">await </span>; deployment . start () . <span class="kw">await </span>. unwrap () ; <span class="kw">for </span><span class="kw-2">mut </span>node_stdout <span class="kw">in </span>cluster_stdouts { <span class="kw">let </span><span class="kw-2">mut </span>node_outs = vec ! [] ; <span class="kw">for </span>_i <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4 </span>{ node_outs . push (node_stdout . recv () . <span class="kw">await </span>. unwrap ()) ; } node_outs . sort () ; <span class="kw">let </span><span class="kw-2">mut </span>node_outs = node_outs . into_iter () ; <span class="kw">for </span>sender <span class="kw">in </span><span class="number">0 </span>.. <span class="number">2 </span>{ <span class="kw">for </span>value <span class="kw">in </span><span class="number">0 </span>.. <span class="number">2 </span>{ assert_eq ! (node_outs . next () . unwrap () , format ! (<span class="string">"cluster received: ({}, {})" </span>, sender , value)) ; } } } } } } <span class="kw">pub mod </span>map_reduce { <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub fn </span>map_reduce &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>, ClusterId = u32 &gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; , cluster_spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; (D :: Process , D :: Cluster) { <span class="kw">let </span>process = flow . process (process_spec) ; <span class="kw">let </span>cluster = flow . cluster (cluster_spec) ; <span class="kw">let </span>words = flow . source_iter (&amp; process , q ! (vec ! [<span class="string">"abc" </span>, <span class="string">"abc" </span>, <span class="string">"xyz" </span>, <span class="string">"abc"</span>])) . map (q ! (| s | s . to_string ())) ; <span class="kw">let </span>all_ids_vec = cluster . ids () ; <span class="kw">let </span>words_partitioned = words . enumerate () . map (q ! (| (i , w) | ((i % all_ids_vec . len ()) <span class="kw">as </span>u32 , w))) ; words_partitioned . send_bincode (&amp; cluster) . tick_batch () . map (q ! (| string | (string , ()))) . fold_keyed (q ! (|| <span class="number">0</span>) , q ! (| count , <span class="kw">_ </span>| * count += <span class="number">1</span>)) . inspect (q ! (| (string , count) | println ! (<span class="string">"partition count: {} - {}" </span>, string , count))) . send_bincode_interleaved (&amp; process) . all_ticks () . reduce_keyed (q ! (| total , count | * total += count)) . for_each (q ! (| (string , count) | println ! (<span class="string">"{}: {}" </span>, string , count))) ; (process , cluster) } <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: HydroCLI ; <span class="kw">pub use </span>hydroflow_plus_cli_integration :: { CLIRuntime , HydroflowPlusMeta } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>map_reduce_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= map_reduce (&amp; flow , &amp; cli , &amp; cli) ; flow . extract () . optimize_default () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>stageleft :: RuntimeData ; # [test] <span class="kw">fn </span>map_reduce_ir () { <span class="kw">let </span>builder = hydroflow_plus :: FlowBuilder :: new () ; <span class="kw">let _ </span>= <span class="kw">super </span>:: map_reduce (&amp; builder , &amp; RuntimeData :: new (<span class="string">"FAKE"</span>) , &amp; RuntimeData :: new (<span class="string">"FAKE"</span>) ,) ; <span class="kw">let </span>built = builder . extract () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">for </span>(id , ir) <span class="kw">in </span>built . optimize_default () . hydroflow_ir () { insta :: with_settings ! ({ snapshot_suffix =&gt; format ! (<span class="string">"surface_graph_{id}"</span>) } , { insta :: assert_display_snapshot ! (ir . surface_syntax_string ()) ; }) ; } } } } <span class="kw">pub mod </span>simple_cluster { <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub fn </span>simple_cluster &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>, ClusterId = u32 &gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; , cluster_spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; (D :: Process , D :: Cluster) { <span class="kw">let </span>process = flow . process (process_spec) ; <span class="kw">let </span>cluster = flow . cluster (cluster_spec) ; <span class="kw">let </span>numbers = flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">5</span>)) ; <span class="kw">let </span>ids = flow . source_iter (&amp; process , cluster . ids ()) . map (q ! (|&amp; id | id)) ; <span class="kw">let </span>cluster_self_id = cluster . self_id () ; ids . cross_product (numbers) . map (q ! (| (id , n) | (id , (id , n)))) . send_bincode (&amp; cluster) . inspect (q ! (<span class="kw">move </span>| n | println ! (<span class="string">"cluster received: {:?} (self cluster id: {})" </span>, n , cluster_self_id))) . send_bincode (&amp; process) . for_each (q ! (| (id , d) | println ! (<span class="string">"node received: ({}, {:?})" </span>, id , d))) ; (process , cluster) } <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: HydroCLI ; <span class="kw">pub use </span>hydroflow_plus_cli_integration :: { CLIRuntime , HydroflowPlusMeta } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>simple_cluster_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= simple_cluster (&amp; flow , &amp; cli , &amp; cli) ; flow . extract () . optimize_default () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>std :: cell :: RefCell ; <span class="kw">use </span>hydro_deploy :: { Deployment , HydroflowCrate } ; <span class="kw">use </span>hydroflow_plus_cli_integration :: { DeployClusterSpec , DeployCrateWrapper , DeployProcessSpec , } ; # [tokio :: test] <span class="kw">async fn </span>simple_cluster () { <span class="kw">let </span>deployment = RefCell :: new (Deployment :: new ()) ; <span class="kw">let </span>localhost = deployment . borrow_mut () . Localhost () ; <span class="kw">let </span>builder = hydroflow_plus :: FlowBuilder :: new () ; <span class="kw">let </span>(node , cluster) = <span class="kw">super </span>:: simple_cluster (&amp; builder , &amp; DeployProcessSpec :: new (| | { deployment . borrow_mut () . add_service (HydroflowCrate :: new (<span class="string">"." </span>, localhost . clone ()) . bin (<span class="string">"simple_cluster"</span>) . profile (<span class="string">"dev"</span>) ,) }) , &amp; DeployClusterSpec :: new (| | { (<span class="number">0 </span>.. <span class="number">2</span>) . map (| <span class="kw">_ </span>| { deployment . borrow_mut () . add_service (HydroflowCrate :: new (<span class="string">"." </span>, localhost . clone ()) . bin (<span class="string">"simple_cluster"</span>) . profile (<span class="string">"dev"</span>) ,) }) . collect () }) ,) ; insta :: assert_debug_snapshot ! (builder . extract () . ir ()) ; <span class="kw">let </span><span class="kw-2">mut </span>deployment = deployment . into_inner () ; deployment . deploy () . <span class="kw">await </span>. unwrap () ; <span class="kw">let </span><span class="kw-2">mut </span>node_stdout = node . stdout () . <span class="kw">await </span>; <span class="kw">let </span>cluster_stdouts = futures :: future :: join_all (cluster . members . iter () . map (| node | node . stdout ())) . <span class="kw">await </span>; deployment . start () . <span class="kw">await </span>. unwrap () ; <span class="kw">for </span>(i , <span class="kw-2">mut </span>stdout) <span class="kw">in </span>cluster_stdouts . into_iter () . enumerate () { <span class="kw">for </span>j <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5 </span>{ assert_eq ! (stdout . recv () . <span class="kw">await </span>. unwrap () , format ! (<span class="string">"cluster received: ({}, {}) (self cluster id: {})" </span>, i , j , i)) ; } } <span class="kw">let </span><span class="kw-2">mut </span>node_outs = vec ! [] ; <span class="kw">for </span>_i <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10 </span>{ node_outs . push (node_stdout . recv () . <span class="kw">await </span>. unwrap ()) ; } node_outs . sort () ; <span class="kw">for </span>(i , n) <span class="kw">in </span>node_outs . into_iter () . enumerate () { assert_eq ! (n , format ! (<span class="string">"node received: ({}, ({}, {}))" </span>, i / <span class="number">5 </span>, i / <span class="number">5 </span>, i % <span class="number">5</span>)) ; } } } } } # [cfg (not (stageleft_macro))] <span class="kw">pub mod </span>cluster { <span class="kw">pub mod </span>compute_pi { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: time :: Duration ; <span class="kw">pub use </span>futures :: channel :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>hydroflow_plus :: profiler :: profiling ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub fn </span>compute_pi &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; , cluster_spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; , batch_size : RuntimeData &lt; &amp; <span class="lifetime">'a </span>usize &gt; ,) -&gt; D :: Process { <span class="kw">let </span>cluster = flow . cluster (cluster_spec) ; <span class="kw">let </span>process = flow . process (process_spec) ; <span class="kw">let </span>trials = flow . spin_batch (&amp; cluster , q ! (* batch_size)) . map (q ! (| <span class="kw">_ </span>| rand :: random ::&lt; (f64 , f64) &gt; ())) . map (q ! (| (x , y) | x * x + y * y &lt; <span class="number">1.0</span>)) . fold (q ! (|| (<span class="number">0u64 </span>, <span class="number">0u64</span>)) , q ! (| (inside , total) , sample_inside | { <span class="kw">if </span>sample_inside { * inside += <span class="number">1 </span>; } * total += <span class="number">1 </span>; }) ,) ; trials . send_bincode_interleaved (&amp; process) . all_ticks () . reduce (q ! (| (inside , total) , (inside_batch , total_batch) | { * inside += inside_batch ; * total += total_batch ; })) . sample_every (q ! (Duration :: from_secs (<span class="number">1</span>))) . for_each (q ! (| (inside , total) | { println ! (<span class="string">"pi: {} ({} trials)" </span>, <span class="number">4.0 </span>* inside <span class="kw">as </span>f64 / total <span class="kw">as </span>f64 , total) ; })) ; process } <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: HydroCLI ; <span class="kw">pub use </span>hydroflow_plus_cli_integration :: { CLIRuntime , HydroflowPlusMeta } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>compute_pi_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; , batch_size : RuntimeData &lt; &amp; <span class="lifetime">'a </span>usize &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= compute_pi (&amp; flow , &amp; cli , &amp; cli , batch_size) ; flow . extract () . optimize_default () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>cardinality_compute_pi_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; , batch_size : RuntimeData &lt; &amp; <span class="lifetime">'a </span>usize &gt; , counters : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; u64 &gt; &gt; &gt; , counter_queue : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; UnboundedSender &lt; (usize , u64) &gt; &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= compute_pi (&amp; flow , &amp; cli , &amp; cli , batch_size) ; <span class="kw">let </span>runtime_context = flow . runtime_context () ; flow . extract () . optimize_with (| ir | profiling (ir , runtime_context , counters , counter_queue)) . no_optimize () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>stageleft :: RuntimeData ; # [test] <span class="kw">fn </span>compute_pi_ir () { <span class="kw">let </span>builder = hydroflow_plus :: FlowBuilder :: new () ; <span class="kw">let _ </span>= <span class="kw">super </span>:: compute_pi (&amp; builder , &amp; RuntimeData :: new (<span class="string">"FAKE"</span>) , &amp; RuntimeData :: new (<span class="string">"FAKE"</span>) , RuntimeData :: new (<span class="string">"FAKE"</span>) ,) ; <span class="kw">let </span>built = builder . extract () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">for </span>(id , ir) <span class="kw">in </span>built . optimize_default () . hydroflow_ir () { insta :: with_settings ! ({ snapshot_suffix =&gt; format ! (<span class="string">"surface_graph_{id}"</span>) } , { insta :: assert_display_snapshot ! (ir . surface_syntax_string ()) ; }) ; } } } } <span class="kw">pub mod </span>many_to_many { <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub fn </span>many_to_many &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , cluster_spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; D :: Cluster <span class="kw">where </span>D :: ClusterId : std :: fmt :: Debug , { <span class="kw">let </span>cluster = flow . cluster (cluster_spec) ; flow . source_iter (&amp; cluster , q ! (<span class="number">0 </span>.. <span class="number">2</span>)) . broadcast_bincode (&amp; cluster) . for_each (q ! (| n | println ! (<span class="string">"cluster received: {:?}" </span>, n))) ; cluster } <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: HydroCLI ; <span class="kw">pub use </span>hydroflow_plus_cli_integration :: { CLIRuntime , HydroflowPlusMeta } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>many_to_many_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= many_to_many (&amp; flow , &amp; cli) ; flow . extract () . optimize_default () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>std :: cell :: RefCell ; <span class="kw">use </span>hydro_deploy :: { Deployment , HydroflowCrate } ; <span class="kw">use </span>hydroflow_plus_cli_integration :: { DeployClusterSpec , DeployCrateWrapper } ; # [tokio :: test] <span class="kw">async fn </span>many_to_many () { <span class="kw">let </span>deployment = RefCell :: new (Deployment :: new ()) ; <span class="kw">let </span>localhost = deployment . borrow_mut () . Localhost () ; <span class="kw">let </span>builder = hydroflow_plus :: FlowBuilder :: new () ; <span class="kw">let </span>cluster = <span class="kw">super </span>:: many_to_many (&amp; builder , &amp; DeployClusterSpec :: new (| | { (<span class="number">0 </span>.. <span class="number">2</span>) . map (| <span class="kw">_ </span>| { deployment . borrow_mut () . add_service (HydroflowCrate :: new (<span class="string">"." </span>, localhost . clone ()) . bin (<span class="string">"many_to_many"</span>) . profile (<span class="string">"dev"</span>) ,) }) . collect () }) ,) ; insta :: assert_debug_snapshot ! (builder . extract () . ir ()) ; <span class="kw">let </span><span class="kw-2">mut </span>deployment = deployment . into_inner () ; deployment . deploy () . <span class="kw">await </span>. unwrap () ; <span class="kw">let </span>cluster_stdouts = futures :: future :: join_all (cluster . members . iter () . map (| node | node . stdout ())) . <span class="kw">await </span>; deployment . start () . <span class="kw">await </span>. unwrap () ; <span class="kw">for </span><span class="kw-2">mut </span>node_stdout <span class="kw">in </span>cluster_stdouts { <span class="kw">let </span><span class="kw-2">mut </span>node_outs = vec ! [] ; <span class="kw">for </span>_i <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4 </span>{ node_outs . push (node_stdout . recv () . <span class="kw">await </span>. unwrap ()) ; } node_outs . sort () ; <span class="kw">let </span><span class="kw-2">mut </span>node_outs = node_outs . into_iter () ; <span class="kw">for </span>sender <span class="kw">in </span><span class="number">0 </span>.. <span class="number">2 </span>{ <span class="kw">for </span>value <span class="kw">in </span><span class="number">0 </span>.. <span class="number">2 </span>{ assert_eq ! (node_outs . next () . unwrap () , format ! (<span class="string">"cluster received: ({}, {})" </span>, sender , value)) ; } } } } } } <span class="kw">pub mod </span>map_reduce { <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub fn </span>map_reduce &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>, ClusterId = u32 &gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; , cluster_spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; (D :: Process , D :: Cluster) { <span class="kw">let </span>process = flow . process (process_spec) ; <span class="kw">let </span>cluster = flow . cluster (cluster_spec) ; <span class="kw">let </span>words = flow . source_iter (&amp; process , q ! (vec ! [<span class="string">"abc" </span>, <span class="string">"abc" </span>, <span class="string">"xyz" </span>, <span class="string">"abc"</span>])) . map (q ! (| s | s . to_string ())) ; <span class="kw">let </span>all_ids_vec = cluster . ids () ; <span class="kw">let </span>words_partitioned = words . enumerate () . map (q ! (| (i , w) | ((i % all_ids_vec . len ()) <span class="kw">as </span>u32 , w))) ; words_partitioned . send_bincode (&amp; cluster) . tick_batch () . map (q ! (| string | (string , ()))) . fold_keyed (q ! (|| <span class="number">0</span>) , q ! (| count , <span class="kw">_ </span>| * count += <span class="number">1</span>)) . inspect (q ! (| (string , count) | println ! (<span class="string">"partition count: {} - {}" </span>, string , count))) . send_bincode_interleaved (&amp; process) . all_ticks () . reduce_keyed (q ! (| total , count | * total += count)) . for_each (q ! (| (string , count) | println ! (<span class="string">"{}: {}" </span>, string , count))) ; (process , cluster) } <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: HydroCLI ; <span class="kw">pub use </span>hydroflow_plus_cli_integration :: { CLIRuntime , HydroflowPlusMeta } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>map_reduce_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= map_reduce (&amp; flow , &amp; cli , &amp; cli) ; flow . extract () . optimize_default () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>stageleft :: RuntimeData ; # [test] <span class="kw">fn </span>map_reduce_ir () { <span class="kw">let </span>builder = hydroflow_plus :: FlowBuilder :: new () ; <span class="kw">let _ </span>= <span class="kw">super </span>:: map_reduce (&amp; builder , &amp; RuntimeData :: new (<span class="string">"FAKE"</span>) , &amp; RuntimeData :: new (<span class="string">"FAKE"</span>) ,) ; <span class="kw">let </span>built = builder . extract () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">for </span>(id , ir) <span class="kw">in </span>built . optimize_default () . hydroflow_ir () { insta :: with_settings ! ({ snapshot_suffix =&gt; format ! (<span class="string">"surface_graph_{id}"</span>) } , { insta :: assert_display_snapshot ! (ir . surface_syntax_string ()) ; }) ; } } } } <span class="kw">pub mod </span>simple_cluster { <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub fn </span>simple_cluster &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>, ClusterId = u32 &gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; , cluster_spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; (D :: Process , D :: Cluster) { <span class="kw">let </span>process = flow . process (process_spec) ; <span class="kw">let </span>cluster = flow . cluster (cluster_spec) ; <span class="kw">let </span>numbers = flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">5</span>)) ; <span class="kw">let </span>ids = flow . source_iter (&amp; process , cluster . ids ()) . map (q ! (|&amp; id | id)) ; <span class="kw">let </span>cluster_self_id = cluster . self_id () ; ids . cross_product (numbers) . map (q ! (| (id , n) | (id , (id , n)))) . send_bincode (&amp; cluster) . inspect (q ! (<span class="kw">move </span>| n | println ! (<span class="string">"cluster received: {:?} (self cluster id: {})" </span>, n , cluster_self_id))) . send_bincode (&amp; process) . for_each (q ! (| (id , d) | println ! (<span class="string">"node received: ({}, {:?})" </span>, id , d))) ; (process , cluster) } <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: HydroCLI ; <span class="kw">pub use </span>hydroflow_plus_cli_integration :: { CLIRuntime , HydroflowPlusMeta } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>simple_cluster_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= simple_cluster (&amp; flow , &amp; cli , &amp; cli) ; flow . extract () . optimize_default () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>std :: cell :: RefCell ; <span class="kw">use </span>hydro_deploy :: { Deployment , HydroflowCrate } ; <span class="kw">use </span>hydroflow_plus_cli_integration :: { DeployClusterSpec , DeployCrateWrapper , DeployProcessSpec , } ; # [tokio :: test] <span class="kw">async fn </span>simple_cluster () { <span class="kw">let </span>deployment = RefCell :: new (Deployment :: new ()) ; <span class="kw">let </span>localhost = deployment . borrow_mut () . Localhost () ; <span class="kw">let </span>builder = hydroflow_plus :: FlowBuilder :: new () ; <span class="kw">let </span>(node , cluster) = <span class="kw">super </span>:: simple_cluster (&amp; builder , &amp; DeployProcessSpec :: new (| | { deployment . borrow_mut () . add_service (HydroflowCrate :: new (<span class="string">"." </span>, localhost . clone ()) . bin (<span class="string">"simple_cluster"</span>) . profile (<span class="string">"dev"</span>) ,) }) , &amp; DeployClusterSpec :: new (| | { (<span class="number">0 </span>.. <span class="number">2</span>) . map (| <span class="kw">_ </span>| { deployment . borrow_mut () . add_service (HydroflowCrate :: new (<span class="string">"." </span>, localhost . clone ()) . bin (<span class="string">"simple_cluster"</span>) . profile (<span class="string">"dev"</span>) ,) }) . collect () }) ,) ; insta :: assert_debug_snapshot ! (builder . extract () . ir ()) ; <span class="kw">let </span><span class="kw-2">mut </span>deployment = deployment . into_inner () ; deployment . deploy () . <span class="kw">await </span>. unwrap () ; <span class="kw">let </span><span class="kw-2">mut </span>node_stdout = node . stdout () . <span class="kw">await </span>; <span class="kw">let </span>cluster_stdouts = futures :: future :: join_all (cluster . members . iter () . map (| node | node . stdout ())) . <span class="kw">await </span>; deployment . start () . <span class="kw">await </span>. unwrap () ; <span class="kw">for </span>(i , <span class="kw-2">mut </span>stdout) <span class="kw">in </span>cluster_stdouts . into_iter () . enumerate () { <span class="kw">for </span>j <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5 </span>{ assert_eq ! (stdout . recv () . <span class="kw">await </span>. unwrap () , format ! (<span class="string">"cluster received: ({}, {}) (self cluster id: {})" </span>, i , j , i)) ; } } <span class="kw">let </span><span class="kw-2">mut </span>node_outs = vec ! [] ; <span class="kw">for </span>_i <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10 </span>{ node_outs . push (node_stdout . recv () . <span class="kw">await </span>. unwrap ()) ; } node_outs . sort () ; <span class="kw">for </span>(i , n) <span class="kw">in </span>node_outs . into_iter () . enumerate () { assert_eq ! (n , format ! (<span class="string">"node received: ({}, ({}, {}))" </span>, i / <span class="number">5 </span>, i / <span class="number">5 </span>, i % <span class="number">5</span>)) ; } } } } } # [cfg (stageleft_macro)] <span class="kw">pub mod </span>local { <span class="kw">pub mod </span>chat_app { <span class="kw">pub use </span>hydroflow_plus :: tokio :: sync :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>hydroflow_plus :: tokio_stream :: wrappers :: UnboundedReceiverStream ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: { q , Quoted , RuntimeData } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>chat_app &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , users_stream : RuntimeData &lt; UnboundedReceiverStream &lt; u32 &gt; &gt; , messages : RuntimeData &lt; UnboundedReceiverStream &lt; String &gt; &gt; , output : RuntimeData &lt; &amp; <span class="lifetime">'a </span>UnboundedSender &lt; (u32 , String) &gt; &gt; , replay_messages : bool ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span>process = flow . process (&amp; ()) ; <span class="kw">let </span>users = flow . source_stream (&amp; process , users_stream) . all_ticks () ; <span class="kw">let </span>messages = flow . source_stream (&amp; process , messages) ; <span class="kw">let </span>messages = <span class="kw">if </span>replay_messages { messages . all_ticks () } <span class="kw">else </span>{ messages . tick_batch () } ; <span class="kw">let </span>messages = messages . map (q ! (| s | s . to_uppercase ())) ; <span class="kw">let </span><span class="kw-2">mut </span>joined = users . cross_product (messages) ; <span class="kw">if </span>replay_messages { joined = joined . delta () ; } joined . for_each (q ! (| t | { output . send (t) . unwrap () ; })) ; flow . extract () . optimize_default () } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>hydroflow_plus :: assert_graphvis_snapshots ; <span class="kw">use </span>hydroflow_plus :: util :: collect_ready ; # [test] <span class="kw">fn </span>test_chat_app_no_replay () { <span class="kw">let </span>(users_send , users) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(messages_send , messages) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>chat_server = <span class="kw">super </span>:: chat_app ! (users , messages , &amp; out , <span class="bool-val">false</span>) ; assert_graphvis_snapshots ! (chat_server) ; users_send . send (<span class="number">1</span>) . unwrap () ; users_send . send (<span class="number">2</span>) . unwrap () ; messages_send . send (<span class="string">"hello" </span>. to_string ()) . unwrap () ; messages_send . send (<span class="string">"world" </span>. to_string ()) . unwrap () ; chat_server . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [(<span class="number">1 </span>, <span class="string">"HELLO" </span>. to_string ()) , (<span class="number">2 </span>, <span class="string">"HELLO" </span>. to_string ()) , (<span class="number">1 </span>, <span class="string">"WORLD" </span>. to_string ()) , (<span class="number">2 </span>, <span class="string">"WORLD" </span>. to_string ())]) ; users_send . send (<span class="number">3</span>) . unwrap () ; messages_send . send (<span class="string">"goodbye" </span>. to_string ()) . unwrap () ; chat_server . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [(<span class="number">1 </span>, <span class="string">"GOODBYE" </span>. to_string ()) , (<span class="number">2 </span>, <span class="string">"GOODBYE" </span>. to_string ()) , (<span class="number">3 </span>, <span class="string">"GOODBYE" </span>. to_string ())]) ; } # [test] <span class="kw">fn </span>test_chat_app_replay () { <span class="kw">let </span>(users_send , users) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(messages_send , messages) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>chat_server = <span class="kw">super </span>:: chat_app ! (users , messages , &amp; out , <span class="bool-val">true</span>) ; assert_graphvis_snapshots ! (chat_server) ; users_send . send (<span class="number">1</span>) . unwrap () ; users_send . send (<span class="number">2</span>) . unwrap () ; messages_send . send (<span class="string">"hello" </span>. to_string ()) . unwrap () ; messages_send . send (<span class="string">"world" </span>. to_string ()) . unwrap () ; chat_server . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [(<span class="number">1 </span>, <span class="string">"HELLO" </span>. to_string ()) , (<span class="number">2 </span>, <span class="string">"HELLO" </span>. to_string ()) , (<span class="number">1 </span>, <span class="string">"WORLD" </span>. to_string ()) , (<span class="number">2 </span>, <span class="string">"WORLD" </span>. to_string ())]) ; users_send . send (<span class="number">3</span>) . unwrap () ; messages_send . send (<span class="string">"goodbye" </span>. to_string ()) . unwrap () ; chat_server . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [(<span class="number">3 </span>, <span class="string">"HELLO" </span>. to_string ()) , (<span class="number">3 </span>, <span class="string">"WORLD" </span>. to_string ()) , (<span class="number">1 </span>, <span class="string">"GOODBYE" </span>. to_string ()) , (<span class="number">2 </span>, <span class="string">"GOODBYE" </span>. to_string ()) , (<span class="number">3 </span>, <span class="string">"GOODBYE" </span>. to_string ())]) ; } } } <span class="kw">pub mod </span>compute_pi { <span class="kw">pub use </span>std :: time :: Duration ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub fn </span>compute_pi &lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; , batch_size : RuntimeData &lt; &amp; <span class="lifetime">'a </span>usize &gt; ,) -&gt; D :: Process { <span class="kw">let </span>process = flow . process (process_spec) ; <span class="kw">let </span>trials = flow . spin_batch (&amp; process , q ! (* batch_size)) . map (q ! (| <span class="kw">_ </span>| rand :: random ::&lt; (f64 , f64) &gt; ())) . map (q ! (| (x , y) | x * x + y * y &lt; <span class="number">1.0</span>)) . fold (q ! (|| (<span class="number">0u64 </span>, <span class="number">0u64</span>)) , q ! (| (inside , total) , sample_inside | { <span class="kw">if </span>sample_inside { * inside += <span class="number">1 </span>; } * total += <span class="number">1 </span>; }) ,) ; trials . all_ticks () . reduce (q ! (| (inside , total) , (inside_batch , total_batch) | { * inside += inside_batch ; * total += total_batch ; })) . sample_every (q ! (Duration :: from_secs (<span class="number">1</span>))) . for_each (q ! (| (inside , total) | { println ! (<span class="string">"pi: {} ({} trials)" </span>, <span class="number">4.0 </span>* inside <span class="kw">as </span>f64 / total <span class="kw">as </span>f64 , total) ; })) ; process } # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>compute_pi_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , batch_size : RuntimeData &lt; &amp; <span class="lifetime">'a </span>usize &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= compute_pi (&amp; flow , &amp; () , batch_size) ; flow . extract () . optimize_default () } } <span class="kw">pub mod </span>count_elems { <span class="kw">pub use </span>hydroflow_plus :: tokio :: sync :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>hydroflow_plus :: tokio_stream :: wrappers :: UnboundedReceiverStream ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: { q , Quoted , RuntimeData } ; # [cfg (stageleft_macro)] # [stageleft :: entry (String)] <span class="kw">pub fn </span>count_elems &lt; <span class="lifetime">'a </span>, T : <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , input_stream : RuntimeData &lt; UnboundedReceiverStream &lt; T &gt; &gt; , output : RuntimeData &lt; &amp; <span class="lifetime">'a </span>UnboundedSender &lt; u32 &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span>process = flow . process (&amp; ()) ; <span class="kw">let </span>source = flow . source_stream (&amp; process , input_stream) ; <span class="kw">let </span>count = source . map (q ! (| <span class="kw">_ </span>| <span class="number">1</span>)) . tick_batch () . fold (q ! (|| <span class="number">0</span>) , q ! (| a , b | * a += b)) ; count . for_each (q ! (| v | { output . send (v) . unwrap () ; })) ; flow . extract () . optimize_default () } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>hydroflow_plus :: assert_graphvis_snapshots ; <span class="kw">use </span>hydroflow_plus :: util :: collect_ready ; # [test] <span class="kw">pub fn </span>test_count () { <span class="kw">let </span>(in_send , input) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>count = <span class="kw">super </span>:: count_elems ! (input , &amp; out) ; assert_graphvis_snapshots ! (count) ; in_send . send (<span class="number">1</span>) . unwrap () ; in_send . send (<span class="number">1</span>) . unwrap () ; in_send . send (<span class="number">1</span>) . unwrap () ; count . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">3</span>]) ; } } } <span class="kw">pub mod </span>first_ten { <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub fn </span>first_ten &lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) { <span class="kw">let </span>process = flow . process (process_spec) ; <span class="kw">let </span>numbers = flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">10</span>)) ; numbers . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; } # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>first_ten_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { first_ten (&amp; flow , &amp; ()) ; flow . extract () . optimize_default () } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { # [test] <span class="kw">fn </span>instantiate_first_ten () { <span class="kw">let _ </span>= <span class="kw">super </span>:: first_ten_runtime ! () ; } } } <span class="kw">pub mod </span>graph_reachability { <span class="kw">pub use </span>hydroflow_plus :: tokio :: sync :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>hydroflow_plus :: tokio_stream :: wrappers :: UnboundedReceiverStream ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>graph_reachability &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , roots : RuntimeData &lt; UnboundedReceiverStream &lt; u32 &gt; &gt; , edges : RuntimeData &lt; UnboundedReceiverStream &lt; (u32 , u32) &gt; &gt; , reached_out : RuntimeData &lt; &amp; <span class="lifetime">'a </span>UnboundedSender &lt; u32 &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span>process = flow . process (&amp; ()) ; <span class="kw">let </span>roots = flow . source_stream (&amp; process , roots) ; <span class="kw">let </span>edges = flow . source_stream (&amp; process , edges) ; <span class="kw">let </span>(set_reached_cycle , reached_cycle) = flow . cycle (&amp; process) ; <span class="kw">let </span>reached = roots . union (reached_cycle) ; <span class="kw">let </span>reachable = reached . clone () . map (q ! (| r | (r , ()))) . join (edges) . map (q ! (| (_from , (<span class="kw">_ </span>, to)) | to)) ; set_reached_cycle . complete (reachable) ; reached . tick_batch () . unique () . for_each (q ! (| v | { reached_out . send (v) . unwrap () ; })) ; flow . extract () . optimize_default () } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>hydroflow_plus :: assert_graphvis_snapshots ; <span class="kw">use </span>hydroflow_plus :: util :: collect_ready ; # [test] <span class="kw">pub fn </span>test_reachability () { <span class="kw">let </span>(roots_send , roots) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(edges_send , edges) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>reachability = <span class="kw">super </span>:: graph_reachability ! (roots , edges , &amp; out) ; assert_graphvis_snapshots ! (reachability) ; roots_send . send (<span class="number">1</span>) . unwrap () ; roots_send . send (<span class="number">2</span>) . unwrap () ; edges_send . send ((<span class="number">1 </span>, <span class="number">2</span>)) . unwrap () ; edges_send . send ((<span class="number">2 </span>, <span class="number">3</span>)) . unwrap () ; edges_send . send ((<span class="number">3 </span>, <span class="number">4</span>)) . unwrap () ; edges_send . send ((<span class="number">4 </span>, <span class="number">5</span>)) . unwrap () ; reachability . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">1 </span>, <span class="number">2 </span>, <span class="number">3 </span>, <span class="number">4 </span>, <span class="number">5</span>]) ; } } } <span class="kw">pub mod </span>negation { <span class="kw">pub use </span>hydroflow_plus :: tokio :: sync :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: { q , Quoted , RuntimeData } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>test_difference &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , output : RuntimeData &lt; &amp; <span class="lifetime">'a </span>UnboundedSender &lt; u32 &gt; &gt; , persist1 : bool , persist2 : bool ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span>process = flow . process (&amp; ()) ; <span class="kw">let </span><span class="kw-2">mut </span>source = flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">5</span>)) ; <span class="kw">if </span>persist1 { source = source . all_ticks () ; } <span class="kw">let </span><span class="kw-2">mut </span>source2 = flow . source_iter (&amp; process , q ! (<span class="number">3 </span>.. <span class="number">6</span>)) ; <span class="kw">if </span>persist2 { source2 = source2 . all_ticks () ; } source . filter_not_in (source2) . for_each (q ! (| v | { output . send (v) . unwrap () ; })) ; flow . extract () . optimize_default () } # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>test_anti_join &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , output : RuntimeData &lt; &amp; <span class="lifetime">'a </span>UnboundedSender &lt; u32 &gt; &gt; , persist1 : bool , persist2 : bool ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span>process = flow . process (&amp; ()) ; <span class="kw">let </span><span class="kw-2">mut </span>source = flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">5</span>)) . map (q ! (| v | (v , v))) ; <span class="kw">if </span>persist1 { source = source . all_ticks () ; } <span class="kw">let </span><span class="kw-2">mut </span>source2 = flow . source_iter (&amp; process , q ! (<span class="number">3 </span>.. <span class="number">6</span>)) ; <span class="kw">if </span>persist2 { source2 = source2 . all_ticks () ; } source . anti_join (source2) . for_each (q ! (| v : (u32 , u32) | { output . send (v . <span class="number">0</span>) . unwrap () ; })) ; flow . extract () . optimize_default () } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>hydroflow_plus :: assert_graphvis_snapshots ; <span class="kw">use </span>hydroflow_plus :: util :: collect_ready ; # [test] <span class="kw">fn </span>test_difference_tick_tick () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_difference ! (&amp; out , <span class="bool-val">false </span>, <span class="bool-val">false</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [] <span class="kw">as </span>&amp; [u32]) ; } # [test] <span class="kw">fn </span>test_difference_tick_static () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_difference ! (&amp; out , <span class="bool-val">false </span>, <span class="bool-val">true</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [] <span class="kw">as </span>&amp; [u32]) ; } # [test] <span class="kw">fn </span>test_difference_static_tick () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_difference ! (&amp; out , <span class="bool-val">true </span>, <span class="bool-val">false</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2 </span>, <span class="number">3 </span>, <span class="number">4</span>]) ; } # [test] <span class="kw">fn </span>test_difference_static_static () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_difference ! (&amp; out , <span class="bool-val">true </span>, <span class="bool-val">true</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; } # [test] <span class="kw">fn </span>test_anti_join_tick_tick () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_anti_join ! (&amp; out , <span class="bool-val">false </span>, <span class="bool-val">false</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [] <span class="kw">as </span>&amp; [u32]) ; } # [test] <span class="kw">fn </span>test_anti_join_tick_static () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_anti_join ! (&amp; out , <span class="bool-val">false </span>, <span class="bool-val">true</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [] <span class="kw">as </span>&amp; [u32]) ; } # [test] <span class="kw">fn </span>test_anti_join_static_tick () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_anti_join ! (&amp; out , <span class="bool-val">true </span>, <span class="bool-val">false</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2 </span>, <span class="number">3 </span>, <span class="number">4</span>]) ; } # [test] <span class="kw">fn </span>test_anti_join_static_static () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_anti_join ! (&amp; out , <span class="bool-val">true </span>, <span class="bool-val">true</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; } } } <span class="kw">pub mod </span>teed_join { <span class="kw">pub use </span>hydroflow_plus :: futures :: stream :: Stream ; <span class="kw">pub use </span>hydroflow_plus :: tokio :: sync :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>hydroflow_plus :: tokio_stream :: wrappers :: UnboundedReceiverStream ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: { q , Quoted , RuntimeData } ; # [cfg (stageleft_macro)] # [stageleft :: entry (UnboundedReceiverStream &lt; u32 &gt;)] <span class="kw">pub fn </span>teed_join &lt; <span class="lifetime">'a </span>, S : Stream &lt; Item = u32 &gt; + Unpin + <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, MultiGraph &gt; , input_stream : RuntimeData &lt; S &gt; , output : RuntimeData &lt; &amp; <span class="lifetime">'a </span>UnboundedSender &lt; u32 &gt; &gt; , send_twice : bool , subgraph_id : RuntimeData &lt; usize &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span>node_zero = flow . process (&amp; ()) ; <span class="kw">let </span>node_one = flow . process (&amp; ()) ; <span class="kw">let </span>source = flow . source_stream (&amp; node_zero , input_stream) ; <span class="kw">let </span>map1 = source . clone () . map (q ! (| v | (v + <span class="number">1 </span>, ()))) ; <span class="kw">let </span>map2 = source . map (q ! (| v | (v - <span class="number">1 </span>, ()))) ; <span class="kw">let </span>joined = map1 . join (map2) . map (q ! (| t | t . <span class="number">0</span>)) ; joined . clone () . for_each (q ! (| v | { output . send (v) . unwrap () ; })) ; <span class="kw">if </span>send_twice { joined . for_each (q ! (| v | { output . send (v) . unwrap () ; })) ; } <span class="kw">let </span>source_node_id_1 = flow . source_iter (&amp; node_one , q ! (<span class="number">0 </span>.. <span class="number">5</span>)) ; source_node_id_1 . for_each (q ! (| v | { output . send (v) . unwrap () ; })) ; flow . extract () . optimize_default () . with_dynamic_id (subgraph_id) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>hydroflow_plus :: assert_graphvis_snapshots ; <span class="kw">use </span>hydroflow_plus :: util :: collect_ready ; # [test] <span class="kw">fn </span>test_teed_join () { <span class="kw">let </span>(in_send , input) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>joined = <span class="kw">super </span>:: teed_join ! (input , &amp; out , <span class="bool-val">false </span>, <span class="number">0</span>) ; assert_graphvis_snapshots ! (joined) ; in_send . send (<span class="number">1</span>) . unwrap () ; in_send . send (<span class="number">2</span>) . unwrap () ; in_send . send (<span class="number">3</span>) . unwrap () ; in_send . send (<span class="number">4</span>) . unwrap () ; joined . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">2 </span>, <span class="number">3</span>]) ; } # [test] <span class="kw">fn </span>test_teed_join_twice () { <span class="kw">let </span>(in_send , input) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>joined = <span class="kw">super </span>:: teed_join ! (input , &amp; out , <span class="bool-val">true </span>, <span class="number">0</span>) ; assert_graphvis_snapshots ! (joined) ; in_send . send (<span class="number">1</span>) . unwrap () ; in_send . send (<span class="number">2</span>) . unwrap () ; in_send . send (<span class="number">3</span>) . unwrap () ; in_send . send (<span class="number">4</span>) . unwrap () ; joined . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">2 </span>, <span class="number">2 </span>, <span class="number">3 </span>, <span class="number">3</span>]) ; } # [test] <span class="kw">fn </span>test_teed_join_multi_node () { <span class="kw">let </span>(<span class="kw">_ </span>, input) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>joined = <span class="kw">super </span>:: teed_join ! (input , &amp; out , <span class="bool-val">true </span>, <span class="number">1</span>) ; assert_graphvis_snapshots ! (joined) ; joined . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2 </span>, <span class="number">3 </span>, <span class="number">4</span>]) ; } } } } # [cfg (not (stageleft_macro))] <span class="kw">pub mod </span>local { <span class="kw">pub mod </span>chat_app { <span class="kw">pub use </span>hydroflow_plus :: tokio :: sync :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>hydroflow_plus :: tokio_stream :: wrappers :: UnboundedReceiverStream ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: { q , Quoted , RuntimeData } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>chat_app &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , users_stream : RuntimeData &lt; UnboundedReceiverStream &lt; u32 &gt; &gt; , messages : RuntimeData &lt; UnboundedReceiverStream &lt; String &gt; &gt; , output : RuntimeData &lt; &amp; <span class="lifetime">'a </span>UnboundedSender &lt; (u32 , String) &gt; &gt; , replay_messages : bool ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span>process = flow . process (&amp; ()) ; <span class="kw">let </span>users = flow . source_stream (&amp; process , users_stream) . all_ticks () ; <span class="kw">let </span>messages = flow . source_stream (&amp; process , messages) ; <span class="kw">let </span>messages = <span class="kw">if </span>replay_messages { messages . all_ticks () } <span class="kw">else </span>{ messages . tick_batch () } ; <span class="kw">let </span>messages = messages . map (q ! (| s | s . to_uppercase ())) ; <span class="kw">let </span><span class="kw-2">mut </span>joined = users . cross_product (messages) ; <span class="kw">if </span>replay_messages { joined = joined . delta () ; } joined . for_each (q ! (| t | { output . send (t) . unwrap () ; })) ; flow . extract () . optimize_default () } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>hydroflow_plus :: assert_graphvis_snapshots ; <span class="kw">use </span>hydroflow_plus :: util :: collect_ready ; # [test] <span class="kw">fn </span>test_chat_app_no_replay () { <span class="kw">let </span>(users_send , users) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(messages_send , messages) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>chat_server = <span class="kw">super </span>:: chat_app ! (users , messages , &amp; out , <span class="bool-val">false</span>) ; assert_graphvis_snapshots ! (chat_server) ; users_send . send (<span class="number">1</span>) . unwrap () ; users_send . send (<span class="number">2</span>) . unwrap () ; messages_send . send (<span class="string">"hello" </span>. to_string ()) . unwrap () ; messages_send . send (<span class="string">"world" </span>. to_string ()) . unwrap () ; chat_server . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [(<span class="number">1 </span>, <span class="string">"HELLO" </span>. to_string ()) , (<span class="number">2 </span>, <span class="string">"HELLO" </span>. to_string ()) , (<span class="number">1 </span>, <span class="string">"WORLD" </span>. to_string ()) , (<span class="number">2 </span>, <span class="string">"WORLD" </span>. to_string ())]) ; users_send . send (<span class="number">3</span>) . unwrap () ; messages_send . send (<span class="string">"goodbye" </span>. to_string ()) . unwrap () ; chat_server . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [(<span class="number">1 </span>, <span class="string">"GOODBYE" </span>. to_string ()) , (<span class="number">2 </span>, <span class="string">"GOODBYE" </span>. to_string ()) , (<span class="number">3 </span>, <span class="string">"GOODBYE" </span>. to_string ())]) ; } # [test] <span class="kw">fn </span>test_chat_app_replay () { <span class="kw">let </span>(users_send , users) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(messages_send , messages) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>chat_server = <span class="kw">super </span>:: chat_app ! (users , messages , &amp; out , <span class="bool-val">true</span>) ; assert_graphvis_snapshots ! (chat_server) ; users_send . send (<span class="number">1</span>) . unwrap () ; users_send . send (<span class="number">2</span>) . unwrap () ; messages_send . send (<span class="string">"hello" </span>. to_string ()) . unwrap () ; messages_send . send (<span class="string">"world" </span>. to_string ()) . unwrap () ; chat_server . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [(<span class="number">1 </span>, <span class="string">"HELLO" </span>. to_string ()) , (<span class="number">2 </span>, <span class="string">"HELLO" </span>. to_string ()) , (<span class="number">1 </span>, <span class="string">"WORLD" </span>. to_string ()) , (<span class="number">2 </span>, <span class="string">"WORLD" </span>. to_string ())]) ; users_send . send (<span class="number">3</span>) . unwrap () ; messages_send . send (<span class="string">"goodbye" </span>. to_string ()) . unwrap () ; chat_server . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [(<span class="number">3 </span>, <span class="string">"HELLO" </span>. to_string ()) , (<span class="number">3 </span>, <span class="string">"WORLD" </span>. to_string ()) , (<span class="number">1 </span>, <span class="string">"GOODBYE" </span>. to_string ()) , (<span class="number">2 </span>, <span class="string">"GOODBYE" </span>. to_string ()) , (<span class="number">3 </span>, <span class="string">"GOODBYE" </span>. to_string ())]) ; } } } <span class="kw">pub mod </span>compute_pi { <span class="kw">pub use </span>std :: time :: Duration ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub fn </span>compute_pi &lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; , batch_size : RuntimeData &lt; &amp; <span class="lifetime">'a </span>usize &gt; ,) -&gt; D :: Process { <span class="kw">let </span>process = flow . process (process_spec) ; <span class="kw">let </span>trials = flow . spin_batch (&amp; process , q ! (* batch_size)) . map (q ! (| <span class="kw">_ </span>| rand :: random ::&lt; (f64 , f64) &gt; ())) . map (q ! (| (x , y) | x * x + y * y &lt; <span class="number">1.0</span>)) . fold (q ! (|| (<span class="number">0u64 </span>, <span class="number">0u64</span>)) , q ! (| (inside , total) , sample_inside | { <span class="kw">if </span>sample_inside { * inside += <span class="number">1 </span>; } * total += <span class="number">1 </span>; }) ,) ; trials . all_ticks () . reduce (q ! (| (inside , total) , (inside_batch , total_batch) | { * inside += inside_batch ; * total += total_batch ; })) . sample_every (q ! (Duration :: from_secs (<span class="number">1</span>))) . for_each (q ! (| (inside , total) | { println ! (<span class="string">"pi: {} ({} trials)" </span>, <span class="number">4.0 </span>* inside <span class="kw">as </span>f64 / total <span class="kw">as </span>f64 , total) ; })) ; process } # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>compute_pi_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , batch_size : RuntimeData &lt; &amp; <span class="lifetime">'a </span>usize &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= compute_pi (&amp; flow , &amp; () , batch_size) ; flow . extract () . optimize_default () } } <span class="kw">pub mod </span>count_elems { <span class="kw">pub use </span>hydroflow_plus :: tokio :: sync :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>hydroflow_plus :: tokio_stream :: wrappers :: UnboundedReceiverStream ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: { q , Quoted , RuntimeData } ; # [cfg (stageleft_macro)] # [stageleft :: entry (String)] <span class="kw">pub fn </span>count_elems &lt; <span class="lifetime">'a </span>, T : <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , input_stream : RuntimeData &lt; UnboundedReceiverStream &lt; T &gt; &gt; , output : RuntimeData &lt; &amp; <span class="lifetime">'a </span>UnboundedSender &lt; u32 &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span>process = flow . process (&amp; ()) ; <span class="kw">let </span>source = flow . source_stream (&amp; process , input_stream) ; <span class="kw">let </span>count = source . map (q ! (| <span class="kw">_ </span>| <span class="number">1</span>)) . tick_batch () . fold (q ! (|| <span class="number">0</span>) , q ! (| a , b | * a += b)) ; count . for_each (q ! (| v | { output . send (v) . unwrap () ; })) ; flow . extract () . optimize_default () } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>hydroflow_plus :: assert_graphvis_snapshots ; <span class="kw">use </span>hydroflow_plus :: util :: collect_ready ; # [test] <span class="kw">pub fn </span>test_count () { <span class="kw">let </span>(in_send , input) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>count = <span class="kw">super </span>:: count_elems ! (input , &amp; out) ; assert_graphvis_snapshots ! (count) ; in_send . send (<span class="number">1</span>) . unwrap () ; in_send . send (<span class="number">1</span>) . unwrap () ; in_send . send (<span class="number">1</span>) . unwrap () ; count . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">3</span>]) ; } } } <span class="kw">pub mod </span>first_ten { <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub fn </span>first_ten &lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) { <span class="kw">let </span>process = flow . process (process_spec) ; <span class="kw">let </span>numbers = flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">10</span>)) ; numbers . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; } # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>first_ten_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { first_ten (&amp; flow , &amp; ()) ; flow . extract () . optimize_default () } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { # [test] <span class="kw">fn </span>instantiate_first_ten () { <span class="kw">let _ </span>= <span class="kw">super </span>:: first_ten_runtime ! () ; } } } <span class="kw">pub mod </span>graph_reachability { <span class="kw">pub use </span>hydroflow_plus :: tokio :: sync :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>hydroflow_plus :: tokio_stream :: wrappers :: UnboundedReceiverStream ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: * ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>graph_reachability &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , roots : RuntimeData &lt; UnboundedReceiverStream &lt; u32 &gt; &gt; , edges : RuntimeData &lt; UnboundedReceiverStream &lt; (u32 , u32) &gt; &gt; , reached_out : RuntimeData &lt; &amp; <span class="lifetime">'a </span>UnboundedSender &lt; u32 &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span>process = flow . process (&amp; ()) ; <span class="kw">let </span>roots = flow . source_stream (&amp; process , roots) ; <span class="kw">let </span>edges = flow . source_stream (&amp; process , edges) ; <span class="kw">let </span>(set_reached_cycle , reached_cycle) = flow . cycle (&amp; process) ; <span class="kw">let </span>reached = roots . union (reached_cycle) ; <span class="kw">let </span>reachable = reached . clone () . map (q ! (| r | (r , ()))) . join (edges) . map (q ! (| (_from , (<span class="kw">_ </span>, to)) | to)) ; set_reached_cycle . complete (reachable) ; reached . tick_batch () . unique () . for_each (q ! (| v | { reached_out . send (v) . unwrap () ; })) ; flow . extract () . optimize_default () } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>hydroflow_plus :: assert_graphvis_snapshots ; <span class="kw">use </span>hydroflow_plus :: util :: collect_ready ; # [test] <span class="kw">pub fn </span>test_reachability () { <span class="kw">let </span>(roots_send , roots) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(edges_send , edges) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>reachability = <span class="kw">super </span>:: graph_reachability ! (roots , edges , &amp; out) ; assert_graphvis_snapshots ! (reachability) ; roots_send . send (<span class="number">1</span>) . unwrap () ; roots_send . send (<span class="number">2</span>) . unwrap () ; edges_send . send ((<span class="number">1 </span>, <span class="number">2</span>)) . unwrap () ; edges_send . send ((<span class="number">2 </span>, <span class="number">3</span>)) . unwrap () ; edges_send . send ((<span class="number">3 </span>, <span class="number">4</span>)) . unwrap () ; edges_send . send ((<span class="number">4 </span>, <span class="number">5</span>)) . unwrap () ; reachability . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">1 </span>, <span class="number">2 </span>, <span class="number">3 </span>, <span class="number">4 </span>, <span class="number">5</span>]) ; } } } <span class="kw">pub mod </span>negation { <span class="kw">pub use </span>hydroflow_plus :: tokio :: sync :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: { q , Quoted , RuntimeData } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>test_difference &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , output : RuntimeData &lt; &amp; <span class="lifetime">'a </span>UnboundedSender &lt; u32 &gt; &gt; , persist1 : bool , persist2 : bool ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span>process = flow . process (&amp; ()) ; <span class="kw">let </span><span class="kw-2">mut </span>source = flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">5</span>)) ; <span class="kw">if </span>persist1 { source = source . all_ticks () ; } <span class="kw">let </span><span class="kw-2">mut </span>source2 = flow . source_iter (&amp; process , q ! (<span class="number">3 </span>.. <span class="number">6</span>)) ; <span class="kw">if </span>persist2 { source2 = source2 . all_ticks () ; } source . filter_not_in (source2) . for_each (q ! (| v | { output . send (v) . unwrap () ; })) ; flow . extract () . optimize_default () } # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>test_anti_join &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; , output : RuntimeData &lt; &amp; <span class="lifetime">'a </span>UnboundedSender &lt; u32 &gt; &gt; , persist1 : bool , persist2 : bool ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span>process = flow . process (&amp; ()) ; <span class="kw">let </span><span class="kw-2">mut </span>source = flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">5</span>)) . map (q ! (| v | (v , v))) ; <span class="kw">if </span>persist1 { source = source . all_ticks () ; } <span class="kw">let </span><span class="kw-2">mut </span>source2 = flow . source_iter (&amp; process , q ! (<span class="number">3 </span>.. <span class="number">6</span>)) ; <span class="kw">if </span>persist2 { source2 = source2 . all_ticks () ; } source . anti_join (source2) . for_each (q ! (| v : (u32 , u32) | { output . send (v . <span class="number">0</span>) . unwrap () ; })) ; flow . extract () . optimize_default () } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>hydroflow_plus :: assert_graphvis_snapshots ; <span class="kw">use </span>hydroflow_plus :: util :: collect_ready ; # [test] <span class="kw">fn </span>test_difference_tick_tick () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_difference ! (&amp; out , <span class="bool-val">false </span>, <span class="bool-val">false</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [] <span class="kw">as </span>&amp; [u32]) ; } # [test] <span class="kw">fn </span>test_difference_tick_static () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_difference ! (&amp; out , <span class="bool-val">false </span>, <span class="bool-val">true</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [] <span class="kw">as </span>&amp; [u32]) ; } # [test] <span class="kw">fn </span>test_difference_static_tick () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_difference ! (&amp; out , <span class="bool-val">true </span>, <span class="bool-val">false</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2 </span>, <span class="number">3 </span>, <span class="number">4</span>]) ; } # [test] <span class="kw">fn </span>test_difference_static_static () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_difference ! (&amp; out , <span class="bool-val">true </span>, <span class="bool-val">true</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; } # [test] <span class="kw">fn </span>test_anti_join_tick_tick () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_anti_join ! (&amp; out , <span class="bool-val">false </span>, <span class="bool-val">false</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [] <span class="kw">as </span>&amp; [u32]) ; } # [test] <span class="kw">fn </span>test_anti_join_tick_static () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_anti_join ! (&amp; out , <span class="bool-val">false </span>, <span class="bool-val">true</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [] <span class="kw">as </span>&amp; [u32]) ; } # [test] <span class="kw">fn </span>test_anti_join_static_tick () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_anti_join ! (&amp; out , <span class="bool-val">true </span>, <span class="bool-val">false</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2 </span>, <span class="number">3 </span>, <span class="number">4</span>]) ; } # [test] <span class="kw">fn </span>test_anti_join_static_static () { <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>flow = <span class="kw">super </span>:: test_anti_join ! (&amp; out , <span class="bool-val">true </span>, <span class="bool-val">true</span>) ; assert_graphvis_snapshots ! (flow) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; flow . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2</span>]) ; } } } <span class="kw">pub mod </span>teed_join { <span class="kw">pub use </span>hydroflow_plus :: futures :: stream :: Stream ; <span class="kw">pub use </span>hydroflow_plus :: tokio :: sync :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>hydroflow_plus :: tokio_stream :: wrappers :: UnboundedReceiverStream ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>stageleft :: { q , Quoted , RuntimeData } ; # [cfg (stageleft_macro)] # [stageleft :: entry (UnboundedReceiverStream &lt; u32 &gt;)] <span class="kw">pub fn </span>teed_join &lt; <span class="lifetime">'a </span>, S : Stream &lt; Item = u32 &gt; + Unpin + <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, MultiGraph &gt; , input_stream : RuntimeData &lt; S &gt; , output : RuntimeData &lt; &amp; <span class="lifetime">'a </span>UnboundedSender &lt; u32 &gt; &gt; , send_twice : bool , subgraph_id : RuntimeData &lt; usize &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span>node_zero = flow . process (&amp; ()) ; <span class="kw">let </span>node_one = flow . process (&amp; ()) ; <span class="kw">let </span>source = flow . source_stream (&amp; node_zero , input_stream) ; <span class="kw">let </span>map1 = source . clone () . map (q ! (| v | (v + <span class="number">1 </span>, ()))) ; <span class="kw">let </span>map2 = source . map (q ! (| v | (v - <span class="number">1 </span>, ()))) ; <span class="kw">let </span>joined = map1 . join (map2) . map (q ! (| t | t . <span class="number">0</span>)) ; joined . clone () . for_each (q ! (| v | { output . send (v) . unwrap () ; })) ; <span class="kw">if </span>send_twice { joined . for_each (q ! (| v | { output . send (v) . unwrap () ; })) ; } <span class="kw">let </span>source_node_id_1 = flow . source_iter (&amp; node_one , q ! (<span class="number">0 </span>.. <span class="number">5</span>)) ; source_node_id_1 . for_each (q ! (| v | { output . send (v) . unwrap () ; })) ; flow . extract () . optimize_default () . with_dynamic_id (subgraph_id) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>hydroflow_plus :: assert_graphvis_snapshots ; <span class="kw">use </span>hydroflow_plus :: util :: collect_ready ; # [test] <span class="kw">fn </span>test_teed_join () { <span class="kw">let </span>(in_send , input) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>joined = <span class="kw">super </span>:: teed_join ! (input , &amp; out , <span class="bool-val">false </span>, <span class="number">0</span>) ; assert_graphvis_snapshots ! (joined) ; in_send . send (<span class="number">1</span>) . unwrap () ; in_send . send (<span class="number">2</span>) . unwrap () ; in_send . send (<span class="number">3</span>) . unwrap () ; in_send . send (<span class="number">4</span>) . unwrap () ; joined . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">2 </span>, <span class="number">3</span>]) ; } # [test] <span class="kw">fn </span>test_teed_join_twice () { <span class="kw">let </span>(in_send , input) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>joined = <span class="kw">super </span>:: teed_join ! (input , &amp; out , <span class="bool-val">true </span>, <span class="number">0</span>) ; assert_graphvis_snapshots ! (joined) ; in_send . send (<span class="number">1</span>) . unwrap () ; in_send . send (<span class="number">2</span>) . unwrap () ; in_send . send (<span class="number">3</span>) . unwrap () ; in_send . send (<span class="number">4</span>) . unwrap () ; joined . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">2 </span>, <span class="number">2 </span>, <span class="number">3 </span>, <span class="number">3</span>]) ; } # [test] <span class="kw">fn </span>test_teed_join_multi_node () { <span class="kw">let </span>(<span class="kw">_ </span>, input) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span>(out , <span class="kw-2">mut </span>out_recv) = hydroflow_plus :: util :: unbounded_channel () ; <span class="kw">let </span><span class="kw-2">mut </span>joined = <span class="kw">super </span>:: teed_join ! (input , &amp; out , <span class="bool-val">true </span>, <span class="number">1</span>) ; assert_graphvis_snapshots ! (joined) ; joined . run_tick () ; assert_eq ! (<span class="kw-2">&amp;</span>* collect_ready ::&lt; Vec &lt; <span class="kw">_ </span>&gt;, <span class="kw">_ </span>&gt; (&amp; <span class="kw-2">mut </span>out_recv) , &amp; [<span class="number">0 </span>, <span class="number">1 </span>, <span class="number">2 </span>, <span class="number">3 </span>, <span class="number">4</span>]) ; } } } } # [cfg (stageleft_macro)] <span class="kw">pub mod </span>distributed { <span class="kw">pub mod </span>first_ten { <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>serde :: { Deserialize , Serialize } ; <span class="kw">pub use </span>stageleft :: * ; # [derive (Serialize , Deserialize)] <span class="kw">pub struct </span>SendOverNetwork { <span class="kw">pub </span>n : u32 , } <span class="kw">pub fn </span>first_ten_distributed &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; D :: Process { <span class="kw">let </span>process = flow . process (process_spec) ; <span class="kw">let </span>second_process = flow . process (process_spec) ; <span class="kw">let </span>numbers = flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">10</span>)) ; numbers . map (q ! (| n | SendOverNetwork { n })) . send_bincode (&amp; second_process) . for_each (q ! (| n : SendOverNetwork | println ! (<span class="string">"{}" </span>, n . n))) ; second_process } <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: HydroCLI ; <span class="kw">pub use </span>hydroflow_plus_cli_integration :: { CLIRuntime , HydroflowPlusMeta } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>first_ten_distributed_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= first_ten_distributed (&amp; flow , &amp; cli) ; flow . extract () . optimize_default () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>hydro_deploy :: { Deployment , HydroflowCrate } ; <span class="kw">use </span>hydroflow_plus_cli_integration :: { DeployCrateWrapper , DeployProcessSpec } ; # [tokio :: test] <span class="kw">async fn </span>first_ten_distributed () { <span class="kw">let </span><span class="kw-2">mut </span>deployment = Deployment :: new () ; <span class="kw">let </span>localhost = deployment . Localhost () ; <span class="kw">let </span>builder = hydroflow_plus :: FlowBuilder :: new () ; <span class="kw">let </span>second_node = <span class="kw">super </span>:: first_ten_distributed (&amp; builder , &amp; DeployProcessSpec :: new (| | { deployment . add_service (HydroflowCrate :: new (<span class="string">"." </span>, localhost . clone ()) . bin (<span class="string">"first_ten_distributed"</span>) . profile (<span class="string">"dev"</span>) ,) }) ,) ; <span class="kw">let </span>built = builder . extract () ; insta :: assert_debug_snapshot ! (built . ir ()) ; deployment . deploy () . <span class="kw">await </span>. unwrap () ; <span class="kw">let </span><span class="kw-2">mut </span>second_node_stdout = second_node . stdout () . <span class="kw">await </span>; deployment . start () . <span class="kw">await </span>. unwrap () ; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10 </span>{ assert_eq ! (second_node_stdout . recv () . <span class="kw">await </span>. unwrap () , i . to_string ()) ; } } } } <span class="kw">pub mod </span>networked { <span class="kw">pub use </span>hydroflow_plus :: bytes :: Bytes ; <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: HydroCLI ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>hydroflow_plus_cli_integration :: { CLIRuntime , HydroflowPlusMeta } ; <span class="kw">pub use </span>stageleft :: { q , Quoted , RuntimeData } ; <span class="kw">pub use crate </span>:: distributed :: networked :: NetworkedBasicIo ; <span class="kw">pub fn </span>networked_basic &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; , cluster_spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; NetworkedBasicIo &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">let </span>process_zero = flow . process (process_spec) ; <span class="kw">let </span>process_one = flow . process (process_spec) ; <span class="kw">let </span>(source_zero_port , source_zero) = flow . source_external (&amp; process_zero) ; source_zero . send_bytes (&amp; process_one) . for_each (q ! (| v : Bytes | { println ! (<span class="string">"node one received: {:?}" </span>, std :: str :: from_utf8 (&amp; v) . unwrap ()) ; })) ; <span class="kw">let </span>cluster = flow . cluster (cluster_spec) ; <span class="kw">let </span>(cluster_port , cluster_stream) = flow . many_source_external :: &lt; D :: Process , <span class="kw">_ </span>, <span class="kw">_ </span>&gt; (&amp; cluster) ; cluster_stream . for_each (q ! (| v : Bytes | { println ! (<span class="string">"cluster received: {:?}" </span>, std :: str :: from_utf8 (&amp; v) . unwrap ()) ; })) ; NetworkedBasicIo { source_zero_port , process_zero , process_one , cluster_port , cluster , } } # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>networked_basic_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= networked_basic (&amp; flow , &amp; cli , &amp; cli) ; flow . extract () . optimize_default () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>std :: cell :: RefCell ; <span class="kw">use </span>hydro_deploy :: { Deployment , HydroflowCrate } ; <span class="kw">use </span>hydroflow_plus :: futures :: SinkExt ; <span class="kw">use </span>hydroflow_plus :: util :: cli :: ConnectedSink ; <span class="kw">use </span>hydroflow_plus_cli_integration :: { DeployClusterSpec , DeployCrateWrapper , DeployProcessSpec , } ; # [tokio :: test] <span class="kw">async fn </span>networked_basic () { <span class="kw">let </span><span class="kw-2">mut </span>deployment = Deployment :: new () ; <span class="kw">let </span>localhost = deployment . Localhost () ; <span class="kw">let </span>builder = hydroflow_plus :: FlowBuilder :: new () ; <span class="kw">let </span>deployment = RefCell :: new (deployment) ; <span class="kw">let </span>io = <span class="kw">super </span>:: networked_basic (&amp; builder , &amp; DeployProcessSpec :: new (| | { deployment . borrow_mut () . add_service (HydroflowCrate :: new (<span class="string">"." </span>, localhost . clone ()) . bin (<span class="string">"networked_basic"</span>) . profile (<span class="string">"dev"</span>) ,) }) , &amp; DeployClusterSpec :: new (| | { vec ! [deployment . borrow_mut () . add_service (HydroflowCrate :: new (<span class="string">"." </span>, localhost . clone ()) . bin (<span class="string">"networked_basic"</span>) . profile (<span class="string">"dev"</span>) ,)] }) ,) ; insta :: assert_debug_snapshot ! (builder . extract () . ir ()) ; <span class="kw">let </span><span class="kw-2">mut </span>deployment = deployment . into_inner () ; <span class="kw">let </span>port_to_zero = io . source_zero_port . create_sender (&amp; <span class="kw-2">mut </span>deployment , &amp; localhost) . <span class="kw">await </span>; <span class="kw">let </span>ports_to_cluster = io . cluster_port . create_senders (&amp; <span class="kw-2">mut </span>deployment , &amp; localhost) . <span class="kw">await </span>; deployment . deploy () . <span class="kw">await </span>. unwrap () ; <span class="kw">let </span><span class="kw-2">mut </span>conn_to_zero = port_to_zero . connect () . <span class="kw">await </span>. into_sink () ; <span class="kw">let </span><span class="kw-2">mut </span>node_one_stdout = io . process_one . stdout () . <span class="kw">await </span>; <span class="kw">let </span><span class="kw-2">mut </span>conn_to_cluster = ports_to_cluster [<span class="number">0</span>] . connect () . <span class="kw">await </span>. into_sink () ; <span class="kw">let </span><span class="kw-2">mut </span>cluster_stdout = io . cluster . members [<span class="number">0</span>] . stdout () . <span class="kw">await </span>; deployment . start () . <span class="kw">await </span>. unwrap () ; conn_to_zero . send (<span class="string">"hello world!" </span>. into ()) . <span class="kw">await </span>. unwrap () ; conn_to_cluster . send (<span class="string">"hello cluster!" </span>. into ()) . <span class="kw">await </span>. unwrap () ; assert_eq ! (node_one_stdout . recv () . <span class="kw">await </span>. unwrap () , <span class="string">"node one received: \"hello world!\""</span>) ; assert_eq ! (cluster_stdout . recv () . <span class="kw">await </span>. unwrap () , <span class="string">"cluster received: \"hello cluster!\""</span>) ; } } } } # [cfg (not (stageleft_macro))] <span class="kw">pub mod </span>distributed { <span class="kw">pub mod </span>first_ten { <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>serde :: { Deserialize , Serialize } ; <span class="kw">pub use </span>stageleft :: * ; # [derive (Serialize , Deserialize)] <span class="kw">pub struct </span>SendOverNetwork { <span class="kw">pub </span>n : u32 , } <span class="kw">pub fn </span>first_ten_distributed &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; D :: Process { <span class="kw">let </span>process = flow . process (process_spec) ; <span class="kw">let </span>second_process = flow . process (process_spec) ; <span class="kw">let </span>numbers = flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">10</span>)) ; numbers . map (q ! (| n | SendOverNetwork { n })) . send_bincode (&amp; second_process) . for_each (q ! (| n : SendOverNetwork | println ! (<span class="string">"{}" </span>, n . n))) ; second_process } <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: HydroCLI ; <span class="kw">pub use </span>hydroflow_plus_cli_integration :: { CLIRuntime , HydroflowPlusMeta } ; # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>first_ten_distributed_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= first_ten_distributed (&amp; flow , &amp; cli) ; flow . extract () . optimize_default () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>hydro_deploy :: { Deployment , HydroflowCrate } ; <span class="kw">use </span>hydroflow_plus_cli_integration :: { DeployCrateWrapper , DeployProcessSpec } ; # [tokio :: test] <span class="kw">async fn </span>first_ten_distributed () { <span class="kw">let </span><span class="kw-2">mut </span>deployment = Deployment :: new () ; <span class="kw">let </span>localhost = deployment . Localhost () ; <span class="kw">let </span>builder = hydroflow_plus :: FlowBuilder :: new () ; <span class="kw">let </span>second_node = <span class="kw">super </span>:: first_ten_distributed (&amp; builder , &amp; DeployProcessSpec :: new (| | { deployment . add_service (HydroflowCrate :: new (<span class="string">"." </span>, localhost . clone ()) . bin (<span class="string">"first_ten_distributed"</span>) . profile (<span class="string">"dev"</span>) ,) }) ,) ; <span class="kw">let </span>built = builder . extract () ; insta :: assert_debug_snapshot ! (built . ir ()) ; deployment . deploy () . <span class="kw">await </span>. unwrap () ; <span class="kw">let </span><span class="kw-2">mut </span>second_node_stdout = second_node . stdout () . <span class="kw">await </span>; deployment . start () . <span class="kw">await </span>. unwrap () ; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10 </span>{ assert_eq ! (second_node_stdout . recv () . <span class="kw">await </span>. unwrap () , i . to_string ()) ; } } } } <span class="kw">pub mod </span>networked { <span class="kw">pub use </span>hydroflow_plus :: bytes :: Bytes ; <span class="kw">pub use </span>hydroflow_plus :: util :: cli :: HydroCLI ; <span class="kw">pub use </span>hydroflow_plus :: * ; <span class="kw">pub use </span>hydroflow_plus_cli_integration :: { CLIRuntime , HydroflowPlusMeta } ; <span class="kw">pub use </span>stageleft :: { q , Quoted , RuntimeData } ; <span class="kw">pub use crate </span>:: distributed :: networked :: NetworkedBasicIo ; <span class="kw">pub fn </span>networked_basic &lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; (flow : &amp; FlowBuilder &lt; <span class="lifetime">'a </span>, D &gt; , process_spec : &amp; <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; , cluster_spec : &amp; <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; NetworkedBasicIo &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">let </span>process_zero = flow . process (process_spec) ; <span class="kw">let </span>process_one = flow . process (process_spec) ; <span class="kw">let </span>(source_zero_port , source_zero) = flow . source_external (&amp; process_zero) ; source_zero . send_bytes (&amp; process_one) . for_each (q ! (| v : Bytes | { println ! (<span class="string">"node one received: {:?}" </span>, std :: str :: from_utf8 (&amp; v) . unwrap ()) ; })) ; <span class="kw">let </span>cluster = flow . cluster (cluster_spec) ; <span class="kw">let </span>(cluster_port , cluster_stream) = flow . many_source_external :: &lt; D :: Process , <span class="kw">_ </span>, <span class="kw">_ </span>&gt; (&amp; cluster) ; cluster_stream . for_each (q ! (| v : Bytes | { println ! (<span class="string">"cluster received: {:?}" </span>, std :: str :: from_utf8 (&amp; v) . unwrap ()) ; })) ; NetworkedBasicIo { source_zero_port , process_zero , process_one , cluster_port , cluster , } } # [cfg (stageleft_macro)] # [stageleft :: entry] <span class="kw">pub fn </span>networked_basic_runtime &lt; <span class="lifetime">'a </span>&gt; (flow : FlowBuilder &lt; <span class="lifetime">'a </span>, CLIRuntime &gt; , cli : RuntimeData &lt; &amp; <span class="lifetime">'a </span>HydroCLI &lt; HydroflowPlusMeta &gt; &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let _ </span>= networked_basic (&amp; flow , &amp; cli , &amp; cli) ; flow . extract () . optimize_default () . with_dynamic_id (q ! (cli . meta . subgraph_id)) } # [cfg (stageleft_macro)] # [stageleft :: runtime] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>std :: cell :: RefCell ; <span class="kw">use </span>hydro_deploy :: { Deployment , HydroflowCrate } ; <span class="kw">use </span>hydroflow_plus :: futures :: SinkExt ; <span class="kw">use </span>hydroflow_plus :: util :: cli :: ConnectedSink ; <span class="kw">use </span>hydroflow_plus_cli_integration :: { DeployClusterSpec , DeployCrateWrapper , DeployProcessSpec , } ; # [tokio :: test] <span class="kw">async fn </span>networked_basic () { <span class="kw">let </span><span class="kw-2">mut </span>deployment = Deployment :: new () ; <span class="kw">let </span>localhost = deployment . Localhost () ; <span class="kw">let </span>builder = hydroflow_plus :: FlowBuilder :: new () ; <span class="kw">let </span>deployment = RefCell :: new (deployment) ; <span class="kw">let </span>io = <span class="kw">super </span>:: networked_basic (&amp; builder , &amp; DeployProcessSpec :: new (| | { deployment . borrow_mut () . add_service (HydroflowCrate :: new (<span class="string">"." </span>, localhost . clone ()) . bin (<span class="string">"networked_basic"</span>) . profile (<span class="string">"dev"</span>) ,) }) , &amp; DeployClusterSpec :: new (| | { vec ! [deployment . borrow_mut () . add_service (HydroflowCrate :: new (<span class="string">"." </span>, localhost . clone ()) . bin (<span class="string">"networked_basic"</span>) . profile (<span class="string">"dev"</span>) ,)] }) ,) ; insta :: assert_debug_snapshot ! (builder . extract () . ir ()) ; <span class="kw">let </span><span class="kw-2">mut </span>deployment = deployment . into_inner () ; <span class="kw">let </span>port_to_zero = io . source_zero_port . create_sender (&amp; <span class="kw-2">mut </span>deployment , &amp; localhost) . <span class="kw">await </span>; <span class="kw">let </span>ports_to_cluster = io . cluster_port . create_senders (&amp; <span class="kw-2">mut </span>deployment , &amp; localhost) . <span class="kw">await </span>; deployment . deploy () . <span class="kw">await </span>. unwrap () ; <span class="kw">let </span><span class="kw-2">mut </span>conn_to_zero = port_to_zero . connect () . <span class="kw">await </span>. into_sink () ; <span class="kw">let </span><span class="kw-2">mut </span>node_one_stdout = io . process_one . stdout () . <span class="kw">await </span>; <span class="kw">let </span><span class="kw-2">mut </span>conn_to_cluster = ports_to_cluster [<span class="number">0</span>] . connect () . <span class="kw">await </span>. into_sink () ; <span class="kw">let </span><span class="kw-2">mut </span>cluster_stdout = io . cluster . members [<span class="number">0</span>] . stdout () . <span class="kw">await </span>; deployment . start () . <span class="kw">await </span>. unwrap () ; conn_to_zero . send (<span class="string">"hello world!" </span>. into ()) . <span class="kw">await </span>. unwrap () ; conn_to_cluster . send (<span class="string">"hello cluster!" </span>. into ()) . <span class="kw">await </span>. unwrap () ; assert_eq ! (node_one_stdout . recv () . <span class="kw">await </span>. unwrap () , <span class="string">"node one received: \"hello world!\""</span>) ; assert_eq ! (cluster_stdout . recv () . <span class="kw">await </span>. unwrap () , <span class="string">"cluster received: \"hello cluster!\""</span>) ; } } } }</code></pre></div></section></main></body></html>