searchState.loadedDescShard("hydro_optimize", 0, "Returns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTODO: Return type should be changed to also include …\nReturns (op_id, count)\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGiven the set of possible partitionings, select an …\nReturns (all possible partitionings, inputs -&gt; inputs’ …\nCopy dependencies from RHS, extending it with rhs_index …\nReturns the argument unchanged.\nReturns the argument unchanged.\nNote: May return redundant dependencies; no easy fix given …\nCreate a tuple representing dependencies present in both …\nFind the fields where all tuples have a dependency, …\nFind the intersection between all tuples (calling …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemap dependencies of the parent onto the child\nRemove any fields that could be None. If a parent could be …\nOverwrite self at index with rhs at rhs_index, creating …\nDon’t expose partition members to the cluster\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLimitations: Can only partition sends to clusters (not …\nReplace CLUSTER_SELF_ID with the ID of the original node …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReplays the rewrites in order. Returns Vec(Cluster, number …")