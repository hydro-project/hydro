<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A nullable Rust value that can asynchronously change over time."><title>Optional in hydro_lang::live_collections - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="hydro_lang" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (9f32ccf35 2025-09-21)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-061df703.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Optional</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../hydro_lang/index.html">hydro_<wbr>lang</a><span class="version">0.14.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Optional</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.all_ticks" title="all_ticks">all_ticks</a></li><li><a href="#method.all_ticks_atomic" title="all_ticks_atomic">all_ticks_atomic</a></li><li><a href="#method.atomic" title="atomic">atomic</a></li><li><a href="#method.defer_tick" title="defer_tick">defer_tick</a></li><li><a href="#method.end_atomic" title="end_atomic">end_atomic</a></li><li><a href="#method.filter" title="filter">filter</a></li><li><a href="#method.filter_if_none" title="filter_if_none">filter_if_none</a></li><li><a href="#method.filter_if_some" title="filter_if_some">filter_if_some</a></li><li><a href="#method.filter_map" title="filter_map">filter_map</a></li><li><a href="#method.flat_map_ordered" title="flat_map_ordered">flat_map_ordered</a></li><li><a href="#method.flat_map_unordered" title="flat_map_unordered">flat_map_unordered</a></li><li><a href="#method.flatten_ordered" title="flatten_ordered">flatten_ordered</a></li><li><a href="#method.flatten_unordered" title="flatten_unordered">flatten_unordered</a></li><li><a href="#method.if_some_then" title="if_some_then">if_some_then</a></li><li><a href="#method.into_singleton" title="into_singleton">into_singleton</a></li><li><a href="#method.into_stream" title="into_stream">into_stream</a></li><li><a href="#method.ir_node_named" title="ir_node_named">ir_node_named</a></li><li><a href="#method.latest" title="latest">latest</a></li><li><a href="#method.latest_atomic" title="latest_atomic">latest_atomic</a></li><li><a href="#method.map" title="map">map</a></li><li><a href="#method.or" title="or">or</a></li><li><a href="#method.persist" title="persist">persist</a></li><li><a href="#method.sample_eager" title="sample_eager">sample_eager</a></li><li><a href="#method.sample_every" title="sample_every">sample_every</a></li><li><a href="#method.snapshot" title="snapshot">snapshot</a></li><li><a href="#method.snapshot-1" title="snapshot">snapshot</a></li><li><a href="#method.unwrap_or" title="unwrap_or">unwrap_or</a></li><li><a href="#method.zip" title="zip">zip</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Optional%3CT,+L,+B%3E" title="Clone">Clone</a></li><li><a href="#impl-DeferTick-for-Optional%3CT,+Tick%3CL%3E,+Bounded%3E" title="DeferTick">DeferTick</a></li><li><a href="#impl-From%3COptional%3CT,+L,+Bounded%3E%3E-for-Optional%3CT,+L,+Unbounded%3E" title="From&#60;Optional&#60;T, L, Bounded&#62;&#62;">From&#60;Optional&#60;T, L, Bounded&#62;&#62;</a></li><li><a href="#impl-From%3CSingleton%3CT,+L,+B%3E%3E-for-Optional%3CT,+L,+B%3E" title="From&#60;Singleton&#60;T, L, B&#62;&#62;">From&#60;Singleton&#60;T, L, B&#62;&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Optional%3CType,+Loc,+Bound%3E" title="!Freeze">!Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Optional%3CType,+Loc,+Bound%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Send-for-Optional%3CType,+Loc,+Bound%3E" title="!Send">!Send</a></li><li><a href="#impl-Sync-for-Optional%3CType,+Loc,+Bound%3E" title="!Sync">!Sync</a></li><li><a href="#impl-UnwindSafe-for-Optional%3CType,+Loc,+Bound%3E" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Unpin-for-Optional%3CType,+Loc,+Bound%3E" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-DynClone-for-T" title="DynClone">DynClone</a></li><li><a href="#impl-ErasedDestructor-for-T" title="ErasedDestructor">ErasedDestructor</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-PolicyExt-for-T" title="PolicyExt">PolicyExt</a></li><li><a href="#impl-Same-for-T" title="Same">Same</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-VZip%3CV%3E-for-T" title="VZip&#60;V&#62;">VZip&#60;V&#62;</a></li><li><a href="#impl-WithSubscriber-for-T" title="WithSubscriber">WithSubscriber</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In hydro_<wbr>lang::<wbr>live_<wbr>collections</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">hydro_lang</a>::<wbr><a href="index.html">live_collections</a></div><h1>Struct <span class="struct">Optional</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/hydro_lang/live_collections/optional.rs.html#37-42">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Optional&lt;Type, Loc, Bound: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A <em>nullable</em> Rust value that can asynchronously change over time.</p>
<p>Optionals are the live collection equivalent of <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a>. If the optional is <a href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a>,
the value is frozen and will not change. But if it is <a href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a>, the value will
asynchronously change over time, including becoming present of uninhabited.</p>
<p>Optionals are used in many of the same places as <a href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>Singleton</code></a>, but when the value may be
nullable. For example, the first element of a <a href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream"><code>Stream</code></a> is exposed as an <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>.</p>
<p>Type Parameters:</p>
<ul>
<li><code>Type</code>: the type of the value in this optional (when it is not null)</li>
<li><code>Loc</code>: the <a href="../location/trait.Location.html" title="trait hydro_lang::location::Location"><code>Location</code></a> where the optional is materialized</li>
<li><code>Bound</code>: tracks whether the value is <a href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a> (fixed) or <a href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a> (changing asynchronously)</li>
</ul>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Optional%3CT,+L,+B%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#225-719">Source</a><a href="#impl-Optional%3CT,+L,+B%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.map" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#255-268">Source</a><h4 class="code-header">pub fn <a href="#method.map" class="fn">map</a>&lt;U, F&gt;(self, f: impl IntoQuotedMut&lt;'a, F, L&gt;) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;U, L, B&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; U + 'a,</div></h4></section></summary><div class="docblock"><p>Transforms the optional value by applying a function <code>f</code> to it,
continuously as the input is updated.</p>
<p>Whenever the optional is empty, the output optional is also empty.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>optional = tick.optional_first_tick(<span class="macro">q!</span>(<span class="number">1</span>));
optional.map(<span class="macro">q!</span>(|v| v + <span class="number">1</span>)).all_ticks()
<span class="comment">// 2</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flat_map_ordered" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#296-313">Source</a><h4 class="code-header">pub fn <a href="#method.flat_map_ordered" class="fn">flat_map_ordered</a>&lt;U, I, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;U, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; I + 'a,</div></h4></section></summary><div class="docblock"><p>Transforms the optional value by applying a function <code>f</code> to it and then flattening
the result into a stream, preserving the order of elements.</p>
<p>If the optional is empty, the output stream is also empty. If the optional contains
a value, <code>f</code> is applied to produce an iterator, and all items from that iterator
are emitted in the output stream in deterministic order.</p>
<p>The implementation of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> for the output type <code>I</code> must produce items in a
<strong>deterministic</strong> order. For example, <code>I</code> could be a <code>Vec</code>, but not a <code>HashSet</code>.
If the order is not deterministic, use <a href="struct.Optional.html#method.flat_map_unordered" title="method hydro_lang::live_collections::Optional::flat_map_unordered"><code>Optional::flat_map_unordered</code></a> instead.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>optional = tick.optional_first_tick(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));
optional.flat_map_ordered(<span class="macro">q!</span>(|v| v)).all_ticks()
<span class="comment">// 1, 2, 3</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flat_map_unordered" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#342-359">Source</a><h4 class="code-header">pub fn <a href="#method.flat_map_unordered" class="fn">flat_map_unordered</a>&lt;U, I, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;U, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; I + 'a,</div></h4></section></summary><div class="docblock"><p>Like <a href="struct.Optional.html#method.flat_map_ordered" title="method hydro_lang::live_collections::Optional::flat_map_ordered"><code>Optional::flat_map_ordered</code></a>, but allows the implementation of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>
for the output type <code>I</code> to produce items in any order.</p>
<p>If the optional is empty, the output stream is also empty. If the optional contains
a value, <code>f</code> is applied to produce an iterator, and all items from that iterator
are emitted in the output stream in non-deterministic order.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>optional = tick.optional_first_tick(<span class="macro">q!</span>(
    std::collections::HashSet::&lt;i32&gt;::from_iter(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])
));
optional.flat_map_unordered(<span class="macro">q!</span>(|v| v)).all_ticks()
<span class="comment">// 1, 2, 3, but in no particular order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flatten_ordered" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#386-391">Source</a><h4 class="code-header">pub fn <a href="#method.flatten_ordered" class="fn">flatten_ordered</a>&lt;U&gt;(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;U, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,</div></h4></section></summary><div class="docblock"><p>Flattens the optional value into a stream, preserving the order of elements.</p>
<p>If the optional is empty, the output stream is also empty. If the optional contains
a value that implements <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator"><code>IntoIterator</code></a>, all items from that iterator are emitted
in the output stream in deterministic order.</p>
<p>The implementation of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> for the element type <code>T</code> must produce items in a
<strong>deterministic</strong> order. For example, <code>T</code> could be a <code>Vec</code>, but not a <code>HashSet</code>.
If the order is not deterministic, use <a href="struct.Optional.html#method.flatten_unordered" title="method hydro_lang::live_collections::Optional::flatten_unordered"><code>Optional::flatten_unordered</code></a> instead.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>optional = tick.optional_first_tick(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));
optional.flatten_ordered().all_ticks()
<span class="comment">// 1, 2, 3</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flatten_unordered" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#420-425">Source</a><h4 class="code-header">pub fn <a href="#method.flatten_unordered" class="fn">flatten_unordered</a>&lt;U&gt;(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;U, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,</div></h4></section></summary><div class="docblock"><p>Like <a href="struct.Optional.html#method.flatten_ordered" title="method hydro_lang::live_collections::Optional::flatten_ordered"><code>Optional::flatten_ordered</code></a>, but allows the implementation of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>
for the element type <code>T</code> to produce items in any order.</p>
<p>If the optional is empty, the output stream is also empty. If the optional contains
a value that implements <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator"><code>IntoIterator</code></a>, all items from that iterator are emitted
in the output stream in non-deterministic order.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>optional = tick.optional_first_tick(<span class="macro">q!</span>(
    std::collections::HashSet::&lt;i32&gt;::from_iter(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])
));
optional.flatten_unordered().all_ticks()
<span class="comment">// 1, 2, 3, but in no particular order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#450-463">Source</a><h4 class="code-header">pub fn <a href="#method.filter" class="fn">filter</a>&lt;F&gt;(self, f: impl IntoQuotedMut&lt;'a, F, L&gt;) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> + 'a,</div></h4></section></summary><div class="docblock"><p>Creates an optional containing only the value if it satisfies a predicate <code>f</code>.</p>
<p>If the optional is empty, the output optional is also empty. If the optional contains
a value and the predicate returns <code>true</code>, the output optional contains the same value.
If the predicate returns <code>false</code>, the output optional is empty.</p>
<p>The closure <code>f</code> receives a reference <code>&amp;T</code> rather than an owned value <code>T</code> because filtering does
not modify or take ownership of the value. If you need to modify the value while filtering
use <a href="struct.Optional.html#method.filter_map" title="method hydro_lang::live_collections::Optional::filter_map"><code>Optional::filter_map</code></a> instead.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>optional = tick.optional_first_tick(<span class="macro">q!</span>(<span class="number">5</span>));
optional.filter(<span class="macro">q!</span>(|<span class="kw-2">&amp;</span>x| x &gt; <span class="number">3</span>)).all_ticks()
<span class="comment">// 5</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_map" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#487-500">Source</a><h4 class="code-header">pub fn <a href="#method.filter_map" class="fn">filter_map</a>&lt;U, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;U, L, B&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;U&gt; + 'a,</div></h4></section></summary><div class="docblock"><p>An operator that both filters and maps. It yields only the value if the supplied
closure <code>f</code> returns <code>Some(value)</code>.</p>
<p>If the optional is empty, the output optional is also empty. If the optional contains
a value and the closure returns <code>Some(new_value)</code>, the output optional contains <code>new_value</code>.
If the closure returns <code>None</code>, the output optional is empty.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>optional = tick.optional_first_tick(<span class="macro">q!</span>(<span class="string">"42"</span>));
optional
    .filter_map(<span class="macro">q!</span>(|s| s.parse::&lt;i32&gt;().ok()))
    .all_ticks()
<span class="comment">// 42</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.zip" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#526-561">Source</a><h4 class="code-header">pub fn <a href="#method.zip" class="fn">zip</a>&lt;O&gt;(
    self,
    other: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;O, L, B&gt;&gt;,
) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(T, O)</a>, L, B&gt;<div class="where">where
    O: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Combines this singleton with another <a href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>Singleton</code></a> or <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a> by tupling their values.</p>
<p>If the other value is a <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>, the output will be non-null only if the argument is
non-null. This is useful for combining several pieces of state together.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>min = numbers.clone().min(); <span class="comment">// Optional
</span><span class="kw">let </span>max = numbers.max(); <span class="comment">// Optional
</span>min.zip(max).all_ticks()
<span class="comment">// [(123, 789)]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.or" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#591-622">Source</a><h4 class="code-header">pub fn <a href="#method.or" class="fn">or</a>(self, other: <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;</h4></section></summary><div class="docblock"><p>Passes through <code>self</code> when it has a value, otherwise passes through <code>other</code>.</p>
<p>Like <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#method.or" title="method core::option::Option::or"><code>Option::or</code></a>, this is helpful for defining a fallback for an <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>, when the
fallback itself is an <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>. If the fallback is a <a href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>Singleton</code></a>, you can use
<a href="struct.Optional.html#method.unwrap_or" title="method hydro_lang::live_collections::Optional::unwrap_or"><code>Optional::unwrap_or</code></a> to ensure that the output is always non-null.</p>
<p>If the inputs are <a href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a>, the output will be asynchronously updated as the contents
of the inputs change (including to/from null states).</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="comment">// ticks are lazy by default, forces the second tick to run
</span>tick.spin_batch(<span class="macro">q!</span>(<span class="number">1</span>)).all_ticks().for_each(<span class="macro">q!</span>(|<span class="kw">_</span>| {}));

<span class="kw">let </span>some_first_tick = tick.optional_first_tick(<span class="macro">q!</span>(<span class="number">123</span>));
<span class="kw">let </span>some_second_tick = tick.optional_first_tick(<span class="macro">q!</span>(<span class="number">456</span>)).defer_tick();
some_first_tick.or(some_second_tick).all_ticks()
<span class="comment">// [123 /* first tick */, 456 /* second tick */]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.unwrap_or" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#652-655">Source</a><h4 class="code-header">pub fn <a href="#method.unwrap_or" class="fn">unwrap_or</a>(self, other: <a class="struct" href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;T, L, B&gt;) -&gt; <a class="struct" href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;T, L, B&gt;</h4></section></summary><div class="docblock"><p>Gets the contents of <code>self</code> when it has a value, otherwise passes through <code>other</code>.</p>
<p>Like <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#method.unwrap_or" title="method core::option::Option::unwrap_or"><code>Option::unwrap_or</code></a>, this is helpful for defining a fallback for an <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>.
If the fallback is not always defined (an <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>), you can use <a href="struct.Optional.html#method.or" title="method hydro_lang::live_collections::Optional::or"><code>Optional::or</code></a>.</p>
<p>If the inputs are <a href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a>, the output will be asynchronously updated as the contents
of the inputs change (including to/from null states).</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="comment">// ticks are lazy by default, forces the later ticks to run
</span>tick.spin_batch(<span class="macro">q!</span>(<span class="number">1</span>)).all_ticks().for_each(<span class="macro">q!</span>(|<span class="kw">_</span>| {}));

<span class="kw">let </span>some_first_tick = tick.optional_first_tick(<span class="macro">q!</span>(<span class="number">123</span>));
some_first_tick
    .unwrap_or(tick.singleton(<span class="macro">q!</span>(<span class="number">456</span>)))
    .all_ticks()
<span class="comment">// [123 /* first tick */, 456 /* second tick */, 456 /* third tick */, 456, ...]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.into_singleton" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#681-707">Source</a><h4 class="code-header">pub fn <a href="#method.into_singleton" class="fn">into_singleton</a>(self) -&gt; <a class="struct" href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;, L, B&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Converts this optional into a <a href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>Singleton</code></a> with a Rust <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a> as its contents.</p>
<p>Useful for writing custom Rust code that needs to interact with both the null and non-null
states of the <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>. When possible, you should use the native APIs on <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>
so that Hydro can skip any computation on null values.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="comment">// ticks are lazy by default, forces the later ticks to run
</span>tick.spin_batch(<span class="macro">q!</span>(<span class="number">1</span>)).all_ticks().for_each(<span class="macro">q!</span>(|<span class="kw">_</span>| {}));

<span class="kw">let </span>some_first_tick = tick.optional_first_tick(<span class="macro">q!</span>(<span class="number">123</span>));
some_first_tick.into_singleton().all_ticks()
<span class="comment">// [Some(123) /* first tick */, None /* second tick */, None /* third tick */, None, ...]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ir_node_named" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#711-718">Source</a><h4 class="code-header">pub fn <a href="#method.ir_node_named" class="fn">ir_node_named</a>(self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;</h4></section></summary><div class="docblock"><p>An operator which allows you to “name” a <code>HydroNode</code>.
This is only used for testing, to correlate certain <code>HydroNode</code>s with IDs.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Optional%3CT,+L,+Bounded%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#721-835">Source</a><a href="#impl-Optional%3CT,+L,+Bounded%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.filter_if_some" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#759-761">Source</a><h4 class="code-header">pub fn <a href="#method.filter_if_some" class="fn">filter_if_some</a>&lt;U&gt;(
    self,
    signal: <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;U, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;,
) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;</h4></section></summary><div class="docblock"><p>Filters this optional, passing through the optional value if it is non-null <strong>and</strong> the
argument (a <a href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a> <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>`) is non-null, otherwise the output is null.</p>
<p>Useful for conditionally processing, such as only emitting an optional’s value outside
a tick if some other condition is satisfied.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="comment">// ticks are lazy by default, forces the second tick to run
</span>tick.spin_batch(<span class="macro">q!</span>(<span class="number">1</span>)).all_ticks().for_each(<span class="macro">q!</span>(|<span class="kw">_</span>| {}));

<span class="kw">let </span>batch_first_tick = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>batch_second_tick = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">456</span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>))
  .defer_tick(); <span class="comment">// appears on the second tick
</span><span class="kw">let </span>some_on_first_tick = tick.optional_first_tick(<span class="macro">q!</span>(()));
batch_first_tick.chain(batch_second_tick).first()
  .filter_if_some(some_on_first_tick)
  .unwrap_or(tick.singleton(<span class="macro">q!</span>(<span class="number">789</span>)))
  .all_ticks()
<span class="comment">// [789, 789]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_if_none" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#797-804">Source</a><h4 class="code-header">pub fn <a href="#method.filter_if_none" class="fn">filter_if_none</a>&lt;U&gt;(
    self,
    other: <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;U, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;,
) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;</h4></section></summary><div class="docblock"><p>Filters this optional, passing through the optional value if it is non-null <strong>and</strong> the
argument (a <a href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a> <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>`) is <em>null</em>, otherwise the output is null.</p>
<p>Useful for conditionally processing, such as only emitting an optional’s value outside
a tick if some other condition is satisfied.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="comment">// ticks are lazy by default, forces the second tick to run
</span>tick.spin_batch(<span class="macro">q!</span>(<span class="number">1</span>)).all_ticks().for_each(<span class="macro">q!</span>(|<span class="kw">_</span>| {}));

<span class="kw">let </span>batch_first_tick = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>batch_second_tick = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">456</span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>))
  .defer_tick(); <span class="comment">// appears on the second tick
</span><span class="kw">let </span>some_on_first_tick = tick.optional_first_tick(<span class="macro">q!</span>(()));
batch_first_tick.chain(batch_second_tick).first()
  .filter_if_none(some_on_first_tick)
  .unwrap_or(tick.singleton(<span class="macro">q!</span>(<span class="number">789</span>)))
  .all_ticks()
<span class="comment">// [789, 789]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.if_some_then" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#832-834">Source</a><h4 class="code-header">pub fn <a href="#method.if_some_then" class="fn">if_some_then</a>&lt;U&gt;(
    self,
    value: <a class="struct" href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;U, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;,
) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;U, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;</h4></section></summary><div class="docblock"><p>If <code>self</code> is null, emits a null optional, but if it non-null, emits <code>value</code>.</p>
<p>Useful for gating the release of a <a href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>Singleton</code></a> on a condition of the <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>
having a value, such as only releasing a piece of state if the node is the leader.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="comment">// ticks are lazy by default, forces the second tick to run
</span>tick.spin_batch(<span class="macro">q!</span>(<span class="number">1</span>)).all_ticks().for_each(<span class="macro">q!</span>(|<span class="kw">_</span>| {}));

<span class="kw">let </span>some_on_first_tick = tick.optional_first_tick(<span class="macro">q!</span>(()));
some_on_first_tick
    .if_some_then(tick.singleton(<span class="macro">q!</span>(<span class="number">456</span>)))
    .unwrap_or(tick.singleton(<span class="macro">q!</span>(<span class="number">123</span>)))
<span class="comment">// 456 (first tick) ~&gt; 123 (second tick onwards)</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Optional%3CT,+Atomic%3CL%3E,+B%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#837-866">Source</a><a href="#impl-Optional%3CT,+Atomic%3CL%3E,+B%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, B&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.snapshot" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#851-859">Source</a><h4 class="code-header">pub fn <a href="#method.snapshot" class="fn">snapshot</a>(self, _nondet: <a class="struct" href="../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;</h4></section></summary><div class="docblock"><p>Returns an optional value corresponding to the latest snapshot of the optional
being atomically processed. The snapshot at tick <code>t + 1</code> is guaranteed to include
at least all relevant data that contributed to the snapshot at tick <code>t</code>. Furthermore,
all snapshots of this optional into the atomic-associated tick will observe the
same value each tick.</p>
<h5 id="non-determinism"><a class="doc-anchor" href="#non-determinism">§</a>Non-Determinism</h5>
<p>Because this picks a snapshot of a optional whose value is continuously changing,
the output optional has a non-deterministic value since the snapshot can be at an
arbitrary point in time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.end_atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#863-865">Source</a><h4 class="code-header">pub fn <a href="#method.end_atomic" class="fn">end_atomic</a>(self) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;</h4></section></summary><div class="docblock"><p>Returns this optional back into a top-level, asynchronous execution context where updates
to the value will be asynchronously propagated.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Optional%3CT,+L,+B%3E-1" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#868-933">Source</a><a href="#impl-Optional%3CT,+L,+B%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a> + <a class="trait" href="../location/tick/trait.NoAtomic.html" title="trait hydro_lang::location::tick::NoAtomic">NoAtomic</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#883-885">Source</a><h4 class="code-header">pub fn <a href="#method.atomic" class="fn">atomic</a>(self, tick: &amp;<a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, B&gt;</h4></section></summary><div class="docblock"><p>Shifts this optional into an atomic context, which guarantees that any downstream logic
will observe the same version of the value and will be executed synchronously before any
outputs are yielded (in <a href="struct.Optional.html#method.end_atomic" title="method hydro_lang::live_collections::Optional::end_atomic"><code>Optional::end_atomic</code></a>).</p>
<p>This is useful to enforce local consistency constraints, such as ensuring that several readers
see a consistent version of local state (since otherwise each <a href="struct.Optional.html#method.snapshot" title="method hydro_lang::live_collections::Optional::snapshot"><code>Optional::snapshot</code></a> may pick
a different version).</p>
<p>Entering an atomic section requires a <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> argument that declares where the optional will
be atomically processed. Snapshotting an optional into the <em>same</em> <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> will preserve the
synchronous execution, and all such snapshots in the same <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> will have the same value.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.snapshot-1" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#895-897">Source</a><h4 class="code-header">pub fn <a href="#method.snapshot-1" class="fn">snapshot</a>(
    self,
    tick: &amp;<a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;,
    nondet: <a class="struct" href="../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;</h4></section></summary><div class="docblock"><p>Given a tick, returns a optional value corresponding to a snapshot of the optional
as of that tick. The snapshot at tick <code>t + 1</code> is guaranteed to include at least all
relevant data that contributed to the snapshot at tick <code>t</code>.</p>
<h5 id="non-determinism-1"><a class="doc-anchor" href="#non-determinism-1">§</a>Non-Determinism</h5>
<p>Because this picks a snapshot of a optional whose value is continuously changing,
the output optional has a non-deterministic value since the snapshot can be at an
arbitrary point in time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sample_eager" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#906-909">Source</a><h4 class="code-header">pub fn <a href="#method.sample_eager" class="fn">sample_eager</a>(
    self,
    nondet: <a class="struct" href="../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.AtLeastOnce.html" title="enum hydro_lang::live_collections::stream::AtLeastOnce">AtLeastOnce</a>&gt;</h4></section></summary><div class="docblock"><p>Eagerly samples the optional as fast as possible, returning a stream of snapshots
with order corresponding to increasing prefixes of data contributing to the optional.</p>
<h5 id="non-determinism-2"><a class="doc-anchor" href="#non-determinism-2">§</a>Non-Determinism</h5>
<p>At runtime, the optional will be arbitrarily sampled as fast as possible, but due
to non-deterministic batching and arrival of inputs, the output stream is
non-deterministic.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sample_every" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#920-932">Source</a><h4 class="code-header">pub fn <a href="#method.sample_every" class="fn">sample_every</a>(
    self,
    interval: impl QuotedWithContext&lt;'a, <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> + 'a,
    nondet: <a class="struct" href="../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.AtLeastOnce.html" title="enum hydro_lang::live_collections::stream::AtLeastOnce">AtLeastOnce</a>&gt;</h4></section></summary><div class="docblock"><p>Given a time interval, returns a stream corresponding to snapshots of the optional
value taken at various points in time. Because the input optional may be
<a href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a>, there are no guarantees on what these snapshots are other than they
represent the value of the optional given some prefix of the streams leading up to
it.</p>
<h5 id="non-determinism-3"><a class="doc-anchor" href="#non-determinism-3">§</a>Non-Determinism</h5>
<p>The output stream is non-deterministic in which elements are sampled, since this
is controlled by a clock.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Optional%3CT,+Tick%3CL%3E,+Bounded%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#935-1109">Source</a><a href="#impl-Optional%3CT,+Tick%3CL%3E,+Bounded%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.all_ticks" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#973-975">Source</a><h4 class="code-header">pub fn <a href="#method.all_ticks" class="fn">all_ticks</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;</h4></section></summary><div class="docblock"><p>Asynchronously yields the value of this singleton outside the tick as an unbounded stream,
which will stream the value computed in <em>each</em> tick as a separate stream element (skipping
null values).</p>
<p>Unlike <a href="struct.Optional.html#method.latest" title="method hydro_lang::live_collections::Optional::latest"><code>Optional::latest</code></a>, the value computed in each tick is emitted separately,
producing one element in the output for each (non-null) tick. This is useful for batched
computations, where the results from each tick must be combined together.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>input_batch <span class="comment">// first tick: [], second tick: [1, 2, 3]
    </span>.max()
    .all_ticks()
<span class="comment">// [3]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.all_ticks_atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#983-985">Source</a><h4 class="code-header">pub fn <a href="#method.all_ticks_atomic" class="fn">all_ticks_atomic</a>(
    self,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;</h4></section></summary><div class="docblock"><p>Synchronously yields the value of this optional outside the tick as an unbounded stream,
which will stream the value computed in <em>each</em> tick as a separate stream element.</p>
<p>Unlike <a href="struct.Optional.html#method.all_ticks" title="method hydro_lang::live_collections::Optional::all_ticks"><code>Optional::all_ticks</code></a>, this preserves synchronous execution, as the output stream
is emitted in an <a href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic"><code>Atomic</code></a> context that will process elements synchronously with the input
optional’s <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> context.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.latest" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#1023-1031">Source</a><h4 class="code-header">pub fn <a href="#method.latest" class="fn">latest</a>(self) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>&gt;</h4></section></summary><div class="docblock"><p>Asynchronously yields this optional outside the tick as an unbounded optional, which will
be asynchronously updated with the latest value of the optional inside the tick, including
whether the optional is null or not.</p>
<p>This converts a bounded value <em>inside</em> a tick into an asynchronous value outside the
tick that tracks the inner value. This is useful for getting the value as of the
“most recent” tick, but note that updates are propagated asynchronously outside the tick.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>input_batch <span class="comment">// first tick: [], second tick: [1, 2, 3]
    </span>.max()
    .latest()
<span class="comment">// asynchronously changes from None ~&gt; 3</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.latest_atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#1039-1049">Source</a><h4 class="code-header">pub fn <a href="#method.latest_atomic" class="fn">latest_atomic</a>(self) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>&gt;</h4></section></summary><div class="docblock"><p>Synchronously yields this optional outside the tick as an unbounded optional, which will
be updated with the latest value of the optional inside the tick.</p>
<p>Unlike <a href="struct.Optional.html#method.latest" title="method hydro_lang::live_collections::Optional::latest"><code>Optional::latest</code></a>, this preserves synchronous execution, as the output optional
is emitted in an <a href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic"><code>Atomic</code></a> context that will process elements synchronously with the input
optional’s <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> context.</p>
</div></details><section id="method.defer_tick" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#1052-1060">Source</a><h4 class="code-header">pub fn <a href="#method.defer_tick" class="fn">defer_tick</a>(self) -&gt; <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;</h4></section><section id="method.persist" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#1064-1072">Source</a><h4 class="code-header">pub fn <a href="#method.persist" class="fn">persist</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use .into_stream().persist()</span></div></span><details class="toggle method-toggle" open><summary><section id="method.into_stream" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#1106-1108">Source</a><h4 class="code-header">pub fn <a href="#method.into_stream" class="fn">into_stream</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;</h4></section></summary><div class="docblock"><p>Converts this optional into a <a href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream"><code>Stream</code></a> containing a single element, the value, if it is
non-null. Otherwise, the stream is empty.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>input_batch <span class="comment">// first tick: [], second tick: [123, 456]
    </span>.clone()
    .max()
    .into_stream()
    .chain(input_batch)
    .all_ticks()
<span class="comment">// [456, 123, 456]</span></code></pre></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Optional%3CT,+L,+B%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#195-223">Source</a><a href="#impl-Clone-for-Optional%3CT,+L,+B%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#200-222">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DeferTick-for-Optional%3CT,+Tick%3CL%3E,+Bounded%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#44-51">Source</a><a href="#impl-DeferTick-for-Optional%3CT,+Tick%3CL%3E,+Bounded%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L&gt; <a class="trait" href="../location/tick/trait.DeferTick.html" title="trait hydro_lang::location::tick::DeferTick">DeferTick</a> for <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.defer_tick-1" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#48-50">Source</a><a href="#method.defer_tick-1" class="anchor">§</a><h4 class="code-header">fn <a href="../location/tick/trait.DeferTick.html#tymethod.defer_tick" class="fn">defer_tick</a>(self) -&gt; Self</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3COptional%3CT,+L,+Bounded%3E%3E-for-Optional%3CT,+L,+Unbounded%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#177-184">Source</a><a href="#impl-From%3COptional%3CT,+L,+Bounded%3E%3E-for-Optional%3CT,+L,+Unbounded%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;&gt; for <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#181-183">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(singleton: <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSingleton%3CT,+L,+B%3E%3E-for-Optional%3CT,+L,+B%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#186-193">Source</a><a href="#impl-From%3CSingleton%3CT,+L,+B%3E%3E-for-Optional%3CT,+L,+B%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;T, L, B&gt;&gt; for <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/optional.rs.html#190-192">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(singleton: <a class="struct" href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;T, L, B&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Optional%3CType,+Loc,+Bound%3E" class="impl"><a href="#impl-Freeze-for-Optional%3CType,+Loc,+Bound%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Type, Loc, Bound&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;Type, Loc, Bound&gt;</h3></section><section id="impl-RefUnwindSafe-for-Optional%3CType,+Loc,+Bound%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Optional%3CType,+Loc,+Bound%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Type, Loc, Bound&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;Type, Loc, Bound&gt;</h3></section><section id="impl-Send-for-Optional%3CType,+Loc,+Bound%3E" class="impl"><a href="#impl-Send-for-Optional%3CType,+Loc,+Bound%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Type, Loc, Bound&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;Type, Loc, Bound&gt;</h3></section><section id="impl-Sync-for-Optional%3CType,+Loc,+Bound%3E" class="impl"><a href="#impl-Sync-for-Optional%3CType,+Loc,+Bound%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Type, Loc, Bound&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;Type, Loc, Bound&gt;</h3></section><section id="impl-Unpin-for-Optional%3CType,+Loc,+Bound%3E" class="impl"><a href="#impl-Unpin-for-Optional%3CType,+Loc,+Bound%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Type, Loc, Bound&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;Type, Loc, Bound&gt;<div class="where">where
    Loc: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Type: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Bound: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-Optional%3CType,+Loc,+Bound%3E" class="impl"><a href="#impl-UnwindSafe-for-Optional%3CType,+Loc,+Bound%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Type, Loc, Bound&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;Type, Loc, Bound&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#515">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#517">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-DynClone-for-T" class="impl"><a class="src rightside" href="https://docs.rs/dyn-clone/1.0.20/src/dyn_clone/lib.rs.html#196-198">Source</a><a href="#impl-DynClone-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/dyn-clone/1.0.20/dyn_clone/trait.DynClone.html" title="trait dyn_clone::DynClone">DynClone</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><section id="method.__clone_box" class="method trait-impl"><a class="src rightside" href="https://docs.rs/dyn-clone/1.0.20/src/dyn_clone/lib.rs.html#200">Source</a><a href="#method.__clone_box" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/dyn-clone/1.0.20/dyn_clone/trait.DynClone.html#tymethod.__clone_box" class="fn">__clone_box</a>(&amp;self, _: Private) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Instrument for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a class="fn">instrument</a>(self, span: Span) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided [<code>Span</code>], returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a class="fn">in_current_span</a>(self) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="super::Span::current()">current</a> <a href="crate::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-PolicyExt-for-T" class="impl"><a href="#impl-PolicyExt-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; PolicyExt for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.and" class="method trait-impl"><a href="#method.and" class="anchor">§</a><h4 class="code-header">fn <a class="fn">and</a>&lt;P, B, E&gt;(self, other: P) -&gt; And&lt;T, P&gt;<div class="where">where
    T: Policy&lt;B, E&gt;,
    P: Policy&lt;B, E&gt;,</div></h4></section></summary><div class='docblock'>Create a new <code>Policy</code> that returns [<code>Action::Follow</code>] only if <code>self</code> and <code>other</code> return
<code>Action::Follow</code>. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.or-1" class="method trait-impl"><a href="#method.or-1" class="anchor">§</a><h4 class="code-header">fn <a class="fn">or</a>&lt;P, B, E&gt;(self, other: P) -&gt; Or&lt;T, P&gt;<div class="where">where
    T: Policy&lt;B, E&gt;,
    P: Policy&lt;B, E&gt;,</div></h4></section></summary><div class='docblock'>Create a new <code>Policy</code> that returns [<code>Action::Follow</code>] if either <code>self</code> or <code>other</code> returns
<code>Action::Follow</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.18.0/src/typenum/type_operators.rs.html#34">Source</a><a href="#impl-Same-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.18.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="https://docs.rs/typenum/1.18.0/src/typenum/type_operators.rs.html#35">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.18.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#84-86">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#88">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#93">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a href="#impl-WithSubscriber-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; WithSubscriber for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a href="#method.with_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; WithDispatch&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Dispatch&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a href="#method.with_current_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_current_subscriber</a>(self) -&gt; WithDispatch&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="crate::dispatcher#setting-the-default-subscriber">default</a> <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details></div></details><section id="impl-ErasedDestructor-for-T" class="impl"><a href="#impl-ErasedDestructor-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; ErasedDestructor for T<div class="where">where
    T: 'static,</div></h3></section></div></section></div></main></body></html>