<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Streaming elements of type `V` grouped by a key of type `K`."><title>KeyedStream in hydro_lang::live_collections - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-b7b9f40b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="hydro_lang" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (f889772d6 2026-02-05)" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-12f88f4f.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">KeyedStream</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../hydro_lang/index.html">hydro_<wbr>lang</a><span class="version">0.15.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Keyed<wbr>Stream</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.across_ticks" title="across_ticks">across_ticks</a></li><li><a href="#method.all_ticks" title="all_ticks">all_ticks</a></li><li><a href="#method.all_ticks_atomic" title="all_ticks_atomic">all_ticks_atomic</a></li><li><a href="#method.assume_ordering" title="assume_ordering">assume_ordering</a></li><li><a href="#method.assume_retries" title="assume_retries">assume_retries</a></li><li><a href="#method.atomic" title="atomic">atomic</a></li><li><a href="#method.batch" title="batch">batch</a></li><li><a href="#method.batch_atomic" title="batch_atomic">batch_atomic</a></li><li><a href="#method.chain" title="chain">chain</a></li><li><a href="#method.collection_kind" title="collection_kind">collection_kind</a></li><li><a href="#method.cross_singleton" title="cross_singleton">cross_singleton</a></li><li><a href="#method.defer_tick" title="defer_tick">defer_tick</a></li><li><a href="#method.demux" title="demux">demux</a></li><li><a href="#method.demux-1" title="demux">demux</a></li><li><a href="#method.demux-2" title="demux">demux</a></li><li><a href="#method.demux_bincode" title="demux_bincode">demux_bincode</a></li><li><a href="#method.demux_bincode-1" title="demux_bincode">demux_bincode</a></li><li><a href="#method.demux_bincode-2" title="demux_bincode">demux_bincode</a></li><li><a href="#method.drop_key_prefix" title="drop_key_prefix">drop_key_prefix</a></li><li><a href="#method.end_atomic" title="end_atomic">end_atomic</a></li><li><a href="#method.entries" title="entries">entries</a></li><li><a href="#method.filter" title="filter">filter</a></li><li><a href="#method.filter_key_not_in" title="filter_key_not_in">filter_key_not_in</a></li><li><a href="#method.filter_map" title="filter_map">filter_map</a></li><li><a href="#method.filter_map_with_key" title="filter_map_with_key">filter_map_with_key</a></li><li><a href="#method.filter_with_key" title="filter_with_key">filter_with_key</a></li><li><a href="#method.first" title="first">first</a></li><li><a href="#method.flat_map_ordered" title="flat_map_ordered">flat_map_ordered</a></li><li><a href="#method.flat_map_unordered" title="flat_map_unordered">flat_map_unordered</a></li><li><a href="#method.flatten_ordered" title="flatten_ordered">flatten_ordered</a></li><li><a href="#method.flatten_unordered" title="flatten_unordered">flatten_unordered</a></li><li><a href="#method.fold" title="fold">fold</a></li><li><a href="#method.fold_early_stop" title="fold_early_stop">fold_early_stop</a></li><li><a href="#method.generator" title="generator">generator</a></li><li><a href="#method.get" title="get">get</a></li><li><a href="#method.inspect" title="inspect">inspect</a></li><li><a href="#method.inspect_with_key" title="inspect_with_key">inspect_with_key</a></li><li><a href="#method.interleave" title="interleave">interleave</a></li><li><a href="#method.ir_node_named" title="ir_node_named">ir_node_named</a></li><li><a href="#method.join_keyed_singleton" title="join_keyed_singleton">join_keyed_singleton</a></li><li><a href="#method.join_keyed_stream" title="join_keyed_stream">join_keyed_stream</a></li><li><a href="#method.keys" title="keys">keys</a></li><li><a href="#method.location" title="location">location</a></li><li><a href="#method.lookup_keyed_singleton" title="lookup_keyed_singleton">lookup_keyed_singleton</a></li><li><a href="#method.lookup_keyed_stream" title="lookup_keyed_stream">lookup_keyed_stream</a></li><li><a href="#method.map" title="map">map</a></li><li><a href="#method.map_with_key" title="map_with_key">map_with_key</a></li><li><a href="#method.prefix_key" title="prefix_key">prefix_key</a></li><li><a href="#method.reduce" title="reduce">reduce</a></li><li><a href="#method.reduce_watermark" title="reduce_watermark">reduce_watermark</a></li><li><a href="#method.scan" title="scan">scan</a></li><li><a href="#method.send" title="send">send</a></li><li><a href="#method.send_bincode" title="send_bincode">send_bincode</a></li><li><a href="#method.value_counts" title="value_counts">value_counts</a></li><li><a href="#method.values" title="values">values</a></li><li><a href="#method.weaken_ordering" title="weaken_ordering">weaken_ordering</a></li><li><a href="#method.weaken_retries" title="weaken_retries">weaken_retries</a></li><li><a href="#method.weakest_ordering" title="weakest_ordering">weakest_ordering</a></li><li><a href="#method.weakest_retries" title="weakest_retries">weakest_retries</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+R%3E" title="Clone">Clone</a></li><li><a href="#impl-DeferTick-for-KeyedStream%3CK,+V,+Tick%3CL%3E,+Bounded,+O,+R%3E" title="DeferTick">DeferTick</a></li><li><a href="#impl-From%3CKeyedStream%3CK,+V,+L,+B,+TotalOrder,+R%3E%3E-for-KeyedStream%3CK,+V,+L,+B,+NoOrder,+R%3E" title="From&#60;KeyedStream&#60;K, V, L, B, TotalOrder, R&#62;&#62;">From&#60;KeyedStream&#60;K, V, L, B, TotalOrder, R&#62;&#62;</a></li><li><a href="#impl-From%3CKeyedStream%3CK,+V,+L,+Bounded,+O,+R%3E%3E-for-KeyedStream%3CK,+V,+L,+Unbounded,+O,+R%3E" title="From&#60;KeyedStream&#60;K, V, L, Bounded, O, R&#62;&#62;">From&#60;KeyedStream&#60;K, V, L, Bounded, O, R&#62;&#62;</a></li><li><a href="#impl-Unslicable-for-KeyedStream%3CK,+V,+Tick%3CL%3E,+Bounded,+O,+R%3E" title="Unslicable">Unslicable</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" title="!Freeze">!Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Send-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" title="!Send">!Send</a></li><li><a href="#impl-Sync-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" title="!Sync">!Sync</a></li><li><a href="#impl-UnwindSafe-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Unpin-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-IntoShared%3CShared%3E-for-Unshared" title="IntoShared&#60;Shared&#62;">IntoShared&#60;Shared&#62;</a></li><li><a href="#impl-Same-for-T" title="Same">Same</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToSinkBuild-for-T" title="ToSinkBuild">ToSinkBuild</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-VZip%3CV%3E-for-T" title="VZip&#60;V&#62;">VZip&#60;V&#62;</a></li><li><a href="#impl-WithSubscriber-for-T" title="WithSubscriber">WithSubscriber</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In hydro_<wbr>lang::<wbr>live_<wbr>collections</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">hydro_lang</a>::<wbr><a href="index.html">live_collections</a></div><h1>Struct <span class="struct">Keyed<wbr>Stream</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#55-67">Source</a> </span></div><pre class="rust item-decl"><code>pub struct KeyedStream&lt;K, V, Loc, Bound: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a> = <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, Order: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a> = <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a> = <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Streaming elements of type <code>V</code> grouped by a key of type <code>K</code>.</p>
<p>Keyed Streams capture streaming elements of type <code>V</code> grouped by a key of type <code>K</code>, where the
order of keys is non-deterministic but the order <em>within</em> each group may be deterministic.</p>
<p>Although keyed streams are conceptually grouped by keys, values are not immediately grouped
into buckets when constructing a keyed stream. Instead, keyed streams defer grouping until an
operator such as <a href="struct.KeyedStream.html#method.fold" title="method hydro_lang::live_collections::KeyedStream::fold"><code>KeyedStream::fold</code></a> is called, which requires <code>K: Hash + Eq</code>.</p>
<p>Type Parameters:</p>
<ul>
<li><code>K</code>: the type of the key for each group</li>
<li><code>V</code>: the type of the elements inside each group</li>
<li><code>Loc</code>: the <a href="../location/trait.Location.html" title="trait hydro_lang::location::Location"><code>Location</code></a> where the keyed stream is materialized</li>
<li><code>Bound</code>: tracks whether the entries are <a href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a> (local and finite) or <a href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a> (asynchronous and possibly infinite)</li>
<li><code>Order</code>: tracks whether the elements within each group have deterministic order
(<a href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a>) or not (<a href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder"><code>NoOrder</code></a>)</li>
<li><code>Retries</code>: tracks whether the elements within each group have deterministic cardinality
(<a href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce"><code>ExactlyOnce</code></a>) or may have non-deterministic retries (<a href="stream/enum.AtLeastOnce.html" title="enum hydro_lang::live_collections::stream::AtLeastOnce"><code>crate::live_collections::stream::AtLeastOnce</code></a>)</li>
</ul>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">¬ß</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CMemberId%3CL2%3E,+T,+Process%3C'a,+L%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#16-138">Source</a><a href="#impl-KeyedStream%3CMemberId%3CL2%3E,+T,+Process%3C'a,+L%3E,+B,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, T, L, L2, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;<a class="struct" href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L2&gt;, T, <a class="struct" href="../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L&gt;, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle deprecated" open><summary><section id="method.demux_bincode" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#57-65">Source</a><h4 class="code-header">pub fn <a href="#method.demux_bincode" class="fn">demux_bincode</a>(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">üëé</span><span>Deprecated: use KeyedStream::demux(‚Ä¶, TCP.fail_stop().bincode()) instead</span></div></span></summary><div class="docblock"><p>Sends each group of this stream to a specific member of a cluster, with the <a href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId"><code>MemberId</code></a> key
identifying the recipient for each group and using <a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize messages.</p>
<p>Each key must be a <code>MemberId&lt;L2&gt;</code> and each value must be a <code>T</code> where the key specifies
which cluster member should receive the data. Unlike <a href="struct.Stream.html#method.broadcast_bincode" title="method hydro_lang::live_collections::Stream::broadcast_bincode"><code>Stream::broadcast_bincode</code></a>, this
API allows precise targeting of specific cluster members rather than broadcasting to
all members.</p>
<h5 id="example"><a class="doc-anchor" href="#example">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>p1 = flow.process::&lt;()&gt;();
<span class="kw">let </span>workers: Cluster&lt;()&gt; = flow.cluster::&lt;()&gt;();
<span class="kw">let </span>numbers: Stream&lt;<span class="kw">_</span>, Process&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = p1.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));
<span class="kw">let </span>on_worker: Stream&lt;<span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = numbers
    .map(<span class="macro">q!</span>(|x| (hydro_lang::location::MemberId::from_raw_id(x), x)))
    .into_keyed()
    .demux_bincode(<span class="kw-2">&amp;</span>workers);
<span class="comment">// if there are 4 members in the cluster, each receives one element
// - MemberId::&lt;()&gt;(0): [0]
// - MemberId::&lt;()&gt;(1): [1]
// - MemberId::&lt;()&gt;(2): [2]
// - MemberId::&lt;()&gt;(3): [3]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.demux" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#105-137">Source</a><h4 class="code-header">pub fn <a href="#method.demux" class="fn">demux</a>&lt;N: <a class="trait" href="../networking/trait.NetworkFor.html" title="trait hydro_lang::networking::NetworkFor">NetworkFor</a>&lt;T&gt;&gt;(
    self,
    to: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
    via: N,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>Sends each group of this stream to a specific member of a cluster, with the <a href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId"><code>MemberId</code></a> key
identifying the recipient for each group and using the configuration in <code>via</code> to set up the
message transport.</p>
<p>Each key must be a <code>MemberId&lt;L2&gt;</code> and each value must be a <code>T</code> where the key specifies
which cluster member should receive the data. Unlike <a href="struct.Stream.html#method.broadcast" title="method hydro_lang::live_collections::Stream::broadcast"><code>Stream::broadcast</code></a>, this
API allows precise targeting of specific cluster members rather than broadcasting to
all members.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>p1 = flow.process::&lt;()&gt;();
<span class="kw">let </span>workers: Cluster&lt;()&gt; = flow.cluster::&lt;()&gt;();
<span class="kw">let </span>numbers: Stream&lt;<span class="kw">_</span>, Process&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = p1.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));
<span class="kw">let </span>on_worker: Stream&lt;<span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = numbers
    .map(<span class="macro">q!</span>(|x| (hydro_lang::location::MemberId::from_raw_id(x), x)))
    .into_keyed()
    .demux(<span class="kw-2">&amp;</span>workers, TCP.fail_stop().bincode());
<span class="comment">// if there are 4 members in the cluster, each receives one element
// - MemberId::&lt;()&gt;(0): [0]
// - MemberId::&lt;()&gt;(1): [1]
// - MemberId::&lt;()&gt;(2): [2]
// - MemberId::&lt;()&gt;(3): [3]</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3C(MemberId%3CL2%3E,+K),+T,+Process%3C'a,+L%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#140-260">Source</a><a href="#impl-KeyedStream%3C(MemberId%3CL2%3E,+K),+T,+Process%3C'a,+L%3E,+B,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, T, L, L2, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;(<a class="struct" href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L2&gt;, K), T, <a class="struct" href="../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L&gt;, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle deprecated" open><summary><section id="method.demux_bincode-1" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#177-186">Source</a><h4 class="code-header">pub fn <a href="#method.demux_bincode-1" class="fn">demux_bincode</a>(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, T, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    K: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a>,
    T: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">üëé</span><span>Deprecated: use KeyedStream::demux(‚Ä¶, TCP.fail_stop().bincode()) instead</span></div></span></summary><div class="docblock"><p>Sends each group of this stream to a specific member of a cluster. The input stream has a
compound key where the first element is the recipient‚Äôs <a href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId"><code>MemberId</code></a> and the second element
is a key that will be sent along with the value, using <a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize
messages.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>p1 = flow.process::&lt;()&gt;();
<span class="kw">let </span>workers: Cluster&lt;()&gt; = flow.cluster::&lt;()&gt;();
<span class="kw">let </span>to_send: KeyedStream&lt;<span class="kw">_</span>, <span class="kw">_</span>, Process&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = p1
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))
    .map(<span class="macro">q!</span>(|x| ((hydro_lang::location::MemberId::from_raw_id(x), x), x + <span class="number">123</span>)))
    .into_keyed();
<span class="kw">let </span>on_worker: KeyedStream&lt;<span class="kw">_</span>, <span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = to_send.demux_bincode(<span class="kw-2">&amp;</span>workers);
<span class="comment">// if there are 4 members in the cluster, each receives one element
// - MemberId::&lt;()&gt;(0): { 0: [123] }
// - MemberId::&lt;()&gt;(1): { 1: [124] }
// - ...</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.demux-1" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#221-259">Source</a><h4 class="code-header">pub fn <a href="#method.demux-1" class="fn">demux</a>&lt;N: <a class="trait" href="../networking/trait.NetworkFor.html" title="trait hydro_lang::networking::NetworkFor">NetworkFor</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, T)</a>&gt;&gt;(
    self,
    to: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
    via: N,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, T, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    K: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a>,
    T: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>Sends each group of this stream to a specific member of a cluster. The input stream has a
compound key where the first element is the recipient‚Äôs <a href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId"><code>MemberId</code></a> and the second element
is a key that will be sent along with the value, using the configuration in <code>via</code> to set up
the message transport.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>p1 = flow.process::&lt;()&gt;();
<span class="kw">let </span>workers: Cluster&lt;()&gt; = flow.cluster::&lt;()&gt;();
<span class="kw">let </span>to_send: KeyedStream&lt;<span class="kw">_</span>, <span class="kw">_</span>, Process&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = p1
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))
    .map(<span class="macro">q!</span>(|x| ((hydro_lang::location::MemberId::from_raw_id(x), x), x + <span class="number">123</span>)))
    .into_keyed();
<span class="kw">let </span>on_worker: KeyedStream&lt;<span class="kw">_</span>, <span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = to_send.demux(<span class="kw-2">&amp;</span>workers, TCP.fail_stop().bincode());
<span class="comment">// if there are 4 members in the cluster, each receives one element
// - MemberId::&lt;()&gt;(0): { 0: [123] }
// - MemberId::&lt;()&gt;(1): { 1: [124] }
// - ...</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CMemberId%3CL2%3E,+T,+Cluster%3C'a,+L%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#262-409">Source</a><a href="#impl-KeyedStream%3CMemberId%3CL2%3E,+T,+Cluster%3C'a,+L%3E,+B,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, T, L, L2, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;<a class="struct" href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L2&gt;, T, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L&gt;, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle deprecated" open><summary><section id="method.demux_bincode-2" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#313-321">Source</a><h4 class="code-header">pub fn <a href="#method.demux_bincode-2" class="fn">demux_bincode</a>(
    self,
    other: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;<a class="struct" href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L&gt;, T, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">üëé</span><span>Deprecated: use KeyedStream::demux(‚Ä¶, TCP.fail_stop().bincode()) instead</span></div></span></summary><div class="docblock"><p>Sends each group of this stream at each source member to a specific member of a destination
cluster, with the <a href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId"><code>MemberId</code></a> key identifying the recipient for each group and using
<a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize messages.</p>
<p>Each key must be a <code>MemberId&lt;L2&gt;</code> and each value must be a <code>T</code> where the key specifies
which cluster member should receive the data. Unlike <a href="struct.Stream.html#method.broadcast_bincode" title="method hydro_lang::live_collections::Stream::broadcast_bincode"><code>Stream::broadcast_bincode</code></a>, this
API allows precise targeting of specific cluster members rather than broadcasting to all
members.</p>
<p>Each cluster member sends its local stream elements, and they are collected at each
destination member as a <a href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream"><code>KeyedStream</code></a> where keys identify the source cluster member.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>source: Cluster&lt;Source&gt; = flow.cluster::&lt;Source&gt;();
<span class="kw">let </span>to_send: KeyedStream&lt;<span class="kw">_</span>, <span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = source
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))
    .map(<span class="macro">q!</span>(|x| (hydro_lang::location::MemberId::from_raw_id(x), x)))
    .into_keyed();
<span class="kw">let </span>destination: Cluster&lt;Destination&gt; = flow.cluster::&lt;Destination&gt;();
<span class="kw">let </span>all_received = to_send.demux_bincode(<span class="kw-2">&amp;</span>destination); <span class="comment">// KeyedStream&lt;MemberId&lt;Source&gt;, i32, ...&gt;
// if there are 4 members in the destination cluster, each receives one message from each source member
// - Destination(0): { Source(0): [0], Source(1): [0], ... }
// - Destination(1): { Source(0): [1], Source(1): [1], ... }
// - ...</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.demux-2" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#370-408">Source</a><h4 class="code-header">pub fn <a href="#method.demux-2" class="fn">demux</a>&lt;N: <a class="trait" href="../networking/trait.NetworkFor.html" title="trait hydro_lang::networking::NetworkFor">NetworkFor</a>&lt;T&gt;&gt;(
    self,
    to: &amp;<a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
    via: N,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;<a class="struct" href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L&gt;, T, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>Sends each group of this stream at each source member to a specific member of a destination
cluster, with the <a href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId"><code>MemberId</code></a> key identifying the recipient for each group and using the
configuration in <code>via</code> to set up the message transport.</p>
<p>Each key must be a <code>MemberId&lt;L2&gt;</code> and each value must be a <code>T</code> where the key specifies
which cluster member should receive the data. Unlike <a href="struct.Stream.html#method.broadcast" title="method hydro_lang::live_collections::Stream::broadcast"><code>Stream::broadcast</code></a>, this
API allows precise targeting of specific cluster members rather than broadcasting to all
members.</p>
<p>Each cluster member sends its local stream elements, and they are collected at each
destination member as a <a href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream"><code>KeyedStream</code></a> where keys identify the source cluster member.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>source: Cluster&lt;Source&gt; = flow.cluster::&lt;Source&gt;();
<span class="kw">let </span>to_send: KeyedStream&lt;<span class="kw">_</span>, <span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = source
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))
    .map(<span class="macro">q!</span>(|x| (hydro_lang::location::MemberId::from_raw_id(x), x)))
    .into_keyed();
<span class="kw">let </span>destination: Cluster&lt;Destination&gt; = flow.cluster::&lt;Destination&gt;();
<span class="kw">let </span>all_received = to_send.demux(<span class="kw-2">&amp;</span>destination, TCP.fail_stop().bincode()); <span class="comment">// KeyedStream&lt;MemberId&lt;Source&gt;, i32, ...&gt;
// if there are 4 members in the destination cluster, each receives one message from each source member
// - Destination(0): { Source(0): [0], Source(1): [0], ... }
// - Destination(1): { Source(0): [1], Source(1): [1], ... }
// - ...</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+Cluster%3C'a,+L%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#411-579">Source</a><a href="#impl-KeyedStream%3CK,+V,+Cluster%3C'a,+L%3E,+B,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L&gt;, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle deprecated" open><summary><section id="method.send_bincode" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#470-479">Source</a><h4 class="code-header">pub fn <a href="#method.send_bincode" class="fn">send_bincode</a>&lt;L2&gt;(
    self,
    other: &amp;<a class="struct" href="../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L2&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;(<a class="struct" href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L&gt;, K), V, <a class="struct" href="../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L2&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    K: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a>,
    V: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">üëé</span><span>Deprecated: use KeyedStream::send(‚Ä¶, TCP.fail_stop().bincode()) instead</span></div></span></summary><div class="docblock"><p>‚ÄúMoves‚Äù elements of this keyed stream from a cluster to a process by sending them over the
network, using <a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize messages. The resulting <a href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream"><code>KeyedStream</code></a>
has a compound key where the first element is the sender‚Äôs <a href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId"><code>MemberId</code></a> and the second
element is the original key.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>source: Cluster&lt;Source&gt; = flow.cluster::&lt;Source&gt;();
<span class="kw">let </span>to_send: KeyedStream&lt;<span class="kw">_</span>, <span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = source
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))
    .map(<span class="macro">q!</span>(|x| (x, x + <span class="number">123</span>)))
    .into_keyed();
<span class="kw">let </span>destination_process = flow.process::&lt;Destination&gt;();
<span class="kw">let </span>all_received = to_send.send_bincode(<span class="kw-2">&amp;</span>destination_process); <span class="comment">// KeyedStream&lt;(MemberId&lt;Source&gt;, i32), i32, ...&gt;
// if there are 4 members in the source cluster, the destination process receives four messages from each source member
// {
//     (MemberId&lt;Source&gt;(0), 0): [123], (MemberId&lt;Source&gt;(1), 0): [123], ...,
//     (MemberId&lt;Source&gt;(0), 1): [124], (MemberId&lt;Source&gt;(1), 1): [124], ...,
//     ...
// }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.send" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/networking.rs.html#536-578">Source</a><h4 class="code-header">pub fn <a href="#method.send" class="fn">send</a>&lt;L2, N: <a class="trait" href="../networking/trait.NetworkFor.html" title="trait hydro_lang::networking::NetworkFor">NetworkFor</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>&gt;&gt;(
    self,
    to: &amp;<a class="struct" href="../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L2&gt;,
    via: N,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;(<a class="struct" href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L&gt;, K), V, <a class="struct" href="../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L2&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    K: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a>,
    V: <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/ser/trait.Serialize.html" title="trait serde_core::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde_core/1.0.228/serde_core/de/trait.DeserializeOwned.html" title="trait serde_core::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>‚ÄúMoves‚Äù elements of this keyed stream from a cluster to a process by sending them over the
network, using the configuration in <code>via</code> to set up the message transport. The resulting
<a href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream"><code>KeyedStream</code></a> has a compound key where the first element is the sender‚Äôs <a href="../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId"><code>MemberId</code></a> and
the second element is the original key.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>source: Cluster&lt;Source&gt; = flow.cluster::&lt;Source&gt;();
<span class="kw">let </span>to_send: KeyedStream&lt;<span class="kw">_</span>, <span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = source
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))
    .map(<span class="macro">q!</span>(|x| (x, x + <span class="number">123</span>)))
    .into_keyed();
<span class="kw">let </span>destination_process = flow.process::&lt;Destination&gt;();
<span class="kw">let </span>all_received = to_send.send(<span class="kw-2">&amp;</span>destination_process, TCP.fail_stop().bincode()); <span class="comment">// KeyedStream&lt;(MemberId&lt;Source&gt;, i32), i32, ...&gt;
// if there are 4 members in the source cluster, the destination process receives four messages from each source member
// {
//     (MemberId&lt;Source&gt;(0), 0): [123], (MemberId&lt;Source&gt;(1), 0): [123], ...,
//     (MemberId&lt;Source&gt;(0), 1): [124], (MemberId&lt;Source&gt;(1), 1): [124], ...,
//     ...
// }</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#223-1193">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+B,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.collection_kind" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#238-246">Source</a><h4 class="code-header">pub fn <a href="#method.collection_kind" class="fn">collection_kind</a>() -&gt; <a class="enum" href="../compile/ir/enum.CollectionKind.html" title="enum hydro_lang::compile::ir::CollectionKind">CollectionKind</a></h4></section></summary><div class="docblock"><p>Returns the <a href="../compile/ir/enum.CollectionKind.html" title="enum hydro_lang::compile::ir::CollectionKind"><code>CollectionKind</code></a> corresponding to this type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.location" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#249-251">Source</a><h4 class="code-header">pub fn <a href="#method.location" class="fn">location</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;L</a></h4></section></summary><div class="docblock"><p>Returns the <a href="../location/trait.Location.html" title="trait hydro_lang::location::Location"><code>Location</code></a> where this keyed stream is being materialized.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_ordering" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#261-287">Source</a><h4 class="code-header">pub fn <a href="#method.assume_ordering" class="fn">assume_ordering</a>&lt;O2: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>&gt;(
    self,
    _nondet: <a class="struct" href="../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O2, R&gt;</h4></section></summary><div class="docblock"><p>Explicitly ‚Äúcasts‚Äù the keyed stream to a type with a different ordering
guarantee for each group. Useful in unsafe code where the ordering cannot be proven
by the type-system.</p>
<h5 id="non-determinism"><a class="doc-anchor" href="#non-determinism">¬ß</a>Non-Determinism</h5>
<p>This function is used as an escape hatch, and any mistakes in the
provided ordering guarantee will propagate into the guarantees
for the rest of the program.</p>
</div></details><details class="toggle method-toggle deprecated" open><summary><section id="method.weakest_ordering" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#323-325">Source</a><h4 class="code-header">pub fn <a href="#method.weakest_ordering" class="fn">weakest_ordering</a>(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">üëé</span><span>Deprecated: use <code>weaken_ordering::&lt;NoOrder&gt;()</code> instead</span></div></span></summary><div class="docblock"><p>Weakens the ordering guarantee provided by the stream to <a href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder"><code>NoOrder</code></a>,
which is always safe because that is the weakest possible guarantee.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.weaken_ordering" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#329-332">Source</a><h4 class="code-header">pub fn <a href="#method.weaken_ordering" class="fn">weaken_ordering</a>&lt;O2: <a class="trait" href="stream/trait.WeakerOrderingThan.html" title="trait hydro_lang::live_collections::stream::WeakerOrderingThan">WeakerOrderingThan</a>&lt;O&gt;&gt;(
    self,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O2, R&gt;</h4></section></summary><div class="docblock"><p>Weakens the ordering guarantee provided by the stream to <code>O2</code>, with the type-system
enforcing that <code>O2</code> is weaker than the input ordering guarantee.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_retries" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#342-368">Source</a><h4 class="code-header">pub fn <a href="#method.assume_retries" class="fn">assume_retries</a>&lt;R2: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    _nondet: <a class="struct" href="../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R2&gt;</h4></section></summary><div class="docblock"><p>Explicitly ‚Äúcasts‚Äù the keyed stream to a type with a different retries
guarantee for each group. Useful in unsafe code where the lack of retries cannot
be proven by the type-system.</p>
<h5 id="non-determinism-1"><a class="doc-anchor" href="#non-determinism-1">¬ß</a>Non-Determinism</h5>
<p>This function is used as an escape hatch, and any mistakes in the
provided retries guarantee will propagate into the guarantees
for the rest of the program.</p>
</div></details><details class="toggle method-toggle deprecated" open><summary><section id="method.weakest_retries" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#373-375">Source</a><h4 class="code-header">pub fn <a href="#method.weakest_retries" class="fn">weakest_retries</a>(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, <a class="enum" href="stream/enum.AtLeastOnce.html" title="enum hydro_lang::live_collections::stream::AtLeastOnce">AtLeastOnce</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">üëé</span><span>Deprecated: use <code>weaken_retries::&lt;AtLeastOnce&gt;()</code> instead</span></div></span></summary><div class="docblock"><p>Weakens the retries guarantee provided by the stream to <a href="stream/enum.AtLeastOnce.html" title="enum hydro_lang::live_collections::stream::AtLeastOnce"><code>AtLeastOnce</code></a>,
which is always safe because that is the weakest possible guarantee.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.weaken_retries" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#379-382">Source</a><h4 class="code-header">pub fn <a href="#method.weaken_retries" class="fn">weaken_retries</a>&lt;R2: <a class="trait" href="stream/trait.WeakerRetryThan.html" title="trait hydro_lang::live_collections::stream::WeakerRetryThan">WeakerRetryThan</a>&lt;R&gt;&gt;(
    self,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R2&gt;</h4></section></summary><div class="docblock"><p>Weakens the retries guarantee provided by the stream to <code>R2</code>, with the type-system
enforcing that <code>R2</code> is weaker than the input retries guarantee.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.entries" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#407-417">Source</a><h4 class="code-header">pub fn <a href="#method.entries" class="fn">entries</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;</h4></section></summary><div class="docblock"><p>Flattens the keyed stream into an unordered stream of key-value pairs.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .entries()
<span class="comment">// (1, 2), (1, 3), (2, 4) in any order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.values" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#442-444">Source</a><h4 class="code-header">pub fn <a href="#method.values" class="fn">values</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;V, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;</h4></section></summary><div class="docblock"><p>Flattens the keyed stream into an unordered stream of only the values.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .values()
<span class="comment">// 2, 3, 4 in any order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.keys" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#469-474">Source</a><h4 class="code-header">pub fn <a href="#method.keys" class="fn">keys</a>(self) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;K, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Flattens the keyed stream into an unordered stream of just the keys.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 1, 2 in any order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.map" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#504-526">Source</a><h4 class="code-header">pub fn <a href="#method.map" class="fn">map</a>&lt;U, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(V) -&gt; U + 'a,</div></h4></section></summary><div class="docblock"><p>Transforms each value by invoking <code>f</code> on each element, with keys staying the same
after transformation. If you need access to the key, see <a href="struct.KeyedStream.html#method.map_with_key" title="method hydro_lang::live_collections::KeyedStream::map_with_key"><code>KeyedStream::map_with_key</code></a>.</p>
<p>If you do not want to modify the stream and instead only want to view
each item use <a href="struct.KeyedStream.html#method.inspect" title="method hydro_lang::live_collections::KeyedStream::inspect"><code>KeyedStream::inspect</code></a> instead.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .map(<span class="macro">q!</span>(|v| v + <span class="number">1</span>))
<span class="comment">// { 1: [3, 4], 2: [5] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.map_with_key" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#556-585">Source</a><h4 class="code-header">pub fn <a href="#method.map_with_key" class="fn">map_with_key</a>&lt;U, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>) -&gt; U + 'a,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Transforms each value by invoking <code>f</code> on each key-value pair. The resulting values are <strong>not</strong>
re-grouped even they are tuples; instead they will be grouped under the original key.</p>
<p>If you do not want to modify the stream and instead only want to view
each item use <a href="struct.KeyedStream.html#method.inspect_with_key" title="method hydro_lang::live_collections::KeyedStream::inspect_with_key"><code>KeyedStream::inspect_with_key</code></a> instead.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .map_with_key(<span class="macro">q!</span>(|(k, v)| k + v))
<span class="comment">// { 1: [3, 4], 2: [6] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.prefix_key" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#613-641">Source</a><h4 class="code-header">pub fn <a href="#method.prefix_key" class="fn">prefix_key</a>&lt;K2, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K2, K)</a>, V, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>) -&gt; K2 + 'a,</div></h4></section></summary><div class="docblock"><p>Prepends a new value to the key of each element in the stream, producing a new
keyed stream with compound keys. Because the original key is preserved, no re-grouping
occurs and the elements in each group preserve their original order.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .prefix_key(<span class="macro">q!</span>(|<span class="kw-2">&amp;</span>(k, <span class="kw">_</span>)| k % <span class="number">2</span>))
<span class="comment">// { (1, 1): [2, 3], (0, 2): [4] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#672-692">Source</a><h4 class="code-header">pub fn <a href="#method.filter" class="fn">filter</a>&lt;F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;V</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> + 'a,</div></h4></section></summary><div class="docblock"><p>Creates a stream containing only the elements of each group stream that satisfy a predicate
<code>f</code>, preserving the order of the elements within the group.</p>
<p>The closure <code>f</code> receives a reference <code>&amp;V</code> rather than an owned value <code>v</code> because filtering does
not modify or take ownership of the values. If you need to modify the values while filtering
use <a href="struct.KeyedStream.html#method.filter_map" title="method hydro_lang::live_collections::KeyedStream::filter_map"><code>KeyedStream::filter_map</code></a> instead.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .filter(<span class="macro">q!</span>(|<span class="kw-2">&amp;</span>x| x &gt; <span class="number">2</span>))
<span class="comment">// { 1: [3], 2: [4] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_with_key" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#723-742">Source</a><h4 class="code-header">pub fn <a href="#method.filter_with_key" class="fn">filter_with_key</a>&lt;F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> + 'a,</div></h4></section></summary><div class="docblock"><p>Creates a stream containing only the elements of each group stream that satisfy a predicate
<code>f</code> (which receives the key-value tuple), preserving the order of the elements within the group.</p>
<p>The closure <code>f</code> receives a reference <code>&amp;(K, V)</code> rather than an owned value <code>(K, V)</code> because filtering does
not modify or take ownership of the values. If you need to modify the values while filtering
use <a href="struct.KeyedStream.html#method.filter_map_with_key" title="method hydro_lang::live_collections::KeyedStream::filter_map_with_key"><code>KeyedStream::filter_map_with_key</code></a> instead.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .filter_with_key(<span class="macro">q!</span>(|<span class="kw-2">&amp;</span>(k, v)| v - k == <span class="number">2</span>))
<span class="comment">// { 1: [3], 2: [4] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_map" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#770-795">Source</a><h4 class="code-header">pub fn <a href="#method.filter_map" class="fn">filter_map</a>&lt;U, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(V) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;U&gt; + 'a,</div></h4></section></summary><div class="docblock"><p>An operator that both filters and maps each value, with keys staying the same.
It yields only the items for which the supplied closure <code>f</code> returns <code>Some(value)</code>.
If you need access to the key, see <a href="struct.KeyedStream.html#method.filter_map_with_key" title="method hydro_lang::live_collections::KeyedStream::filter_map_with_key"><code>KeyedStream::filter_map_with_key</code></a>.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="string">"2"</span>), (<span class="number">1</span>, <span class="string">"hello"</span>), (<span class="number">2</span>, <span class="string">"4"</span>)]))
    .into_keyed()
    .filter_map(<span class="macro">q!</span>(|s| s.parse::&lt;usize&gt;().ok()))
<span class="comment">// { 1: [2], 2: [4] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_map_with_key" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#823-852">Source</a><h4 class="code-header">pub fn <a href="#method.filter_map_with_key" class="fn">filter_map_with_key</a>&lt;U, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;U&gt; + 'a,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>An operator that both filters and maps each key-value pair. The resulting values are <strong>not</strong>
re-grouped even they are tuples; instead they will be grouped under the original key.
It yields only the items for which the supplied closure <code>f</code> returns <code>Some(value)</code>.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="string">"2"</span>), (<span class="number">1</span>, <span class="string">"hello"</span>), (<span class="number">2</span>, <span class="string">"2"</span>)]))
    .into_keyed()
    .filter_map_with_key(<span class="macro">q!</span>(|(k, s)| s.parse::&lt;usize&gt;().ok().filter(|v| v == <span class="kw-2">&amp;</span>k)))
<span class="comment">// { 2: [2] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cross_singleton" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#882-904">Source</a><h4 class="code-header">pub fn <a href="#method.cross_singleton" class="fn">cross_singleton</a>&lt;O2&gt;(
    self,
    other: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;O2, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(V, O2)</a>, L, B, O, R&gt;<div class="where">where
    O2: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Generates a keyed stream that maps each value <code>v</code> to a tuple <code>(v, x)</code>,
where <code>v</code> is the value of <code>other</code>, a bounded <a href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>super::singleton::Singleton</code></a> or
<a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>. If <code>other</code> is an empty <a href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>, no values will be produced.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>batch = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">123</span>), (<span class="number">1</span>, <span class="number">456</span>), (<span class="number">2</span>, <span class="number">123</span>)]))
  .into_keyed()
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>count = batch.clone().entries().count(); <span class="comment">// `count()` returns a singleton
</span>batch.cross_singleton(count).all_ticks().entries()
<span class="comment">// { 1: [(123, 3), (456, 3)], 2: [(123, 3)] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flat_map_ordered" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#936-963">Source</a><h4 class="code-header">pub fn <a href="#method.flat_map_ordered" class="fn">flat_map_ordered</a>&lt;U, I, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, O, R&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(V) -&gt; I + 'a,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>For each value <code>v</code> in each group, transform <code>v</code> using <code>f</code> and then treat the
result as an <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> to produce values one by one within the same group.
The implementation for <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> for the output type <code>I</code> must produce items
in a <strong>deterministic</strong> order.</p>
<p>For example, <code>I</code> could be a <code>Vec</code>, but not a <code>HashSet</code>. If the order of the items in <code>I</code> is
not deterministic, use <a href="struct.KeyedStream.html#method.flat_map_unordered" title="method hydro_lang::live_collections::KeyedStream::flat_map_unordered"><code>KeyedStream::flat_map_unordered</code></a> instead.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">3</span>]), (<span class="number">1</span>, <span class="macro">vec!</span>[<span class="number">4</span>]), (<span class="number">2</span>, <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">6</span>])]))
    .into_keyed()
    .flat_map_ordered(<span class="macro">q!</span>(|x| x))
<span class="comment">// { 1: [2, 3, 4], 2: [5, 6] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flat_map_unordered" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#993-1020">Source</a><h4 class="code-header">pub fn <a href="#method.flat_map_unordered" class="fn">flat_map_unordered</a>&lt;U, I, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(V) -&gt; I + 'a,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Like <a href="struct.KeyedStream.html#method.flat_map_ordered" title="method hydro_lang::live_collections::KeyedStream::flat_map_ordered"><code>KeyedStream::flat_map_ordered</code></a>, but allows the implementation of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>
for the output type <code>I</code> to produce items in any order.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[
        (<span class="number">1</span>, std::collections::HashSet::&lt;i32&gt;::from_iter(<span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">3</span>])),
        (<span class="number">2</span>, std::collections::HashSet::from_iter(<span class="macro">vec!</span>[<span class="number">4</span>, <span class="number">5</span>]))
    ]))
    .into_keyed()
    .flat_map_unordered(<span class="macro">q!</span>(|x| x))
<span class="comment">// { 1: [2, 3], 2: [4, 5] } with values in each group in unknown order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flatten_ordered" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1051-1057">Source</a><h4 class="code-header">pub fn <a href="#method.flatten_ordered" class="fn">flatten_ordered</a>&lt;U&gt;(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, O, R&gt;<div class="where">where
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>For each value <code>v</code> in each group, treat <code>v</code> as an <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> and produce its items one by one
within the same group. The implementation for <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> for the value type <code>V</code> must produce
items in a <strong>deterministic</strong> order.</p>
<p>For example, <code>V</code> could be a <code>Vec</code>, but not a <code>HashSet</code>. If the order of the items in <code>V</code> is
not deterministic, use <a href="struct.KeyedStream.html#method.flatten_unordered" title="method hydro_lang::live_collections::KeyedStream::flatten_unordered"><code>KeyedStream::flatten_unordered</code></a> instead.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">3</span>]), (<span class="number">1</span>, <span class="macro">vec!</span>[<span class="number">4</span>]), (<span class="number">2</span>, <span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">6</span>])]))
    .into_keyed()
    .flatten_ordered()
<span class="comment">// { 1: [2, 3, 4], 2: [5, 6] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flatten_unordered" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1087-1093">Source</a><h4 class="code-header">pub fn <a href="#method.flatten_unordered" class="fn">flatten_unordered</a>&lt;U&gt;(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Like <a href="struct.KeyedStream.html#method.flatten_ordered" title="method hydro_lang::live_collections::KeyedStream::flatten_ordered"><code>KeyedStream::flatten_ordered</code></a>, but allows the implementation of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>
for the value type <code>V</code> to produce items in any order.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[
        (<span class="number">1</span>, std::collections::HashSet::&lt;i32&gt;::from_iter(<span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">3</span>])),
        (<span class="number">2</span>, std::collections::HashSet::from_iter(<span class="macro">vec!</span>[<span class="number">4</span>, <span class="number">5</span>]))
    ]))
    .into_keyed()
    .flatten_unordered()
<span class="comment">// { 1: [2, 3], 2: [4, 5] } with values in each group in unknown order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.inspect" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1120-1140">Source</a><h4 class="code-header">pub fn <a href="#method.inspect" class="fn">inspect</a>&lt;F&gt;(self, f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;V</a>) + 'a,</div></h4></section></summary><div class="docblock"><p>An operator which allows you to ‚Äúinspect‚Äù each element of a stream without
modifying it. The closure <code>f</code> is called on a reference to each value. This is
mainly useful for debugging, and should not be used to generate side-effects.</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .inspect(<span class="macro">q!</span>(|v| <span class="macro">println!</span>(<span class="string">"{}"</span>, v)))</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.inspect_with_key" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1167-1181">Source</a><h4 class="code-header">pub fn <a href="#method.inspect_with_key" class="fn">inspect_with_key</a>&lt;F&gt;(self, f: impl IntoQuotedMut&lt;'a, F, L&gt;) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>) + 'a,</div></h4></section></summary><div class="docblock"><p>An operator which allows you to ‚Äúinspect‚Äù each element of a stream without
modifying it. The closure <code>f</code> is called on a reference to each key-value pair. This is
mainly useful for debugging, and should not be used to generate side-effects.</p>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
    .inspect_with_key(<span class="macro">q!</span>(|(k, v)| <span class="macro">println!</span>(<span class="string">"{}: {}"</span>, k, v)))</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ir_node_named" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1185-1192">Source</a><h4 class="code-header">pub fn <a href="#method.ir_node_named" class="fn">ir_node_named</a>(self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;</h4></section></summary><div class="docblock"><p>An operator which allows you to ‚Äúname‚Äù a <code>HydroNode</code>.
This is only used for testing, to correlate certain <code>HydroNode</code>s with IDs.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3C(K1,+K2),+V,+L,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1195-1231">Source</a><a href="#impl-KeyedStream%3C(K1,+K2),+V,+L,+B,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K1, K2, V, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K1, K2)</a>, V, L, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.drop_key_prefix" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1226-1230">Source</a><h4 class="code-header">pub fn <a href="#method.drop_key_prefix" class="fn">drop_key_prefix</a>(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K2, V, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;</h4></section></summary><div class="docblock"><p>Produces a new keyed stream by dropping the first element of the compound key.</p>
<p>Because multiple keys may share the same suffix, this operation results in re-grouping
of the values under the new keys. The values across groups with the same new key
will be interleaved, so the resulting stream has <a href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder"><code>NoOrder</code></a> within each group.</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[((<span class="number">1</span>, <span class="number">10</span>), <span class="number">2</span>), ((<span class="number">1</span>, <span class="number">10</span>), <span class="number">3</span>), ((<span class="number">2</span>, <span class="number">20</span>), <span class="number">4</span>)]))
    .into_keyed()
    .drop_key_prefix()
<span class="comment">// { 10: [2, 3], 20: [4] }</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+Unbounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1233-1289">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+Unbounded,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.interleave" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1266-1288">Source</a><h4 class="code-header">pub fn <a href="#method.interleave" class="fn">interleave</a>&lt;O2: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R2: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    other: <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O2, R2&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, &lt;R as <a class="trait" href="stream/trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;&gt;::<a class="associatedtype" href="stream/trait.MinRetries.html#associatedtype.Min" title="type hydro_lang::live_collections::stream::MinRetries::Min">Min</a>&gt;<div class="where">where
    R: <a class="trait" href="stream/trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;,</div></h4></section></summary><div class="docblock"><p>Produces a new keyed stream that ‚Äúmerges‚Äù the inputs by interleaving the elements
of any overlapping groups. The result has <a href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder"><code>NoOrder</code></a> on each group because the
order of interleaving is not guaranteed. If the keys across both inputs do not overlap,
the ordering will be deterministic and you can safely use <a href="struct.KeyedStream.html#method.assume_ordering" title="method hydro_lang::live_collections::KeyedStream::assume_ordering"><code>Self::assume_ordering</code></a>.</p>
<p>Currently, both input streams must be <a href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a>.</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>numbers1: KeyedStream&lt;i32, i32, <span class="kw">_</span>&gt; = <span class="comment">// { 1: [2], 3: [4] }
</span><span class="kw">let </span>numbers2: KeyedStream&lt;i32, i32, <span class="kw">_</span>&gt; = <span class="comment">// { 1: [3], 3: [5] }
</span>numbers1.interleave(numbers2)
<span class="comment">// { 1: [2, 3], 3: [4, 5] } with each group in unknown order</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+B%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1304-1604">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+B%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.scan" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1346-1370">Source</a><h4 class="code-header">pub fn <a href="#method.scan" class="fn">scan</a>&lt;A, U, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;U&gt; + 'a,</div></h4></section></summary><div class="docblock"><p>A special case of <a href="struct.Stream.html#method.scan" title="method hydro_lang::live_collections::Stream::scan"><code>Stream::scan</code></a> for keyed streams. For each key group the values are transformed via the <code>f</code> combinator.</p>
<p>Unlike <a href="struct.KeyedStream.html#method.fold" title="method hydro_lang::live_collections::KeyedStream::fold"><code>KeyedStream::fold</code></a> which only returns the final accumulated value, <code>scan</code> produces a new stream
containing all intermediate accumulated values paired with the key. The scan operation can also terminate
early by returning <code>None</code>.</p>
<p>The function takes a mutable reference to the accumulator and the current element, and returns
an <code>Option&lt;U&gt;</code>. If the function returns <code>Some(value)</code>, <code>value</code> is emitted to the output stream.
If the function returns <code>None</code>, the stream is terminated and no more elements are processed.</p>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>)]))
    .into_keyed()
    .scan(
        <span class="macro">q!</span>(|| <span class="number">0</span>),
        <span class="macro">q!</span>(|acc, x| {
            <span class="kw-2">*</span>acc += x;
            <span class="kw">if </span><span class="kw-2">*</span>acc % <span class="number">2 </span>== <span class="number">0 </span>{ <span class="prelude-val">None </span>} <span class="kw">else </span>{ <span class="prelude-val">Some</span>(<span class="kw-2">*</span>acc) }
        }),
    )
<span class="comment">// Output: { 0: [1], 1: [3, 7] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.generator" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1420-1488">Source</a><h4 class="code-header">pub fn <a href="#method.generator" class="fn">generator</a>&lt;A, U, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, U, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V) -&gt; <a class="enum" href="keyed_stream/enum.Generate.html" title="enum hydro_lang::live_collections::keyed_stream::Generate">Generate</a>&lt;U&gt; + 'a,</div></h4></section></summary><div class="docblock"><p>Iteratively processes the elements in each group using a state machine that can yield
elements as it processes its inputs. This is designed to mirror the unstable generator
syntax in Rust, without requiring special syntax.</p>
<p>Like <a href="struct.KeyedStream.html#method.scan" title="method hydro_lang::live_collections::KeyedStream::scan"><code>KeyedStream::scan</code></a>, this function takes in an initializer that emits the initial
state for each group. The second argument defines the processing logic, taking in a
mutable reference to the group‚Äôs state and the value to be processed. It emits a
<a href="keyed_stream/enum.Generate.html" title="enum hydro_lang::live_collections::keyed_stream::Generate"><code>Generate</code></a> value, whose variants define what is emitted and whether further inputs
should be processed.</p>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">100</span>), (<span class="number">0</span>, <span class="number">10</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">3</span>)]))
    .into_keyed()
    .generator(
        <span class="macro">q!</span>(|| <span class="number">0</span>),
        <span class="macro">q!</span>(|acc, x| {
            <span class="kw-2">*</span>acc += x;
            <span class="kw">if </span><span class="kw-2">*</span>acc &gt; <span class="number">100 </span>{
                hydro_lang::live_collections::keyed_stream::Generate::Return(
                    <span class="string">"done!"</span>.to_owned()
                )
            } <span class="kw">else if </span><span class="kw-2">*</span>acc % <span class="number">2 </span>== <span class="number">0 </span>{
                hydro_lang::live_collections::keyed_stream::Generate::Yield(
                    <span class="string">"even"</span>.to_owned()
                )
            } <span class="kw">else </span>{
                hydro_lang::live_collections::keyed_stream::Generate::Continue
            }
        }),
    )
<span class="comment">// Output: { 0: ["even", "done!"], 1: ["even"] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.fold_early_stop" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1525-1563">Source</a><h4 class="code-header">pub fn <a href="#method.fold_early_stop" class="fn">fold_early_stop</a>&lt;A, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
    f: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, A, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueBounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueBounded">WhenValueBounded</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> + 'a,</div></h4></section></summary><div class="docblock"><p>A variant of <a href="struct.Stream.html#method.fold" title="method hydro_lang::live_collections::Stream::fold"><code>Stream::fold</code></a>, intended for keyed streams. The aggregation is executed
in-order across the values in each group. But the aggregation function returns a boolean,
which when true indicates that the aggregated result is complete and can be released to
downstream computation. Unlike <a href="struct.KeyedStream.html#method.fold" title="method hydro_lang::live_collections::KeyedStream::fold"><code>KeyedStream::fold</code></a>, this means that even if the input
stream is <a href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>super::boundedness::Unbounded</code></a>, the outputs of the fold can be processed like
normal stream elements.</p>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">6</span>)]))
    .into_keyed()
    .fold_early_stop(
        <span class="macro">q!</span>(|| <span class="number">0</span>),
        <span class="macro">q!</span>(|acc, x| {
            <span class="kw-2">*</span>acc += x;
            x % <span class="number">2 </span>== <span class="number">0
        </span>}),
    )
<span class="comment">// Output: { 0: 2, 1: 9 }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.first" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1591-1603">Source</a><h4 class="code-header">pub fn <a href="#method.first" class="fn">first</a>(self) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueBounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueBounded">WhenValueBounded</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Gets the first element inside each group of values as a <a href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton"><code>KeyedSingleton</code></a> that preserves
the original group keys. Requires the input stream to have <a href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantees,
otherwise the first element would be non-deterministic.</p>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">6</span>)]))
    .into_keyed()
    .first()
<span class="comment">// Output: { 0: 2, 1: 3 }</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+B,+O%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1606-1647">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+B,+O%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.value_counts" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1638-1646">Source</a><h4 class="code-header">pub fn <a href="#method.value_counts" class="fn">value_counts</a>(self) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Counts the number of elements in each group, producing a <a href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton"><code>KeyedSingleton</code></a> with the counts.</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">5</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .value_counts()
    .entries()
    .all_ticks()
<span class="comment">// (1, 3), (2, 2)</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+B,+O,+R%3E-1" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1649-1944">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+B,+O,+R%3E-1" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1688-1720">Source</a><h4 class="code-header">pub fn <a href="#method.fold" class="fn">fold</a>&lt;A, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V), C, Idemp&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L, <a class="struct" href="../properties/struct.AggFuncAlgebra.html" title="struct hydro_lang::properties::AggFuncAlgebra">AggFuncAlgebra</a>&lt;C, Idemp&gt;&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, A, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    C: <a class="trait" href="../properties/trait.ValidCommutativityFor.html" title="trait hydro_lang::properties::ValidCommutativityFor">ValidCommutativityFor</a>&lt;O&gt;,
    Idemp: <a class="trait" href="../properties/trait.ValidIdempotenceFor.html" title="trait hydro_lang::properties::ValidIdempotenceFor">ValidIdempotenceFor</a>&lt;R&gt;,</div></h4></section></summary><div class="docblock"><p>Like <a href="struct.Stream.html#method.fold" title="method hydro_lang::live_collections::Stream::fold"><code>Stream::fold</code></a> but in the spirit of SQL <code>GROUP BY</code>, aggregates the values in each
group via the <code>comb</code> closure.</p>
<p>Depending on the input stream guarantees, the closure may need to be commutative
(for unordered streams) or idempotent (for streams with non-deterministic duplicates).</p>
<p>If the input and output value types are the same and do not require initialization then use
<a href="struct.KeyedStream.html#method.reduce" title="method hydro_lang::live_collections::KeyedStream::reduce"><code>KeyedStream::reduce</code></a>.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold(<span class="macro">q!</span>(|| <span class="bool-val">false</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .entries()
    .all_ticks()
<span class="comment">// (1, false), (2, true)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1756-1785">Source</a><h4 class="code-header">pub fn <a href="#method.reduce" class="fn">reduce</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a, C, Idemp&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, L, <a class="struct" href="../properties/struct.AggFuncAlgebra.html" title="struct hydro_lang::properties::AggFuncAlgebra">AggFuncAlgebra</a>&lt;C, Idemp&gt;&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    C: <a class="trait" href="../properties/trait.ValidCommutativityFor.html" title="trait hydro_lang::properties::ValidCommutativityFor">ValidCommutativityFor</a>&lt;O&gt;,
    Idemp: <a class="trait" href="../properties/trait.ValidIdempotenceFor.html" title="trait hydro_lang::properties::ValidIdempotenceFor">ValidIdempotenceFor</a>&lt;R&gt;,</div></h4></section></summary><div class="docblock"><p>Like <a href="struct.Stream.html#method.reduce" title="method hydro_lang::live_collections::Stream::reduce"><code>Stream::reduce</code></a> but in the spirit of SQL <code>GROUP BY</code>, aggregates the values in each
group via the <code>comb</code> closure.</p>
<p>Depending on the input stream guarantees, the closure may need to be commutative
(for unordered streams) or idempotent (for streams with non-deterministic duplicates).</p>
<p>If you need the accumulated value to have a different type than the input, use <a href="struct.KeyedStream.html#method.fold" title="method hydro_lang::live_collections::KeyedStream::fold"><code>KeyedStream::fold</code></a>.</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .entries()
    .all_ticks()
<span class="comment">// (1, false), (2, true)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_watermark" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1815-1850">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_watermark" class="fn">reduce_watermark</a>&lt;O2, F, C, Idemp&gt;(
    self,
    other: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;O2, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L::<a class="associatedtype" href="../location/trait.Location.html#associatedtype.Root" title="type hydro_lang::location::Location::Root">Root</a>&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L, <a class="struct" href="../properties/struct.AggFuncAlgebra.html" title="struct hydro_lang::properties::AggFuncAlgebra">AggFuncAlgebra</a>&lt;C, Idemp&gt;&gt;,
) -&gt; <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V, L, B::<a class="associatedtype" href="boundedness/trait.KeyedBoundFoldLike.html#associatedtype.WhenValueUnbounded" title="type hydro_lang::live_collections::boundedness::KeyedBoundFoldLike::WhenValueUnbounded">WhenValueUnbounded</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    O2: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a,
    C: <a class="trait" href="../properties/trait.ValidCommutativityFor.html" title="trait hydro_lang::properties::ValidCommutativityFor">ValidCommutativityFor</a>&lt;O&gt;,
    Idemp: <a class="trait" href="../properties/trait.ValidIdempotenceFor.html" title="trait hydro_lang::properties::ValidIdempotenceFor">ValidIdempotenceFor</a>&lt;R&gt;,</div></h4></section></summary><div class="docblock"><p>A special case of <a href="struct.KeyedStream.html#method.reduce" title="method hydro_lang::live_collections::KeyedStream::reduce"><code>KeyedStream::reduce</code></a> where tuples with keys less than the watermark
are automatically deleted.</p>
<p>Depending on the input stream guarantees, the closure may need to be commutative
(for unordered streams) or idempotent (for streams with non-deterministic duplicates).</p>
<h5 id="example-34"><a class="doc-anchor" href="#example-34">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>watermark = tick.singleton(<span class="macro">q!</span>(<span class="number">1</span>));
<span class="kw">let </span>numbers = process
    .source_iter(<span class="macro">q!</span>([(<span class="number">0</span>, <span class="bool-val">false</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>)]))
    .into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_watermark(watermark, <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .entries()
    .all_ticks()
<span class="comment">// (2, true)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_key_not_in" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1882-1899">Source</a><h4 class="code-header">pub fn <a href="#method.filter_key_not_in" class="fn">filter_key_not_in</a>&lt;O2: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R2: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    other: <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;K, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O2, R2&gt;,
) -&gt; Self<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Given a bounded stream of keys <code>K</code>, returns a new keyed stream containing only the groups
whose keys are not in the bounded stream.</p>
<h5 id="example-35"><a class="doc-anchor" href="#example-35">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>keyed_stream = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[ (<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>), (<span class="number">4</span>, <span class="string">'d'</span>) ]))
    .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>))
    .into_keyed();
<span class="kw">let </span>keys_to_remove = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]))
    .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
keyed_stream.filter_key_not_in(keys_to_remove).all_ticks()
<span class="comment">// { 3: ['c'], 4: ['d'] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.join_keyed_stream" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1934-1943">Source</a><h4 class="code-header">pub fn <a href="#method.join_keyed_stream" class="fn">join_keyed_stream</a>&lt;V2, O2: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R2: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    other: <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V2, L, B, O2, R2&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(V, V2)</a>, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, &lt;R as <a class="trait" href="stream/trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;&gt;::<a class="associatedtype" href="stream/trait.MinRetries.html#associatedtype.Min" title="type hydro_lang::live_collections::stream::MinRetries::Min">Min</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    R: <a class="trait" href="stream/trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;,</div></h4></section></summary><div class="docblock"><p>Emit a keyed stream containing keys shared between two keyed streams,
where each value in the output keyed stream is a tuple of
(self‚Äôs value, other‚Äôs value).
If there are multiple values for the same key, this performs a cross product
for each matching key.</p>
<h5 id="example-36"><a class="doc-anchor" href="#example-36">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>keyed_data = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">10</span>), (<span class="number">1</span>, <span class="number">11</span>), (<span class="number">2</span>, <span class="number">20</span>)]))
    .into_keyed()
    .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>other_data = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">100</span>), (<span class="number">2</span>, <span class="number">200</span>), (<span class="number">2</span>, <span class="number">201</span>)]))
    .into_keyed()
    .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
keyed_data.join_keyed_stream(other_data).entries().all_ticks()
<span class="comment">// { 1: [(10, 100), (11, 100)], 2: [(20, 200), (20, 201)] } in any order</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+B,+O,+R%3E-2" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1946-1993">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+B,+O,+R%3E-2" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1958-1968">Source</a><h4 class="code-header">pub fn <a href="#method.atomic" class="fn">atomic</a>(self, tick: &amp;<a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, B, O, R&gt;</h4></section></summary><div class="docblock"><p>Shifts this keyed stream into an atomic context, which guarantees that any downstream logic
will all be executed synchronously before any outputs are yielded (in <a href="struct.KeyedStream.html#method.end_atomic" title="method hydro_lang::live_collections::KeyedStream::end_atomic"><code>KeyedStream::end_atomic</code></a>).</p>
<p>This is useful to enforce local consistency constraints, such as ensuring that a write is
processed before an acknowledgement is emitted. Entering an atomic section requires a <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a>
argument that declares where the stream will be atomically processed. Batching a stream into
the <em>same</em> <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> will preserve the synchronous execution, while batching into a different
<a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> will introduce asynchrony.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.batch" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1976-1992">Source</a><h4 class="code-header">pub fn <a href="#method.batch" class="fn">batch</a>(
    self,
    tick: &amp;<a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;,
    nondet: <a class="struct" href="../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Given a tick, returns a keyed stream corresponding to a batch of elements segmented by
that tick. These batches are guaranteed to be contiguous across ticks and preserve
the order of the input.</p>
<h5 id="non-determinism-2"><a class="doc-anchor" href="#non-determinism-2">¬ß</a>Non-Determinism</h5>
<p>The batch boundaries are non-deterministic and may change across executions.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+Atomic%3CL%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#1995-2040">Source</a><a href="#impl-KeyedStream%3CK,+V,+Atomic%3CL%3E,+B,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, B, O, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.batch_atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2006-2023">Source</a><h4 class="code-header">pub fn <a href="#method.batch_atomic" class="fn">batch_atomic</a>(
    self,
    nondet: <a class="struct" href="../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Returns a keyed stream corresponding to the latest batch of elements being atomically
processed. These batches are guaranteed to be contiguous across ticks and preserve
the order of the input. The output keyed stream will execute in the <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> that was
used to create the atomic section.</p>
<h5 id="non-determinism-3"><a class="doc-anchor" href="#non-determinism-3">¬ß</a>Non-Determinism</h5>
<p>The batch boundaries are non-deterministic and may change across executions.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.end_atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2027-2039">Source</a><h4 class="code-header">pub fn <a href="#method.end_atomic" class="fn">end_atomic</a>(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;</h4></section></summary><div class="docblock"><p>Yields the elements of this keyed stream back into a top-level, asynchronous execution context.
See <a href="struct.KeyedStream.html#method.atomic" title="method hydro_lang::live_collections::KeyedStream::atomic"><code>KeyedStream::atomic</code></a> for more details.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+L,+Bounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2042-2302">Source</a><a href="#impl-KeyedStream%3CK,+V,+L,+Bounded,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.chain" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2077-2102">Source</a><h4 class="code-header">pub fn <a href="#method.chain" class="fn">chain</a>&lt;O2: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R2: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    other: <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O2, R2&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, &lt;O as <a class="trait" href="stream/trait.MinOrder.html" title="trait hydro_lang::live_collections::stream::MinOrder">MinOrder</a>&lt;O2&gt;&gt;::<a class="associatedtype" href="stream/trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::live_collections::stream::MinOrder::Min">Min</a>, &lt;R as <a class="trait" href="stream/trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;&gt;::<a class="associatedtype" href="stream/trait.MinRetries.html#associatedtype.Min" title="type hydro_lang::live_collections::stream::MinRetries::Min">Min</a>&gt;<div class="where">where
    O: <a class="trait" href="stream/trait.MinOrder.html" title="trait hydro_lang::live_collections::stream::MinOrder">MinOrder</a>&lt;O2&gt;,
    R: <a class="trait" href="stream/trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;,</div></h4></section></summary><div class="docblock"><p>Produces a new keyed stream that combines the groups of the inputs by first emitting the
elements of the <code>self</code> stream, and then emits the elements of the <code>other</code> stream (if a key
is only present in one of the inputs, its values are passed through as-is). The output has
a <a href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee if and only if both inputs have a <a href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee.</p>
<p>Currently, both input streams must be <a href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a>. This operator will block
on the first stream until all its elements are available. In a future version,
we will relax the requirement on the <code>other</code> stream.</p>
<h5 id="example-37"><a class="doc-anchor" href="#example-37">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)])).into_keyed();
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.clone().map(<span class="macro">q!</span>(|x| x + <span class="number">1</span>)).chain(batch).all_ticks()
<span class="comment">// { 0: [2, 1], 1: [4, 3] }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.join_keyed_singleton" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2136-2146">Source</a><h4 class="code-header">pub fn <a href="#method.join_keyed_singleton" class="fn">join_keyed_singleton</a>&lt;V2: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt;(
    self,
    keyed_singleton: <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;K, V2, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(V, V2)</a>, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Emit a keyed stream containing keys shared between the keyed stream and the
keyed singleton, where each value in the output keyed stream is a tuple of
(the keyed stream‚Äôs value, the keyed singleton‚Äôs value).</p>
<h5 id="example-38"><a class="doc-anchor" href="#example-38">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>keyed_data = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">10</span>), (<span class="number">1</span>, <span class="number">11</span>), (<span class="number">2</span>, <span class="number">20</span>)]))
    .into_keyed()
    .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>singleton_data = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">100</span>), (<span class="number">2</span>, <span class="number">200</span>)]))
    .into_keyed()
    .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>))
    .first();
keyed_data.join_keyed_singleton(singleton_data).entries().all_ticks()
<span class="comment">// { 1: [(10, 100), (11, 100)], 2: [(20, 200)] } in any order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2174-2181">Source</a><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>(
    self,
    key: <a class="struct" href="struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;K, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;,
) -&gt; <a class="struct" href="struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;V, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Gets the values associated with a specific key from the keyed stream.</p>
<h5 id="example-39"><a class="doc-anchor" href="#example-39">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>keyed_data = process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">10</span>), (<span class="number">1</span>, <span class="number">11</span>), (<span class="number">2</span>, <span class="number">20</span>)]))
    .into_keyed()
    .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>key = tick.singleton(<span class="macro">q!</span>(<span class="number">1</span>));
keyed_data.get(key).all_ticks()
<span class="comment">// 10, 11 in any order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.lookup_keyed_singleton" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2219-2233">Source</a><h4 class="code-header">pub fn <a href="#method.lookup_keyed_singleton" class="fn">lookup_keyed_singleton</a>&lt;V2&gt;(
    self,
    lookup: <a class="struct" href="struct.KeyedSingleton.html" title="struct hydro_lang::live_collections::KeyedSingleton">KeyedSingleton</a>&lt;V, V2, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, (V, <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V2&gt;), L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    V2: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>For each value in <code>self</code>, find the matching key in <code>lookup</code>.
The output is a keyed stream with the key from <code>self</code>, and a value
that is a tuple of (<code>self</code>‚Äôs value, Option&lt;<code>lookup</code>‚Äôs value&gt;).
If the key is not present in <code>lookup</code>, the option will be <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a>.</p>
<h5 id="example-40"><a class="doc-anchor" href="#example-40">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>requests = <span class="comment">// { 1: [10, 11], 2: 20 }
</span><span class="kw">let </span>other_data = <span class="comment">// { 10: 100, 11: 110 }
</span>requests.lookup_keyed_singleton(other_data)
<span class="comment">// { 1: [(10, Some(100)), (11, Some(110))], 2: (20, None) }</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.lookup_keyed_stream" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2271-2301">Source</a><h4 class="code-header">pub fn <a href="#method.lookup_keyed_stream" class="fn">lookup_keyed_stream</a>&lt;V2, O2: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R2: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    lookup: <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;V, V2, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O2, R2&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, (V, <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V2&gt;), L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, &lt;R as <a class="trait" href="stream/trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;&gt;::<a class="associatedtype" href="stream/trait.MinRetries.html#associatedtype.Min" title="type hydro_lang::live_collections::stream::MinRetries::Min">Min</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    V2: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    R: <a class="trait" href="stream/trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;,</div></h4></section></summary><div class="docblock"><p>For each value in <code>self</code>, find the matching key in <code>lookup</code>.
The output is a keyed stream with the key from <code>self</code>, and a value
that is a tuple of (<code>self</code>‚Äôs value, Option&lt;<code>lookup</code>‚Äôs value&gt;).
If the key is not present in <code>lookup</code>, the option will be <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a>.</p>
<h5 id="example-41"><a class="doc-anchor" href="#example-41">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>requests = <span class="comment">// { 1: [10, 11], 2: 20 }
</span><span class="kw">let </span>other_data = <span class="comment">// { 10: [100, 101], 11: 110 }
</span>requests.lookup_keyed_stream(other_data)
<span class="comment">// { 1: [(10, Some(100)), (10, Some(101)), (11, Some(110))], 2: (20, None) }</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-KeyedStream%3CK,+V,+Tick%3CL%3E,+Bounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2304-2485">Source</a><a href="#impl-KeyedStream%3CK,+V,+Tick%3CL%3E,+Bounded,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.all_ticks" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2311-2327">Source</a><h4 class="code-header">pub fn <a href="#method.all_ticks" class="fn">all_ticks</a>(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Asynchronously yields this batch of keyed elements outside the tick as an unbounded keyed stream,
which will stream all the elements across <em>all</em> tick iterations by concatenating the batches for
each key.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.all_ticks_atomic" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2336-2355">Source</a><h4 class="code-header">pub fn <a href="#method.all_ticks_atomic" class="fn">all_ticks_atomic</a>(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Synchronously yields this batch of keyed elements outside the tick as an unbounded keyed stream,
which will stream all the elements across <em>all</em> tick iterations by concatenating the batches for
each key.</p>
<p>Unlike <a href="struct.KeyedStream.html#method.all_ticks" title="method hydro_lang::live_collections::KeyedStream::all_ticks"><code>KeyedStream::all_ticks</code></a>, this preserves synchronous execution, as the output stream
is emitted in an <a href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic"><code>Atomic</code></a> context that will process elements synchronously with the input
stream‚Äôs <a href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> context.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.across_ticks" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2405-2410">Source</a><h4 class="code-header">pub fn <a href="#method.across_ticks" class="fn">across_ticks</a>&lt;Out: BatchAtomic&gt;(
    self,
    thunk: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;) -&gt; Out,
) -&gt; Out::Batched</h4></section></summary><div class="docblock"><p>Transforms the keyed stream using the given closure in ‚Äústateful‚Äù mode, where stateful operators
such as <code>fold</code> retrain their memory for each key across ticks rather than resetting across batches of each key.</p>
<p>This API is particularly useful for stateful computation on batches of data, such as
maintaining an accumulated state that is up to date with the current batch.</p>
<h5 id="example-42"><a class="doc-anchor" href="#example-42">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>input = batch_first_tick.chain(batch_second_tick).all_ticks();

input.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>))
    .across_ticks(|s| s.reduce(<span class="macro">q!</span>(|sum, new| {
        <span class="kw-2">*</span>sum += new;
    }))).entries().all_ticks()
<span class="comment">// First tick: [(0, 1), (1, 2), (2, 3), (3, 4)]
// Second tick: [(0, 6), (1, 8), (2, 10), (3, 4)]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.defer_tick" class="method"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#2469-2484">Source</a><h4 class="code-header">pub fn <a href="#method.defer_tick" class="fn">defer_tick</a>(self) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Shifts the entries in <code>self</code> to the <strong>next tick</strong>, so that the returned keyed stream at
tick <code>T</code> always has the entries of <code>self</code> at tick <code>T - 1</code>.</p>
<p>At tick <code>0</code>, the output keyed stream is empty, since there is no previous tick.</p>
<p>This operator enables stateful iterative processing with ticks, by sending data from one
tick to the next. For example, you can use it to combine inputs across consecutive batches.</p>
<h5 id="example-43"><a class="doc-anchor" href="#example-43">¬ß</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>changes_across_ticks = <span class="comment">// { 1: [2, 3] } (first tick), { 1: [4], 2: [5] } (second tick)
</span>changes_across_ticks.clone().defer_tick().chain( <span class="comment">// from the previous tick
    </span>changes_across_ticks <span class="comment">// from the current tick
</span>)
<span class="comment">// First tick: { 1: [2, 3] }
// Second tick: { 1: [2, 3, 4], 2: [5] }
// Third tick: { 1: [4], 2: [5] }</span></code></pre></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">¬ß</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#195-221">Source</a><a href="#impl-Clone-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, Loc: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, Bound: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, Order: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#198-220">Source</a><a href="#method.clone" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ¬∑ <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DeferTick-for-KeyedStream%3CK,+V,+Tick%3CL%3E,+Bounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#100-107">Source</a><a href="#impl-DeferTick-for-KeyedStream%3CK,+V,+Tick%3CL%3E,+Bounded,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="trait" href="../location/tick/trait.DeferTick.html" title="trait hydro_lang::location::tick::DeferTick">DeferTick</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.defer_tick-1" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#104-106">Source</a><a href="#method.defer_tick-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="../location/tick/trait.DeferTick.html#tymethod.defer_tick" class="fn">defer_tick</a>(self) -&gt; Self</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CKeyedStream%3CK,+V,+L,+B,+TotalOrder,+R%3E%3E-for-KeyedStream%3CK,+V,+L,+B,+NoOrder,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#90-98">Source</a><a href="#impl-From%3CKeyedStream%3CK,+V,+L,+B,+TotalOrder,+R%3E%3E-for-KeyedStream%3CK,+V,+L,+B,+NoOrder,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L, B: <a class="trait" href="boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, R&gt;&gt; for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#95-97">Source</a><a href="#method.from-1" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(
    stream: <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, R&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, <a class="enum" href="stream/enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CKeyedStream%3CK,+V,+L,+Bounded,+O,+R%3E%3E-for-KeyedStream%3CK,+V,+L,+Unbounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#69-88">Source</a><a href="#impl-From%3CKeyedStream%3CK,+V,+L,+Bounded,+O,+R%3E%3E-for-KeyedStream%3CK,+V,+L,+Unbounded,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;&gt; for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/keyed_stream/mod.rs.html#74-87">Source</a><a href="#method.from" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(
    stream: <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;,
) -&gt; <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Unslicable-for-KeyedStream%3CK,+V,+Tick%3CL%3E,+Bounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/sliced/mod.rs.html#406-414">Source</a><a href="#impl-Unslicable-for-KeyedStream%3CK,+V,+Tick%3CL%3E,+Bounded,+O,+R%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;'a, K, V, L: <a class="trait" href="../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, O: <a class="trait" href="stream/trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="stream/trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="trait" href="sliced/trait.Unslicable.html" title="trait hydro_lang::live_collections::sliced::Unslicable">Unslicable</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, <a class="struct" href="../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Unsliced" class="associatedtype trait-impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/sliced/mod.rs.html#409">Source</a><a href="#associatedtype.Unsliced" class="anchor">¬ß</a><h4 class="code-header">type <a href="sliced/trait.Unslicable.html#associatedtype.Unsliced" class="associatedtype">Unsliced</a> = <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;</h4></section></summary><div class='docblock'>The unsliced version of this live collection.</div></details><details class="toggle method-toggle" open><summary><section id="method.unslice" class="method trait-impl"><a class="src rightside" href="../../src/hydro_lang/live_collections/sliced/mod.rs.html#411-413">Source</a><a href="#method.unslice" class="anchor">¬ß</a><h4 class="code-header">fn <a href="sliced/trait.Unslicable.html#tymethod.unslice" class="fn">unslice</a>(self) -&gt; Self::<a class="associatedtype" href="sliced/trait.Unslicable.html#associatedtype.Unsliced" title="type hydro_lang::live_collections::sliced::Unslicable::Unsliced">Unsliced</a></h4></section></summary><div class='docblock'>Unslices a sliced live collection back into its original form.</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">¬ß</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-Freeze-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;K, V, Loc, Bound = <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, Order = <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, Retry&gt;</h3></section><section id="impl-RefUnwindSafe-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-RefUnwindSafe-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;K, V, Loc, Bound = <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, Order = <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, Retry&gt;</h3></section><section id="impl-Send-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-Send-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;K, V, Loc, Bound = <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, Order = <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, Retry&gt;</h3></section><section id="impl-Sync-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-Sync-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;K, V, Loc, Bound = <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, Order = <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, Retry&gt;</h3></section><section id="impl-Unpin-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-Unpin-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;K, V, Loc, Bound, Order, Retry&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, Retry&gt;<div class="where">where
    Loc: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Bound: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Order: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Retry: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-UnwindSafe-for-KeyedStream%3CK,+V,+Loc,+Bound,+Order,+Retry%3E" class="anchor">¬ß</a><h3 class="code-header">impl&lt;K, V, Loc, Bound = <a class="enum" href="boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, Order = <a class="enum" href="stream/enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="stream/enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, Loc, Bound, Order, Retry&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">¬ß</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#547">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#549">Source</a><a href="#method.clone_to_uninit" class="anchor">¬ß</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from-2" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a href="#impl-Instrument-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; Instrument for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a href="#method.instrument" class="anchor">¬ß</a><h4 class="code-header">fn <a class="fn">instrument</a>(self, span: Span) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided [<code>Span</code>], returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a href="#method.in_current_span" class="anchor">¬ß</a><h4 class="code-header">fn <a class="fn">in_current_span</a>(self) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="super::Span::current()">current</a> <a href="crate::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoShared%3CShared%3E-for-Unshared" class="impl"><a href="#impl-IntoShared%3CShared%3E-for-Unshared" class="anchor">¬ß</a><h3 class="code-header">impl&lt;Unshared, Shared&gt; IntoShared&lt;Shared&gt; for Unshared<div class="where">where
    Shared: FromUnshared&lt;Unshared&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_shared" class="method trait-impl"><a href="#method.into_shared" class="anchor">¬ß</a><h4 class="code-header">fn <a class="fn">into_shared</a>(self) -&gt; Shared</h4></section></summary><div class='docblock'>Creates a shared type from an unshared type.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.19.0/src/typenum/type_operators.rs.html#34">Source</a><a href="#impl-Same-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.19.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="https://docs.rs/typenum/1.19.0/src/typenum/type_operators.rs.html#35">Source</a><a href="#associatedtype.Output" class="anchor">¬ß</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.19.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#72-74">Source</a><a href="#impl-ToOwned-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#76">Source</a><a href="#associatedtype.Owned" class="anchor">¬ß</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#77">Source</a><a href="#method.to_owned" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#81">Source</a><a href="#method.clone_into" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToSinkBuild-for-T" class="impl"><a class="src rightside" href="../../src/sinktools/lib.rs.html#268">Source</a><a href="#impl-ToSinkBuild-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../sinktools/trait.ToSinkBuild.html" title="trait sinktools::ToSinkBuild">ToSinkBuild</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.iter_to_sink_build" class="method trait-impl"><a class="src rightside" href="../../src/sinktools/lib.rs.html#253-255">Source</a><a href="#method.iter_to_sink_build" class="anchor">¬ß</a><h4 class="code-header">fn <a href="../../sinktools/trait.ToSinkBuild.html#method.iter_to_sink_build" class="fn">iter_to_sink_build</a>(self) -&gt; <a class="struct" href="../../sinktools/send_iter/struct.SendIterBuild.html" title="struct sinktools::send_iter::SendIterBuild">SendIterBuild</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>,</div></h4></section></summary><div class='docblock'>Starts a <a href="../../sinktools/trait.SinkBuild.html" title="trait sinktools::SinkBuild"><code>SinkBuild</code></a> adaptor chain to send all items from <code>self</code> as an <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>.</div></details><details class="toggle method-toggle" open><summary><section id="method.stream_to_sink_build" class="method trait-impl"><a class="src rightside" href="../../src/sinktools/lib.rs.html#261-263">Source</a><a href="#method.stream_to_sink_build" class="anchor">¬ß</a><h4 class="code-header">fn <a href="../../sinktools/trait.ToSinkBuild.html#method.stream_to_sink_build" class="fn">stream_to_sink_build</a>(self) -&gt; <a class="struct" href="../../sinktools/send_stream/struct.SendStreamBuild.html" title="struct sinktools::send_stream::SendStreamBuild">SendStreamBuild</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + Stream,</div></h4></section></summary><div class='docblock'>Starts a <a href="../../sinktools/trait.SinkBuild.html" title="trait sinktools::SinkBuild"><code>SinkBuild</code></a> adaptor chain to send all items from <code>self</code> as a [<code>Stream</code>].</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">¬ß</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">¬ß</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">¬ß</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">¬ß</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a href="#impl-WithSubscriber-for-T" class="anchor">¬ß</a><h3 class="code-header">impl&lt;T&gt; WithSubscriber for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a href="#method.with_subscriber" class="anchor">¬ß</a><h4 class="code-header">fn <a class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; WithDispatch&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Dispatch&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a href="#method.with_current_subscriber" class="anchor">¬ß</a><h4 class="code-header">fn <a class="fn">with_current_subscriber</a>(self) -&gt; WithDispatch&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="dispatcher#setting-the-default-subscriber">default</a> <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details></div></details></div></section></div></main></body></html>