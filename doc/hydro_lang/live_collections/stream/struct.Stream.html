<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Streaming sequence of elements with type `Type`."><title>Stream in hydro_lang::live_collections::stream - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="hydro_lang" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (9f32ccf35 2025-09-21)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-061df703.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Stream</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../hydro_lang/index.html">hydro_<wbr>lang</a><span class="version">0.14.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Stream</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.all_ticks" title="all_ticks">all_ticks</a></li><li><a href="#method.all_ticks_atomic" title="all_ticks_atomic">all_ticks_atomic</a></li><li><a href="#method.anti_join" title="anti_join">anti_join</a></li><li><a href="#method.assume_ordering" title="assume_ordering">assume_ordering</a></li><li><a href="#method.assume_retries" title="assume_retries">assume_retries</a></li><li><a href="#method.atomic" title="atomic">atomic</a></li><li><a href="#method.atomic_source" title="atomic_source">atomic_source</a></li><li><a href="#method.batch" title="batch">batch</a></li><li><a href="#method.batch-1" title="batch">batch</a></li><li><a href="#method.broadcast_bincode" title="broadcast_bincode">broadcast_bincode</a></li><li><a href="#method.broadcast_bincode-1" title="broadcast_bincode">broadcast_bincode</a></li><li><a href="#method.chain" title="chain">chain</a></li><li><a href="#method.cloned" title="cloned">cloned</a></li><li><a href="#method.collect_vec" title="collect_vec">collect_vec</a></li><li><a href="#method.count" title="count">count</a></li><li><a href="#method.cross_product" title="cross_product">cross_product</a></li><li><a href="#method.cross_product_nested_loop" title="cross_product_nested_loop">cross_product_nested_loop</a></li><li><a href="#method.cross_singleton" title="cross_singleton">cross_singleton</a></li><li><a href="#method.defer_tick" title="defer_tick">defer_tick</a></li><li><a href="#method.demux_bincode" title="demux_bincode">demux_bincode</a></li><li><a href="#method.demux_bincode-1" title="demux_bincode">demux_bincode</a></li><li><a href="#method.dest_sink" title="dest_sink">dest_sink</a></li><li><a href="#method.end_atomic" title="end_atomic">end_atomic</a></li><li><a href="#method.enumerate" title="enumerate">enumerate</a></li><li><a href="#method.filter" title="filter">filter</a></li><li><a href="#method.filter_if_none" title="filter_if_none">filter_if_none</a></li><li><a href="#method.filter_if_some" title="filter_if_some">filter_if_some</a></li><li><a href="#method.filter_map" title="filter_map">filter_map</a></li><li><a href="#method.filter_not_in" title="filter_not_in">filter_not_in</a></li><li><a href="#method.first" title="first">first</a></li><li><a href="#method.flat_map_ordered" title="flat_map_ordered">flat_map_ordered</a></li><li><a href="#method.flat_map_unordered" title="flat_map_unordered">flat_map_unordered</a></li><li><a href="#method.flatten_ordered" title="flatten_ordered">flatten_ordered</a></li><li><a href="#method.flatten_unordered" title="flatten_unordered">flatten_unordered</a></li><li><a href="#method.fold" title="fold">fold</a></li><li><a href="#method.fold_commutative" title="fold_commutative">fold_commutative</a></li><li><a href="#method.fold_commutative_idempotent" title="fold_commutative_idempotent">fold_commutative_idempotent</a></li><li><a href="#method.fold_idempotent" title="fold_idempotent">fold_idempotent</a></li><li><a href="#method.fold_keyed" title="fold_keyed">fold_keyed</a></li><li><a href="#method.fold_keyed_commutative" title="fold_keyed_commutative">fold_keyed_commutative</a></li><li><a href="#method.fold_keyed_commutative_idempotent" title="fold_keyed_commutative_idempotent">fold_keyed_commutative_idempotent</a></li><li><a href="#method.fold_keyed_idempotent" title="fold_keyed_idempotent">fold_keyed_idempotent</a></li><li><a href="#method.for_each" title="for_each">for_each</a></li><li><a href="#method.inspect" title="inspect">inspect</a></li><li><a href="#method.interleave" title="interleave">interleave</a></li><li><a href="#method.into_keyed" title="into_keyed">into_keyed</a></li><li><a href="#method.ir_node_named" title="ir_node_named">ir_node_named</a></li><li><a href="#method.join" title="join">join</a></li><li><a href="#method.keys" title="keys">keys</a></li><li><a href="#method.last" title="last">last</a></li><li><a href="#method.map" title="map">map</a></li><li><a href="#method.max" title="max">max</a></li><li><a href="#method.max_by_key" title="max_by_key">max_by_key</a></li><li><a href="#method.min" title="min">min</a></li><li><a href="#method.persist" title="persist">persist</a></li><li><a href="#method.reduce" title="reduce">reduce</a></li><li><a href="#method.reduce_commutative" title="reduce_commutative">reduce_commutative</a></li><li><a href="#method.reduce_commutative_idempotent" title="reduce_commutative_idempotent">reduce_commutative_idempotent</a></li><li><a href="#method.reduce_idempotent" title="reduce_idempotent">reduce_idempotent</a></li><li><a href="#method.reduce_keyed" title="reduce_keyed">reduce_keyed</a></li><li><a href="#method.reduce_keyed_commutative" title="reduce_keyed_commutative">reduce_keyed_commutative</a></li><li><a href="#method.reduce_keyed_commutative_idempotent" title="reduce_keyed_commutative_idempotent">reduce_keyed_commutative_idempotent</a></li><li><a href="#method.reduce_keyed_idempotent" title="reduce_keyed_idempotent">reduce_keyed_idempotent</a></li><li><a href="#method.resolve_futures" title="resolve_futures">resolve_futures</a></li><li><a href="#method.resolve_futures_ordered" title="resolve_futures_ordered">resolve_futures_ordered</a></li><li><a href="#method.round_robin_bincode" title="round_robin_bincode">round_robin_bincode</a></li><li><a href="#method.sample_every" title="sample_every">sample_every</a></li><li><a href="#method.scan" title="scan">scan</a></li><li><a href="#method.send_bincode" title="send_bincode">send_bincode</a></li><li><a href="#method.send_bincode-1" title="send_bincode">send_bincode</a></li><li><a href="#method.send_bincode_external" title="send_bincode_external">send_bincode_external</a></li><li><a href="#method.sort" title="sort">sort</a></li><li><a href="#method.timeout" title="timeout">timeout</a></li><li><a href="#method.unique" title="unique">unique</a></li><li><a href="#method.weaken_ordering" title="weaken_ordering">weaken_ordering</a></li><li><a href="#method.weaken_retries" title="weaken_retries">weaken_retries</a></li><li><a href="#method.weaker_retries" title="weaker_retries">weaker_retries</a></li><li><a href="#method.weakest_ordering" title="weakest_ordering">weakest_ordering</a></li><li><a href="#method.weakest_retries" title="weakest_retries">weakest_retries</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Stream%3CT,+L,+B,+O,+R%3E" title="Clone">Clone</a></li><li><a href="#impl-DeferTick-for-Stream%3CT,+Tick%3CL%3E,+Bounded,+O,+R%3E" title="DeferTick">DeferTick</a></li><li><a href="#impl-From%3CStream%3CT,+L,+B,+O%3E%3E-for-Stream%3CT,+L,+B,+O,+AtLeastOnce%3E" title="From&#60;Stream&#60;T, L, B, O&#62;&#62;">From&#60;Stream&#60;T, L, B, O&#62;&#62;</a></li><li><a href="#impl-From%3CStream%3CT,+L,+B,+TotalOrder,+R%3E%3E-for-Stream%3CT,+L,+B,+NoOrder,+R%3E" title="From&#60;Stream&#60;T, L, B, TotalOrder, R&#62;&#62;">From&#60;Stream&#60;T, L, B, TotalOrder, R&#62;&#62;</a></li><li><a href="#impl-From%3CStream%3CT,+L,+Bounded,+O,+R%3E%3E-for-Stream%3CT,+L,+Unbounded,+O,+R%3E" title="From&#60;Stream&#60;T, L, Bounded, O, R&#62;&#62;">From&#60;Stream&#60;T, L, Bounded, O, R&#62;&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" title="!Freeze">!Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Send-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" title="!Send">!Send</a></li><li><a href="#impl-Sync-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" title="!Sync">!Sync</a></li><li><a href="#impl-UnwindSafe-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Unpin-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-DynClone-for-T" title="DynClone">DynClone</a></li><li><a href="#impl-ErasedDestructor-for-T" title="ErasedDestructor">ErasedDestructor</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-PolicyExt-for-T" title="PolicyExt">PolicyExt</a></li><li><a href="#impl-Same-for-T" title="Same">Same</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-VZip%3CV%3E-for-T" title="VZip&#60;V&#62;">VZip&#60;V&#62;</a></li><li><a href="#impl-WithSubscriber-for-T" title="WithSubscriber">WithSubscriber</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In hydro_<wbr>lang::<wbr>live_<wbr>collections::<wbr>stream</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">hydro_lang</a>::<wbr><a href="../index.html">live_collections</a>::<wbr><a href="index.html">stream</a></div><h1>Struct <span class="struct">Stream</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#151-162">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Stream&lt;Type, Loc, Bound: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, Order: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a> = <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a> = <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Streaming sequence of elements with type <code>Type</code>.</p>
<p>This live collection represents a growing sequence of elements, with new elements being
asynchronously appended to the end of the sequence. This can be used to model the arrival
of network input, such as API requests, or streaming ingestion.</p>
<p>By default, all streams have deterministic ordering and each element is materialized exactly
once. But streams can also capture non-determinism via the <code>Order</code> and <code>Retries</code> type
parameters. When the ordering / retries guarantee is relaxed, fewer APIs will be available
on the stream. For example, if the stream is unordered, you cannot invoke <a href="../struct.Stream.html#method.first" title="method hydro_lang::live_collections::Stream::first"><code>Stream::first</code></a>.</p>
<p>Type Parameters:</p>
<ul>
<li><code>Type</code>: the type of elements in the stream</li>
<li><code>Loc</code>: the location where the stream is being materialized</li>
<li><code>Bound</code>: the boundedness of the stream, which is either <a href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a> or <a href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a></li>
<li><code>Order</code>: the ordering of the stream, which is either <a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> or <a href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder"><code>NoOrder</code></a>
(default is <a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a>)</li>
<li><code>Retries</code>: the retry guarantee of the stream, which is either <a href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce"><code>ExactlyOnce</code></a> or
<a href="enum.AtLeastOnce.html" title="enum hydro_lang::live_collections::stream::AtLeastOnce"><code>AtLeastOnce</code></a> (default is <a href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce"><code>ExactlyOnce</code></a>)</li>
</ul>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+Process%3C'a,+L%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#90-262">Source</a><a href="#impl-Stream%3CT,+Process%3C'a,+L%3E,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L&gt;, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.send_bincode" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#117-138">Source</a><h4 class="code-header">pub fn <a href="#method.send_bincode" class="fn">send_bincode</a>&lt;L2&gt;(
    self,
    other: &amp;<a class="struct" href="../../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L2&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://docs.rs/serde/1.0.219/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.219/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>“Moves” elements of this stream to a new distributed location by sending them over the network,
using <a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize messages.</p>
<p>The returned stream captures the elements received at the destination, where values will
asynchronously arrive over the network. Sending from a <a href="../../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process"><code>Process</code></a> to another <a href="../../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process"><code>Process</code></a>
preserves ordering and retries guarantees by using a single TCP channel to send the values. The
recipient is guaranteed to receive a <em>prefix</em> or the sent messages; if the TCP connection is
dropped no further messages will be sent.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>p1 = flow.process::&lt;()&gt;();
<span class="kw">let </span>numbers: Stream&lt;<span class="kw">_</span>, Process&lt;<span class="kw">_</span>&gt;, Unbounded&gt; = p1.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));
<span class="kw">let </span>p2 = flow.process::&lt;()&gt;();
<span class="kw">let </span>on_p2: Stream&lt;<span class="kw">_</span>, Process&lt;<span class="kw">_</span>&gt;, Unbounded&gt; = numbers.send_bincode(<span class="kw-2">&amp;</span>p2);
<span class="comment">// 1, 2, 3</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.broadcast_bincode" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#178-199">Source</a><h4 class="code-header">pub fn <a href="#method.broadcast_bincode" class="fn">broadcast_bincode</a>&lt;L2: 'a&gt;(
    self,
    other: &amp;<a class="struct" href="../../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
    nondet_membership: <a class="struct" href="../../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://docs.rs/serde/1.0.219/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.219/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>Broadcasts elements of this stream to all members of a cluster by sending them over the network,
using <a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize messages.</p>
<p>Each element in the stream will be sent to <strong>every</strong> member of the cluster based on the latest
membership information. This is a common pattern in distributed systems for broadcasting data to
all nodes in a cluster. Unlike <a href="../struct.Stream.html#method.demux_bincode" title="method hydro_lang::live_collections::Stream::demux_bincode"><code>Stream::demux_bincode</code></a>, which requires <code>(MemberId, T)</code> tuples to
target specific members, <code>broadcast_bincode</code> takes a stream of <strong>only data elements</strong> and sends
each element to all cluster members.</p>
<h5 id="non-determinism"><a class="doc-anchor" href="#non-determinism">§</a>Non-Determinism</h5>
<p>The set of cluster members may asynchronously change over time. Each element is only broadcast
to the current cluster members <em>at that point in time</em>. Depending on when we are notified of
membership changes, we will broadcast each element to different members.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>p1 = flow.process::&lt;()&gt;();
<span class="kw">let </span>workers: Cluster&lt;()&gt; = flow.cluster::&lt;()&gt;();
<span class="kw">let </span>numbers: Stream&lt;<span class="kw">_</span>, Process&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = p1.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">123</span>]));
<span class="kw">let </span>on_worker: Stream&lt;<span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = numbers.broadcast_bincode(<span class="kw-2">&amp;</span>workers, <span class="macro">nondet!</span>(<span class="doccomment">/** assuming stable membership */</span>));
<span class="comment">// if there are 4 members in the cluster, each receives one element
// - MemberId::&lt;()&gt;(0): [123]
// - MemberId::&lt;()&gt;(1): [123]
// - MemberId::&lt;()&gt;(2): [123]
// - MemberId::&lt;()&gt;(3): [123]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.send_bincode_external" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#232-261">Source</a><h4 class="code-header">pub fn <a href="#method.send_bincode_external" class="fn">send_bincode_external</a>&lt;L2&gt;(
    self,
    other: &amp;<a class="struct" href="../../location/external_process/struct.External.html" title="struct hydro_lang::location::external_process::External">External</a>&lt;'_, L2&gt;,
) -&gt; <a class="struct" href="../../location/external_process/struct.ExternalBincodeStream.html" title="struct hydro_lang::location::external_process::ExternalBincodeStream">ExternalBincodeStream</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://docs.rs/serde/1.0.219/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.219/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>Sends the elements of this stream to an external (non-Hydro) process, using <a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a>
serialization. The external process can receive these elements by establishing a TCP
connection and decoding using [<code>tokio_util::codec::LengthDelimitedCodec</code>].</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>flow = FlowBuilder::new();
<span class="kw">let </span>process = flow.process::&lt;()&gt;();
<span class="kw">let </span>numbers: Stream&lt;<span class="kw">_</span>, Process&lt;<span class="kw">_</span>&gt;, Unbounded&gt; = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));
<span class="kw">let </span>external = flow.external::&lt;()&gt;();
<span class="kw">let </span>external_handle = numbers.send_bincode_external(<span class="kw-2">&amp;</span>external);

<span class="kw">let </span><span class="kw-2">mut </span>deployment = hydro_deploy::Deployment::new();
<span class="kw">let </span>nodes = flow
    .with_process(<span class="kw-2">&amp;</span>process, deployment.Localhost())
    .with_external(<span class="kw-2">&amp;</span>external, deployment.Localhost())
    .deploy(<span class="kw-2">&amp;mut </span>deployment);

deployment.deploy().<span class="kw">await</span>.unwrap();
<span class="comment">// establish the TCP connection
</span><span class="kw">let </span><span class="kw-2">mut </span>external_recv_stream = nodes.connect_source_bincode(external_handle).<span class="kw">await</span>;
deployment.start().<span class="kw">await</span>.unwrap();

<span class="kw">for </span>w <span class="kw">in </span><span class="number">1</span>..=<span class="number">3 </span>{
    <span class="macro">assert_eq!</span>(external_recv_stream.next().<span class="kw">await</span>, <span class="prelude-val">Some</span>(w));
}</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C(MemberId%3CL2%3E,+T),+Process%3C'a,+L%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#264-310">Source</a><a href="#impl-Stream%3C(MemberId%3CL2%3E,+T),+Process%3C'a,+L%3E,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, L2, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;(<a class="struct" href="../../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L2&gt;, T), <a class="struct" href="../../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L&gt;, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.demux_bincode" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#301-309">Source</a><h4 class="code-header">pub fn <a href="#method.demux_bincode" class="fn">demux_bincode</a>(
    self,
    other: &amp;<a class="struct" href="../../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://docs.rs/serde/1.0.219/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.219/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>Sends elements of this stream to specific members of a cluster, identified by a <a href="../../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId"><code>MemberId</code></a>,
using <a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize messages.</p>
<p>Each element in the stream must be a tuple <code>(MemberId&lt;L2&gt;, T)</code> where the first element
specifies which cluster member should receive the data. Unlike <a href="../struct.Stream.html#method.broadcast_bincode" title="method hydro_lang::live_collections::Stream::broadcast_bincode"><code>Stream::broadcast_bincode</code></a>,
this API allows precise targeting of specific cluster members rather than broadcasting to
all members.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>p1 = flow.process::&lt;()&gt;();
<span class="kw">let </span>workers: Cluster&lt;()&gt; = flow.cluster::&lt;()&gt;();
<span class="kw">let </span>numbers: Stream&lt;<span class="kw">_</span>, Process&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = p1.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));
<span class="kw">let </span>on_worker: Stream&lt;<span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = numbers
    .map(<span class="macro">q!</span>(|x| (hydro_lang::location::MemberId::from_raw(x), x)))
    .demux_bincode(<span class="kw-2">&amp;</span>workers);
<span class="comment">// if there are 4 members in the cluster, each receives one element
// - MemberId::&lt;()&gt;(0): [0]
// - MemberId::&lt;()&gt;(1): [1]
// - MemberId::&lt;()&gt;(2): [2]
// - MemberId::&lt;()&gt;(3): [3]</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+Process%3C'a,+L%3E,+B%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#312-382">Source</a><a href="#impl-Stream%3CT,+Process%3C'a,+L%3E,+B%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L&gt;, B, <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.round_robin_bincode" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#356-381">Source</a><h4 class="code-header">pub fn <a href="#method.round_robin_bincode" class="fn">round_robin_bincode</a>&lt;L2: 'a&gt;(
    self,
    other: &amp;<a class="struct" href="../../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
    nondet_membership: <a class="struct" href="../../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    T: <a class="trait" href="https://docs.rs/serde/1.0.219/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.219/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>Distributes elements of this stream to cluster members in a round-robin fashion, using
<a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize messages.</p>
<p>This provides load balancing by evenly distributing work across cluster members. The
distribution is deterministic based on element order - the first element goes to member 0,
the second to member 1, and so on, wrapping around when reaching the end of the member list.</p>
<h5 id="non-determinism-1"><a class="doc-anchor" href="#non-determinism-1">§</a>Non-Determinism</h5>
<p>The set of cluster members may asynchronously change over time. Each element is distributed
based on the current cluster membership <em>at that point in time</em>. Depending on when cluster
members join and leave, the round-robin pattern will change. Furthermore, even when the
membership is stable, the order of members in the round-robin pattern may change across runs.</p>
<h5 id="ordering-requirements"><a class="doc-anchor" href="#ordering-requirements">§</a>Ordering Requirements</h5>
<p>This method is only available on streams with <a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> and <a href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce"><code>ExactlyOnce</code></a>, since the
order of messages and retries affects the round-robin pattern.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>p1 = flow.process::&lt;()&gt;();
<span class="kw">let </span>workers: Cluster&lt;()&gt; = flow.cluster::&lt;()&gt;();
<span class="kw">let </span>numbers: Stream&lt;<span class="kw">_</span>, Process&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>, TotalOrder, ExactlyOnce&gt; = p1.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>on_worker: Stream&lt;<span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = numbers.round_robin_bincode(<span class="kw-2">&amp;</span>workers, <span class="macro">nondet!</span>(<span class="doccomment">/** assuming stable membership */</span>));
on_worker.send_bincode(<span class="kw-2">&amp;</span>p2)
<span class="comment">// with 4 cluster members, elements are distributed (with a non-deterministic round-robin order):
// - MemberId::&lt;()&gt;(?): [1]
// - MemberId::&lt;()&gt;(?): [2]
// - MemberId::&lt;()&gt;(?): [3]
// - MemberId::&lt;()&gt;(?): [4]</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+Cluster%3C'a,+L%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#384-525">Source</a><a href="#impl-Stream%3CT,+Cluster%3C'a,+L%3E,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L&gt;, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.send_bincode-1" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#434-457">Source</a><h4 class="code-header">pub fn <a href="#method.send_bincode-1" class="fn">send_bincode</a>&lt;L2&gt;(
    self,
    other: &amp;<a class="struct" href="../../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L2&gt;,
) -&gt; <a class="struct" href="../struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;<a class="struct" href="../../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L&gt;, T, <a class="struct" href="../../location/process/struct.Process.html" title="struct hydro_lang::location::process::Process">Process</a>&lt;'a, L2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://docs.rs/serde/1.0.219/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.219/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>“Moves” elements of this stream from a cluster to a process by sending them over the network,
using <a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize messages.</p>
<p>Each cluster member sends its local stream elements, and they are collected at the destination
as a <a href="../struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream"><code>KeyedStream</code></a> where keys identify the source cluster member.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>workers: Cluster&lt;()&gt; = flow.cluster::&lt;()&gt;();
<span class="kw">let </span>numbers: Stream&lt;<span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = workers.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>]));
<span class="kw">let </span>all_received = numbers.send_bincode(<span class="kw-2">&amp;</span>process); <span class="comment">// KeyedStream&lt;MemberId&lt;()&gt;, i32, ...&gt;
// if there are 4 members in the cluster, we should receive 4 elements
// { MemberId::&lt;()&gt;(0): [1], MemberId::&lt;()&gt;(1): [1], MemberId::&lt;()&gt;(2): [1], MemberId::&lt;()&gt;(3): [1] }</span></code></pre></div>
<p>If you don’t need to know the source for each element, you can use <code>.values()</code>
to get just the data:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>values: Stream&lt;i32, <span class="kw">_</span>, <span class="kw">_</span>, NoOrder&gt; = numbers.send_bincode(<span class="kw-2">&amp;</span>process).values();
<span class="comment">// if there are 4 members in the cluster, we should receive 4 elements
// 1, 1, 1, 1</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.broadcast_bincode-1" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#504-524">Source</a><h4 class="code-header">pub fn <a href="#method.broadcast_bincode-1" class="fn">broadcast_bincode</a>&lt;L2: 'a&gt;(
    self,
    other: &amp;<a class="struct" href="../../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
    nondet_membership: <a class="struct" href="../../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="../struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;<a class="struct" href="../../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L&gt;, T, <a class="struct" href="../../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://docs.rs/serde/1.0.219/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.219/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>Broadcasts elements of this stream at each source member to all members of a destination
cluster, using <a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize messages.</p>
<p>Each source member sends each of its stream elements to <strong>every</strong> member of the cluster
based on its latest membership information. Unlike <a href="../struct.Stream.html#method.demux_bincode" title="method hydro_lang::live_collections::Stream::demux_bincode"><code>Stream::demux_bincode</code></a>, which requires
<code>(MemberId, T)</code> tuples to target specific members, <code>broadcast_bincode</code> takes a stream of
<strong>only data elements</strong> and sends each element to all cluster members.</p>
<h5 id="non-determinism-2"><a class="doc-anchor" href="#non-determinism-2">§</a>Non-Determinism</h5>
<p>The set of cluster members may asynchronously change over time. Each element is only broadcast
to the current cluster members known <em>at that point in time</em> at the source member. Depending
on when each source member is notified of membership changes, it will broadcast each element
to different members.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>source: Cluster&lt;Source&gt; = flow.cluster::&lt;Source&gt;();
<span class="kw">let </span>numbers: Stream&lt;<span class="kw">_</span>, Cluster&lt;Source&gt;, <span class="kw">_</span>&gt; = source.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">123</span>]));
<span class="kw">let </span>destination: Cluster&lt;Destination&gt; = flow.cluster::&lt;Destination&gt;();
<span class="kw">let </span>on_destination: KeyedStream&lt;MemberId&lt;Source&gt;, <span class="kw">_</span>, Cluster&lt;Destination&gt;, <span class="kw">_</span>&gt; = numbers.broadcast_bincode(<span class="kw-2">&amp;</span>destination, <span class="macro">nondet!</span>(<span class="doccomment">/** assuming stable membership */</span>));
<span class="comment">// if there are 4 members in the desination, each receives one element from each source member
// - Destination(0): { Source(0): [123], Source(1): [123], ... }
// - Destination(1): { Source(0): [123], Source(1): [123], ... }
// - ...</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C(MemberId%3CL2%3E,+T),+Cluster%3C'a,+L%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#527-582">Source</a><a href="#impl-Stream%3C(MemberId%3CL2%3E,+T),+Cluster%3C'a,+L%3E,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, L2, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;(<a class="struct" href="../../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L2&gt;, T), <a class="struct" href="../../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L&gt;, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.demux_bincode-1" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/networking.rs.html#573-581">Source</a><h4 class="code-header">pub fn <a href="#method.demux_bincode-1" class="fn">demux_bincode</a>(
    self,
    other: &amp;<a class="struct" href="../../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;,
) -&gt; <a class="struct" href="../struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;<a class="struct" href="../../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId">MemberId</a>&lt;L&gt;, T, <a class="struct" href="../../location/cluster/struct.Cluster.html" title="struct hydro_lang::location::cluster::Cluster">Cluster</a>&lt;'a, L2&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://docs.rs/serde/1.0.219/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> + <a class="trait" href="https://docs.rs/serde/1.0.219/serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,</div></h4></section></summary><div class="docblock"><p>Sends elements of this stream at each source member to specific members of a destination
cluster, identified by a <a href="../../location/member_id/struct.MemberId.html" title="struct hydro_lang::location::member_id::MemberId"><code>MemberId</code></a>, using <a href="https://docs.rs/bincode/1.3.3/bincode/index.html" title="mod bincode"><code>bincode</code></a> to serialize/deserialize messages.</p>
<p>Each element in the stream must be a tuple <code>(MemberId&lt;L2&gt;, T)</code> where the first element
specifies which cluster member should receive the data. Unlike <a href="../struct.Stream.html#method.broadcast_bincode" title="method hydro_lang::live_collections::Stream::broadcast_bincode"><code>Stream::broadcast_bincode</code></a>,
this API allows precise targeting of specific cluster members rather than broadcasting to
all members.</p>
<p>Each cluster member sends its local stream elements, and they are collected at each
destination member as a <a href="../struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream"><code>KeyedStream</code></a> where keys identify the source cluster member.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>source: Cluster&lt;Source&gt; = flow.cluster::&lt;Source&gt;();
<span class="kw">let </span>to_send: Stream&lt;<span class="kw">_</span>, Cluster&lt;<span class="kw">_</span>&gt;, <span class="kw">_</span>&gt; = source
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))
    .map(<span class="macro">q!</span>(|x| (hydro_lang::location::MemberId::from_raw(x), x)));
<span class="kw">let </span>destination: Cluster&lt;Destination&gt; = flow.cluster::&lt;Destination&gt;();
<span class="kw">let </span>all_received = to_send.demux_bincode(<span class="kw-2">&amp;</span>destination); <span class="comment">// KeyedStream&lt;MemberId&lt;Source&gt;, i32, ...&gt;
// if there are 4 members in the destination cluster, each receives one message from each source member
// - Destination(0): { Source(0): [0], Source(1): [0], ... }
// - Destination(1): { Source(0): [1], Source(1): [1], ... }
// - ...</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#334-927">Source</a><a href="#impl-Stream%3CT,+L,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.map" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#363-376">Source</a><h4 class="code-header">pub fn <a href="#method.map" class="fn">map</a>&lt;U, F&gt;(self, f: impl IntoQuotedMut&lt;'a, F, L&gt;) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;U, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; U + 'a,</div></h4></section></summary><div class="docblock"><p>Produces a stream based on invoking <code>f</code> on each element.
If you do not want to modify the stream and instead only want to view
each item use <a href="../struct.Stream.html#method.inspect" title="method hydro_lang::live_collections::Stream::inspect"><code>Stream::inspect</code></a> instead.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>words = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="string">"hello"</span>, <span class="string">"world"</span>]));
words.map(<span class="macro">q!</span>(|x| x.to_uppercase()))</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flat_map_ordered" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#400-414">Source</a><h4 class="code-header">pub fn <a href="#method.flat_map_ordered" class="fn">flat_map_ordered</a>&lt;U, I, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;U, L, B, O, R&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; I + 'a,</div></h4></section></summary><div class="docblock"><p>For each item <code>i</code> in the input stream, transform <code>i</code> using <code>f</code> and then treat the
result as an <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> to produce items one by one. The implementation for <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>
for the output type <code>U</code> must produce items in a <strong>deterministic</strong> order.</p>
<p>For example, <code>U</code> could be a <code>Vec</code>, but not a <code>HashSet</code>. If the order of the items in <code>U</code> is
not deterministic, use <a href="../struct.Stream.html#method.flat_map_unordered" title="method hydro_lang::live_collections::Stream::flat_map_unordered"><code>Stream::flat_map_unordered</code></a> instead.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>], <span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">4</span>]]))
    .flat_map_ordered(<span class="macro">q!</span>(|x| x))
<span class="comment">// 1, 2, 3, 4</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flat_map_unordered" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#440-457">Source</a><h4 class="code-header">pub fn <a href="#method.flat_map_unordered" class="fn">flat_map_unordered</a>&lt;U, I, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;U, L, B, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; I + 'a,</div></h4></section></summary><div class="docblock"><p>Like <a href="../struct.Stream.html#method.flat_map_ordered" title="method hydro_lang::live_collections::Stream::flat_map_ordered"><code>Stream::flat_map_ordered</code></a>, but allows the implementation of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>
for the output type <code>U</code> to produce items in any order.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[
        std::collections::HashSet::&lt;i32&gt;::from_iter(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]),
        std::collections::HashSet::from_iter(<span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">4</span>]),
    ]))
    .flat_map_unordered(<span class="macro">q!</span>(|x| x))
<span class="comment">// 1, 2, 3, 4, but in no particular order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flatten_ordered" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#479-484">Source</a><h4 class="code-header">pub fn <a href="#method.flatten_ordered" class="fn">flatten_ordered</a>&lt;U&gt;(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;U, L, B, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,</div></h4></section></summary><div class="docblock"><p>For each item <code>i</code> in the input stream, treat <code>i</code> as an <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> and produce its items one by one.
The implementation for <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> for the element type <code>T</code> must produce items in a <strong>deterministic</strong> order.</p>
<p>For example, <code>T</code> could be a <code>Vec</code>, but not a <code>HashSet</code>. If the order of the items in <code>T</code> is
not deterministic, use <a href="../struct.Stream.html#method.flatten_unordered" title="method hydro_lang::live_collections::Stream::flatten_unordered"><code>Stream::flatten_unordered</code></a> instead.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>], <span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">4</span>]]))
    .flatten_ordered()
<span class="comment">// 1, 2, 3, 4</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.flatten_unordered" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#510-515">Source</a><h4 class="code-header">pub fn <a href="#method.flatten_unordered" class="fn">flatten_unordered</a>&lt;U&gt;(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;U, L, B, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = U&gt;,</div></h4></section></summary><div class="docblock"><p>Like <a href="../struct.Stream.html#method.flatten_ordered" title="method hydro_lang::live_collections::Stream::flatten_ordered"><code>Stream::flatten_ordered</code></a>, but allows the implementation of <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>
for the element type <code>T</code> to produce items in any order.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[
        std::collections::HashSet::&lt;i32&gt;::from_iter(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]),
        std::collections::HashSet::from_iter(<span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">4</span>]),
    ]))
    .flatten_unordered()
<span class="comment">// 1, 2, 3, 4, but in no particular order</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#539-552">Source</a><h4 class="code-header">pub fn <a href="#method.filter" class="fn">filter</a>&lt;F&gt;(self, f: impl IntoQuotedMut&lt;'a, F, L&gt;) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> + 'a,</div></h4></section></summary><div class="docblock"><p>Creates a stream containing only the elements of the input stream that satisfy a predicate
<code>f</code>, preserving the order of the elements.</p>
<p>The closure <code>f</code> receives a reference <code>&amp;T</code> rather than an owned value <code>T</code> because filtering does
not modify or take ownership of the values. If you need to modify the values while filtering
use <a href="../struct.Stream.html#method.filter_map" title="method hydro_lang::live_collections::Stream::filter_map"><code>Stream::filter_map</code></a> instead.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))
    .filter(<span class="macro">q!</span>(|<span class="kw-2">&amp;</span>x| x &gt; <span class="number">2</span>))
<span class="comment">// 3, 4</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_map" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#571-584">Source</a><h4 class="code-header">pub fn <a href="#method.filter_map" class="fn">filter_map</a>&lt;U, F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;U, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;U&gt; + 'a,</div></h4></section></summary><div class="docblock"><p>An operator that both filters and maps. It yields only the items for which the supplied closure <code>f</code> returns <code>Some(value)</code>.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="string">"1"</span>, <span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"2"</span>]))
    .filter_map(<span class="macro">q!</span>(|s| s.parse::&lt;usize&gt;().ok()))
<span class="comment">// 1, 2</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cross_singleton" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#607-625">Source</a><h4 class="code-header">pub fn <a href="#method.cross_singleton" class="fn">cross_singleton</a>&lt;O2&gt;(
    self,
    other: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;O2, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(T, O2)</a>, L, B, O, R&gt;<div class="where">where
    O2: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Generates a stream that maps each input element <code>i</code> to a tuple <code>(i, x)</code>,
where <code>x</code> is the final value of <code>other</code>, a bounded <a href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>Singleton</code></a>.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>batch = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>count = batch.clone().count(); <span class="comment">// `count()` returns a singleton
</span>batch.cross_singleton(count).all_ticks()
<span class="comment">// (1, 4), (2, 4), (3, 4), (4, 4)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_if_some" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#659-662">Source</a><h4 class="code-header">pub fn <a href="#method.filter_if_some" class="fn">filter_if_some</a>&lt;U&gt;(
    self,
    signal: <a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;U, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R&gt;</h4></section></summary><div class="docblock"><p>Passes this stream through if the argument (a <a href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a> <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>`) is non-null, otherwise the output is empty.</p>
<p>Useful for gating the release of elements based on a condition, such as only processing requests if you are the
leader of a cluster.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="comment">// ticks are lazy by default, forces the second tick to run
</span>tick.spin_batch(<span class="macro">q!</span>(<span class="number">1</span>)).all_ticks().for_each(<span class="macro">q!</span>(|<span class="kw">_</span>| {}));

<span class="kw">let </span>batch_first_tick = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>batch_second_tick = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>))
  .defer_tick(); <span class="comment">// appears on the second tick
</span><span class="kw">let </span>some_on_first_tick = tick.optional_first_tick(<span class="macro">q!</span>(()));
batch_first_tick.chain(batch_second_tick)
  .filter_if_some(some_on_first_tick)
  .all_ticks()
<span class="comment">// [1, 2, 3, 4]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_if_none" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#696-703">Source</a><h4 class="code-header">pub fn <a href="#method.filter_if_none" class="fn">filter_if_none</a>&lt;U&gt;(
    self,
    other: <a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;U, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R&gt;</h4></section></summary><div class="docblock"><p>Passes this stream through if the argument (a <a href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a> <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>`) is null, otherwise the output is empty.</p>
<p>Useful for gating the release of elements based on a condition, such as triggering a protocol if you are missing
some local state.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="comment">// ticks are lazy by default, forces the second tick to run
</span>tick.spin_batch(<span class="macro">q!</span>(<span class="number">1</span>)).all_ticks().for_each(<span class="macro">q!</span>(|<span class="kw">_</span>| {}));

<span class="kw">let </span>batch_first_tick = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>batch_second_tick = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>))
  .defer_tick(); <span class="comment">// appears on the second tick
</span><span class="kw">let </span>some_on_first_tick = tick.optional_first_tick(<span class="macro">q!</span>(()));
batch_first_tick.chain(batch_second_tick)
  .filter_if_none(some_on_first_tick)
  .all_ticks()
<span class="comment">// [5, 6, 7, 8]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cross_product" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#723-741">Source</a><h4 class="code-header">pub fn <a href="#method.cross_product" class="fn">cross_product</a>&lt;T2, O2: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>&gt;(
    self,
    other: <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T2, L, B, O2, R&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(T, T2)</a>, L, B, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    T2: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Forms the cross-product (Cartesian product, cross-join) of the items in the 2 input streams, returning all
tupled pairs in a non-deterministic order.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>stream1 = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]));
<span class="kw">let </span>stream2 = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));
stream1.cross_product(stream2)</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.unique" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#759-770">Source</a><h4 class="code-header">pub fn <a href="#method.unique" class="fn">unique</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Takes one stream as input and filters out any duplicate occurrences. The output
contains all unique values from the input.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>])).unique()</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_not_in" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#795-812">Source</a><h4 class="code-header">pub fn <a href="#method.filter_not_in" class="fn">filter_not_in</a>&lt;O2: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>&gt;(
    self,
    other: <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O2, R&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Outputs everything in this stream that is <em>not</em> contained in the <code>other</code> stream.</p>
<p>The <code>other</code> stream must be <a href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a>, since this function will wait until
all its elements are available before producing any output.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>stream = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4 </span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>batch = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
stream.filter_not_in(batch).all_ticks()</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.inspect" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#832-863">Source</a><h4 class="code-header">pub fn <a href="#method.inspect" class="fn">inspect</a>&lt;F&gt;(
    self,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>) + 'a,</div></h4></section></summary><div class="docblock"><p>An operator which allows you to “inspect” each element of a stream without
modifying it. The closure <code>f</code> is called on a reference to each item. This is
mainly useful for debugging, and should not be used to generate side-effects.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>nums = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]));
<span class="comment">// prints "1 * 10 = 10" and "2 * 10 = 20"
</span>nums.inspect(<span class="macro">q!</span>(|x| <span class="macro">println!</span>(<span class="string">"{} * 10 = {}"</span>, x, x * <span class="number">10</span>)))</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ir_node_named" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#867-874">Source</a><h4 class="code-header">pub fn <a href="#method.ir_node_named" class="fn">ir_node_named</a>(self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R&gt;</h4></section></summary><div class="docblock"><p>An operator which allows you to “name” a <code>HydroNode</code>.
This is only used for testing, to correlate certain <code>HydroNode</code>s with IDs.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_ordering" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#884-886">Source</a><h4 class="code-header">pub fn <a href="#method.assume_ordering" class="fn">assume_ordering</a>&lt;O2: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>&gt;(
    self,
    _nondet: <a class="struct" href="../../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O2, R&gt;</h4></section></summary><div class="docblock"><p>Explicitly “casts” the stream to a type with a different ordering
guarantee. Useful in unsafe code where the ordering cannot be proven
by the type-system.</p>
<h5 id="non-determinism-3"><a class="doc-anchor" href="#non-determinism-3">§</a>Non-Determinism</h5>
<p>This function is used as an escape hatch, and any mistakes in the
provided ordering guarantee will propagate into the guarantees
for the rest of the program.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.weakest_ordering" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#890-893">Source</a><h4 class="code-header">pub fn <a href="#method.weakest_ordering" class="fn">weakest_ordering</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;</h4></section></summary><div class="docblock"><p>Weakens the ordering guarantee provided by the stream to <a href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder"><code>NoOrder</code></a>,
which is always safe because that is the weakest possible guarantee.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.weaken_ordering" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#897-900">Source</a><h4 class="code-header">pub fn <a href="#method.weaken_ordering" class="fn">weaken_ordering</a>&lt;O2: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a> + <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::live_collections::stream::MinOrder">MinOrder</a>&lt;O, Min = O2&gt;&gt;(
    self,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O2, R&gt;</h4></section></summary><div class="docblock"><p>Weakens the ordering guarantee provided by the stream to <code>O2</code>, with the type-system
enforcing that <code>O2</code> is weaker than the input ordering guarantee.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_retries" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#910-912">Source</a><h4 class="code-header">pub fn <a href="#method.assume_retries" class="fn">assume_retries</a>&lt;R2: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    _nondet: <a class="struct" href="../../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R2&gt;</h4></section></summary><div class="docblock"><p>Explicitly “casts” the stream to a type with a different retries
guarantee. Useful in unsafe code where the lack of retries cannot
be proven by the type-system.</p>
<h5 id="non-determinism-4"><a class="doc-anchor" href="#non-determinism-4">§</a>Non-Determinism</h5>
<p>This function is used as an escape hatch, and any mistakes in the
provided retries guarantee will propagate into the guarantees
for the rest of the program.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.weakest_retries" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#916-919">Source</a><h4 class="code-header">pub fn <a href="#method.weakest_retries" class="fn">weakest_retries</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, <a class="enum" href="enum.AtLeastOnce.html" title="enum hydro_lang::live_collections::stream::AtLeastOnce">AtLeastOnce</a>&gt;</h4></section></summary><div class="docblock"><p>Weakens the retries guarantee provided by the stream to <a href="enum.AtLeastOnce.html" title="enum hydro_lang::live_collections::stream::AtLeastOnce"><code>AtLeastOnce</code></a>,
which is always safe because that is the weakest possible guarantee.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.weaken_retries" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#923-926">Source</a><h4 class="code-header">pub fn <a href="#method.weaken_retries" class="fn">weaken_retries</a>&lt;R2: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a> + <a class="trait" href="trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R, Min = R2&gt;&gt;(
    self,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R2&gt;</h4></section></summary><div class="docblock"><p>Weakens the retries guarantee provided by the stream to <code>R2</code>, with the type-system
enforcing that <code>R2</code> is weaker than the input retries guarantee.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B,+O%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#929-940">Source</a><a href="#impl-Stream%3CT,+L,+B,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.weaker_retries" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#935-939">Source</a><h4 class="code-header">pub fn <a href="#method.weaker_retries" class="fn">weaker_retries</a>&lt;R2: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R2&gt;</h4></section></summary><div class="docblock"><p>Given a stream with <a href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce"><code>ExactlyOnce</code></a> retry guarantees, weakens it to an arbitrary guarantee
<code>R2</code>, which is safe because all guarantees are equal to or weaker than <a href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce"><code>ExactlyOnce</code></a></p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C%26T,+L,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#942-967">Source</a><a href="#impl-Stream%3C%26T,+L,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>, L, B, O, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cloned" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#961-966">Source</a><h4 class="code-header">pub fn <a href="#method.cloned" class="fn">cloned</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Clone each element of the stream; akin to <code>map(q!(|d| d.clone()))</code>.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process.source_iter(<span class="macro">q!</span>(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])).cloned()
<span class="comment">// 1, 2, 3</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B,+O,+R%3E-1" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#969-1153">Source</a><a href="#impl-Stream%3CT,+L,+B,+O,+R%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_commutative_idempotent" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#996-1009">Source</a><h4 class="code-header">pub fn <a href="#method.fold_commutative_idempotent" class="fn">fold_commutative_idempotent</a>&lt;A, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;A, L, B&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, T),</div></h4></section></summary><div class="docblock"><p>Combines elements of the stream into a <a href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>Singleton</code></a>, by starting with an initial value,
generated by the <code>init</code> closure, and then applying the <code>comb</code> closure to each element in the stream.
Unlike iterators, <code>comb</code> takes the accumulator by <code>&amp;mut</code> reference, so that it can be modified in place.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong> AND <strong>idempotent</strong>, as the order of input items is not guaranteed
and there may be duplicates.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>bools = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>]));
<span class="kw">let </span>batch = bools.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold_commutative_idempotent(<span class="macro">q!</span>(|| <span class="bool-val">false</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .all_ticks()
<span class="comment">// true</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_commutative_idempotent" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1035-1046">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_commutative_idempotent" class="fn">reduce_commutative_idempotent</a>&lt;F&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>, T) + 'a,</div></h4></section></summary><div class="docblock"><p>Combines elements of the stream into an <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>, by starting with the first element in the stream,
and then applying the <code>comb</code> closure to each element in the stream. The <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a> will be empty
until the first element in the input arrives. Unlike iterators, <code>comb</code> takes the accumulator by <code>&amp;mut</code>
reference, so that it can be modified in place.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong> AND <strong>idempotent</strong>, as the order of input items is not guaranteed
and there may be duplicates.</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>bools = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>]));
<span class="kw">let </span>batch = bools.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_commutative_idempotent(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .all_ticks()
<span class="comment">// true</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1065-1074">Source</a><h4 class="code-header">pub fn <a href="#method.max" class="fn">max</a>(self) -&gt; <a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,</div></h4></section></summary><div class="docblock"><p>Computes the maximum element in the stream as an <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>, which
will be empty until the first element in the input arrives.</p>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.max().all_ticks()
<span class="comment">// 4</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.max_by_key" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1094-1124">Source</a><h4 class="code-header">pub fn <a href="#method.max_by_key" class="fn">max_by_key</a>&lt;K, F&gt;(
    self,
    key: impl IntoQuotedMut&lt;'a, F, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
) -&gt; <a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>) -&gt; K + 'a,</div></h4></section></summary><div class="docblock"><p>Computes the maximum element in the stream as an <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>, where the
maximum is determined according to the <code>key</code> function. The <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a> will
be empty until the first element in the input arrives.</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.max_by_key(<span class="macro">q!</span>(|x| -x)).all_ticks()
<span class="comment">// 1</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1143-1152">Source</a><h4 class="code-header">pub fn <a href="#method.min" class="fn">min</a>(self) -&gt; <a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,</div></h4></section></summary><div class="docblock"><p>Computes the minimum element in the stream as an <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>, which
will be empty until the first element in the input arrives.</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.min().all_ticks()
<span class="comment">// 1</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B,+O%3E-1" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1155-1244">Source</a><a href="#impl-Stream%3CT,+L,+B,+O%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_commutative" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1181-1192">Source</a><h4 class="code-header">pub fn <a href="#method.fold_commutative" class="fn">fold_commutative</a>&lt;A, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;A, L, B&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, T),</div></h4></section></summary><div class="docblock"><p>Combines elements of the stream into a <a href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>Singleton</code></a>, by starting with an initial value,
generated by the <code>init</code> closure, and then applying the <code>comb</code> closure to each element in the stream.
Unlike iterators, <code>comb</code> takes the accumulator by <code>&amp;mut</code> reference, so that it can be modified in place.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed.</p>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold_commutative(<span class="macro">q!</span>(|| <span class="number">0</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .all_ticks()
<span class="comment">// 10</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_commutative" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1217-1223">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_commutative" class="fn">reduce_commutative</a>&lt;F&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>, T) + 'a,</div></h4></section></summary><div class="docblock"><p>Combines elements of the stream into a <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>, by starting with the first element in the stream,
and then applying the <code>comb</code> closure to each element in the stream. The <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a> will be empty
until the first element in the input arrives. Unlike iterators, <code>comb</code> takes the accumulator by <code>&amp;mut</code>
reference, so that it can be modified in place.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed.</p>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_commutative(<span class="macro">q!</span>(|curr, new| <span class="kw-2">*</span>curr += new))
    .all_ticks()
<span class="comment">// 10</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.count" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1241-1243">Source</a><h4 class="code-header">pub fn <a href="#method.count" class="fn">count</a>(self) -&gt; <a class="struct" href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, L, B&gt;</h4></section></summary><div class="docblock"><p>Computes the number of elements in the stream as a <a href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>Singleton</code></a>.</p>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.count().all_ticks()
<span class="comment">// 4</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B,+TotalOrder,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1246-1361">Source</a><a href="#impl-Stream%3CT,+L,+B,+TotalOrder,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_idempotent" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1272-1283">Source</a><h4 class="code-header">pub fn <a href="#method.fold_idempotent" class="fn">fold_idempotent</a>&lt;A, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;A, L, B&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, T),</div></h4></section></summary><div class="docblock"><p>Combines elements of the stream into a <a href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>Singleton</code></a>, by starting with an initial value,
generated by the <code>init</code> closure, and then applying the <code>comb</code> closure to each element in the stream.
Unlike iterators, <code>comb</code> takes the accumulator by <code>&amp;mut</code> reference, so that it can be modified in place.</p>
<p>The <code>comb</code> closure must be <strong>idempotent</strong>, as there may be non-deterministic duplicates.</p>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>bools = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>]));
<span class="kw">let </span>batch = bools.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold_idempotent(<span class="macro">q!</span>(|| <span class="bool-val">false</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .all_ticks()
<span class="comment">// true</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_idempotent" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1306-1312">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_idempotent" class="fn">reduce_idempotent</a>&lt;F&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>, T) + 'a,</div></h4></section></summary><div class="docblock"><p>Combines elements of the stream into an <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>, by starting with the first element in the stream,
and then applying the <code>comb</code> closure to each element in the stream. The <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a> will be empty
until the first element in the input arrives. Unlike iterators, <code>comb</code> takes the accumulator by <code>&amp;mut</code>
reference, so that it can be modified in place.</p>
<p>The <code>comb</code> closure must be <strong>idempotent</strong>, as there may be non-deterministic duplicates.</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>bools = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>]));
<span class="kw">let </span>batch = bools.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.reduce_idempotent(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x)).all_ticks()
<span class="comment">// true</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.first" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1334-1336">Source</a><h4 class="code-header">pub fn <a href="#method.first" class="fn">first</a>(self) -&gt; <a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;</h4></section></summary><div class="docblock"><p>Computes the first element in the stream as an <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>, which
will be empty until the first element in the input arrives.</p>
<p>This requires the stream to have a <a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, otherwise
re-ordering of elements may cause the first element to change.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.first().all_ticks()
<span class="comment">// 1</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.last" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1358-1360">Source</a><h4 class="code-header">pub fn <a href="#method.last" class="fn">last</a>(self) -&gt; <a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;</h4></section></summary><div class="docblock"><p>Computes the last element in the stream as an <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>, which
will be empty until an element in the input arrives.</p>
<p>This requires the stream to have a <a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, otherwise
re-ordering of elements may cause the last element to change.</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.last().all_ticks()
<span class="comment">// 4</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1363-1633">Source</a><a href="#impl-Stream%3CT,+L,+B%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.enumerate" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1384-1410">Source</a><h4 class="code-header">pub fn <a href="#method.enumerate" class="fn">enumerate</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, T), L, B, <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a stream with the current count tupled with each element in the input stream.</p>
<h5 id="example-34"><a class="doc-anchor" href="#example-34">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
numbers.enumerate()
<span class="comment">// (0, 1), (1, 2), (2, 3), (3, 4)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.fold" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1435-1461">Source</a><h4 class="code-header">pub fn <a href="#method.fold" class="fn">fold</a>&lt;A, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a, F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, T)&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;A, L, B&gt;</h4></section></summary><div class="docblock"><p>Combines elements of the stream into a <a href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>Singleton</code></a>, by starting with an intitial value,
generated by the <code>init</code> closure, and then applying the <code>comb</code> closure to each element in the stream.
Unlike iterators, <code>comb</code> takes the accumulator by <code>&amp;mut</code> reference, so that it can be modified in place.</p>
<p>The input stream must have a <a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, which means that the <code>comb</code> closure is allowed
to depend on the order of elements in the stream.</p>
<h5 id="example-35"><a class="doc-anchor" href="#example-35">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>words = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="string">"HELLO"</span>, <span class="string">"WORLD"</span>]));
<span class="kw">let </span>batch = words.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold(<span class="macro">q!</span>(|| String::new()), <span class="macro">q!</span>(|acc, x| acc.push_str(x)))
    .all_ticks()
<span class="comment">// "HELLOWORLD"</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.collect_vec" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1486-1493">Source</a><h4 class="code-header">pub fn <a href="#method.collect_vec" class="fn">collect_vec</a>(self) -&gt; <a class="struct" href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton">Singleton</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;, L, B&gt;</h4></section></summary><div class="docblock"><p>Collects all the elements of this stream into a single <a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec</code></a> element.</p>
<p>If the input stream is <a href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a>, the output <a href="../struct.Singleton.html" title="struct hydro_lang::live_collections::Singleton"><code>Singleton</code></a> will be <a href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a> as
well, which means that the value of the <a href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec</code></a> will asynchronously grow as new elements
are added. On such a value, you can use <a href="../struct.Singleton.html#method.snapshot" title="method hydro_lang::live_collections::Singleton::snapshot"><code>Singleton::snapshot</code></a> to grab an instance of
the vector at an arbitrary point in time.</p>
<h5 id="example-36"><a class="doc-anchor" href="#example-36">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.collect_vec().all_ticks() <span class="comment">// emit each tick's Vec into an unbounded stream
// [ vec![1, 2, 3, 4] ]</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.scan" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1551-1587">Source</a><h4 class="code-header">pub fn <a href="#method.scan" class="fn">scan</a>&lt;A, U, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, L&gt;,
    f: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;U, L, B, <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, T) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;U&gt; + 'a,</div></h4></section></summary><div class="docblock"><p>Applies a function to each element of the stream, maintaining an internal state (accumulator)
and emitting each intermediate result.</p>
<p>Unlike <code>fold</code> which only returns the final accumulated value, <code>scan</code> produces a new stream
containing all intermediate accumulated values. The scan operation can also terminate early
by returning <code>None</code>.</p>
<p>The function takes a mutable reference to the accumulator and the current element, and returns
an <code>Option&lt;U&gt;</code>. If the function returns <code>Some(value)</code>, <code>value</code> is emitted to the output stream.
If the function returns <code>None</code>, the stream is terminated and no more elements are processed.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<p>Basic usage - running sum:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])).scan(
    <span class="macro">q!</span>(|| <span class="number">0</span>),
    <span class="macro">q!</span>(|acc, x| {
        <span class="kw-2">*</span>acc += x;
        <span class="prelude-val">Some</span>(<span class="kw-2">*</span>acc)
    }),
)
<span class="comment">// Output: 1, 3, 6, 10</span></code></pre></div>
<p>Early termination example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])).scan(
    <span class="macro">q!</span>(|| <span class="number">1</span>),
    <span class="macro">q!</span>(|state, x| {
        <span class="kw-2">*</span>state = <span class="kw-2">*</span>state * x;
        <span class="kw">if </span><span class="kw-2">*</span>state &gt; <span class="number">6 </span>{
            <span class="prelude-val">None </span><span class="comment">// Terminate the stream
        </span>} <span class="kw">else </span>{
            <span class="prelude-val">Some</span>(-<span class="kw-2">*</span>state)
        }
    }),
)
<span class="comment">// Output: -1, -2, -6</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1613-1632">Source</a><h4 class="code-header">pub fn <a href="#method.reduce" class="fn">reduce</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>, T) + 'a&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, L&gt;,
) -&gt; <a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;T, L, B&gt;</h4></section></summary><div class="docblock"><p>Combines elements of the stream into an <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>, by starting with the first element in the stream,
and then applying the <code>comb</code> closure to each element in the stream. The <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a> will be empty
until the first element in the input arrives.</p>
<p>The input stream must have a <a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, which means that the <code>comb</code> closure is allowed
to depend on the order of elements in the stream.</p>
<h5 id="example-37"><a class="doc-anchor" href="#example-37">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>words = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="string">"HELLO"</span>, <span class="string">"WORLD"</span>]));
<span class="kw">let </span>batch = words.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .map(<span class="macro">q!</span>(|x| x.to_string()))
    .reduce(<span class="macro">q!</span>(|curr, new| curr.push_str(<span class="kw-2">&amp;</span>new)))
    .all_ticks()
<span class="comment">// "HELLOWORLD"</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+Unbounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1635-1677">Source</a><a href="#impl-Stream%3CT,+L,+Unbounded,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a> + <a class="trait" href="../../location/tick/trait.NoAtomic.html" title="trait hydro_lang::location::tick::NoAtomic">NoAtomic</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.interleave" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1658-1676">Source</a><h4 class="code-header">pub fn <a href="#method.interleave" class="fn">interleave</a>&lt;O2: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R2: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    other: <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O2, R2&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, &lt;R as <a class="trait" href="trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;&gt;::<a class="associatedtype" href="trait.MinRetries.html#associatedtype.Min" title="type hydro_lang::live_collections::stream::MinRetries::Min">Min</a>&gt;<div class="where">where
    R: <a class="trait" href="trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;,</div></h4></section></summary><div class="docblock"><p>Produces a new stream that interleaves the elements of the two input streams.
The result has <a href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder"><code>NoOrder</code></a> because the order of interleaving is not guaranteed.</p>
<p>Currently, both input streams must be <a href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded"><code>Unbounded</code></a>. When the streams are
<a href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a>, you can use <a href="../struct.Stream.html#method.chain" title="method hydro_lang::live_collections::Stream::chain"><code>Stream::chain</code></a> instead.</p>
<h5 id="example-38"><a class="doc-anchor" href="#example-38">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
numbers.clone().map(<span class="macro">q!</span>(|x| x + <span class="number">1</span>)).interleave(numbers)
<span class="comment">// 2, 3, 4, 5, and 1, 2, 3, 4 interleaved in unknown order</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+Bounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1679-1786">Source</a><a href="#impl-Stream%3CT,+L,+Bounded,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sort" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1706-1717">Source</a><h4 class="code-header">pub fn <a href="#method.sort" class="fn">sort</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, R&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,</div></h4></section></summary><div class="docblock"><p>Produces a new stream that emits the input elements in sorted order.</p>
<p>The input stream can have any ordering guarantee, but the output stream
will have a <a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee. This operator will block until all
elements in the input stream are available, so it requires the input stream
to be <a href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a>.</p>
<h5 id="example-39"><a class="doc-anchor" href="#example-39">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.sort().all_ticks()
<span class="comment">// 1, 2, 3, 4</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.chain" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1744-1762">Source</a><h4 class="code-header">pub fn <a href="#method.chain" class="fn">chain</a>&lt;O2: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R2: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    other: <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O2, R2&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, &lt;O as <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::live_collections::stream::MinOrder">MinOrder</a>&lt;O2&gt;&gt;::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::live_collections::stream::MinOrder::Min">Min</a>, &lt;R as <a class="trait" href="trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;&gt;::<a class="associatedtype" href="trait.MinRetries.html#associatedtype.Min" title="type hydro_lang::live_collections::stream::MinRetries::Min">Min</a>&gt;<div class="where">where
    O: <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::live_collections::stream::MinOrder">MinOrder</a>&lt;O2&gt;,
    R: <a class="trait" href="trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;,</div></h4></section></summary><div class="docblock"><p>Produces a new stream that first emits the elements of the <code>self</code> stream,
and then emits the elements of the <code>other</code> stream. The output stream has
a <a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee if and only if both input streams have a
<a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee.</p>
<p>Currently, both input streams must be <a href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded"><code>Bounded</code></a>. This operator will block
on the first stream until all its elements are available. In a future version,
we will relax the requirement on the <code>other</code> stream.</p>
<h5 id="example-40"><a class="doc-anchor" href="#example-40">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.clone().map(<span class="macro">q!</span>(|x| x + <span class="number">1</span>)).chain(batch).all_ticks()
<span class="comment">// 2, 3, 4, 5, 1, 2, 3, 4</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.cross_product_nested_loop" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1767-1785">Source</a><h4 class="code-header">pub fn <a href="#method.cross_product_nested_loop" class="fn">cross_product_nested_loop</a>&lt;T2, O2: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a> + <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::live_collections::stream::MinOrder">MinOrder</a>&lt;O&gt;&gt;(
    self,
    other: <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T2, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O2, R&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(T, T2)</a>, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, &lt;O2 as <a class="trait" href="trait.MinOrder.html" title="trait hydro_lang::live_collections::stream::MinOrder">MinOrder</a>&lt;O&gt;&gt;::<a class="associatedtype" href="trait.MinOrder.html#associatedtype.Min" title="type hydro_lang::live_collections::stream::MinOrder::Min">Min</a>, R&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    T2: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Forms the cross-product (Cartesian product, cross-join) of the items in the 2 input streams.
Unlike <a href="../struct.Stream.html#method.cross_product" title="method hydro_lang::live_collections::Stream::cross_product"><code>Stream::cross_product</code></a>, the output order is totally ordered when the inputs are
because this is compiled into a nested loop.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C(K,+V1),+L,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1788-1872">Source</a><a href="#impl-Stream%3C(K,+V1),+L,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V1, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V1)</a>, L, B, O, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.join" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1811-1829">Source</a><h4 class="code-header">pub fn <a href="#method.join" class="fn">join</a>&lt;V2, O2: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R2: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    n: <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V2)</a>, L, B, O2, R2&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;(K, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(V1, V2)</a>), L, B, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, &lt;R as <a class="trait" href="trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;&gt;::<a class="associatedtype" href="trait.MinRetries.html#associatedtype.Min" title="type hydro_lang::live_collections::stream::MinRetries::Min">Min</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    R: <a class="trait" href="trait.MinRetries.html" title="trait hydro_lang::live_collections::stream::MinRetries">MinRetries</a>&lt;R2&gt;,</div></h4></section></summary><div class="docblock"><p>Given two streams of pairs <code>(K, V1)</code> and <code>(K, V2)</code>, produces a new stream of nested pairs <code>(K, (V1, V2))</code>
by equi-joining the two streams on the key attribute <code>K</code>.</p>
<h5 id="example-41"><a class="doc-anchor" href="#example-41">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>stream1 = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>)]));
<span class="kw">let </span>stream2 = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="string">'x'</span>), (<span class="number">2</span>, <span class="string">'y'</span>)]));
stream1.join(stream2)
<span class="comment">// (1, ('a', 'x')), (2, ('b', 'y'))</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.anti_join" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1854-1871">Source</a><h4 class="code-header">pub fn <a href="#method.anti_join" class="fn">anti_join</a>&lt;O2: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R2: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt;(
    self,
    n: <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;K, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O2, R2&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V1)</a>, L, B, O, R&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,</div></h4></section></summary><div class="docblock"><p>Given a stream of pairs <code>(K, V1)</code> and a bounded stream of keys <code>K</code>,
computes the anti-join of the items in the input – i.e. returns
unique items in the first input that do not have a matching key
in the second input.</p>
<h5 id="example-42"><a class="doc-anchor" href="#example-42">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>stream = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[ (<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>), (<span class="number">4</span>, <span class="string">'d'</span>) ]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>batch = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
stream.anti_join(batch).all_ticks()</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C(K,+V),+L,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1874-1907">Source</a><a href="#impl-Stream%3C(K,+V),+L,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, L, B, O, R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_keyed" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1901-1906">Source</a><h4 class="code-header">pub fn <a href="#method.into_keyed" class="fn">into_keyed</a>(self) -&gt; <a class="struct" href="../struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream">KeyedStream</a>&lt;K, V, L, B, O, R&gt;</h4></section></summary><div class="docblock"><p>Transforms this stream into a <a href="../struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream"><code>KeyedStream</code></a>, where the first element of each tuple
is used as the key and the second element is added to the entries associated with that key.</p>
<p>Because <a href="../struct.KeyedStream.html" title="struct hydro_lang::live_collections::KeyedStream"><code>KeyedStream</code></a> lazily groups values into buckets, this operator has zero computational
cost and <em>does not</em> require that the key type is hashable. Keyed streams are useful for
performing grouped aggregations, but also for more precise ordering guarantees such as
total ordering <em>within</em> each group but no ordering <em>across</em> groups.</p>
<h5 id="example-43"><a class="doc-anchor" href="#example-43">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process
    .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]))
    .into_keyed()
<span class="comment">// { 1: [2, 3], 2: [4] }</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C(K,+V),+Tick%3CL%3E,+Bounded%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1909-1997">Source</a><a href="#impl-Stream%3C(K,+V),+Tick%3CL%3E,+Bounded%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_keyed" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1942-1952">Source</a><h4 class="code-header">pub fn <a href="#method.fold_keyed" class="fn">fold_keyed</a>&lt;A, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, A)</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V) + 'a,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use .into_keyed().fold(…) instead</span></div></span></summary><div class="docblock"><p>A special case of <a href="../struct.Stream.html#method.fold" title="method hydro_lang::live_collections::Stream::fold"><code>Stream::fold</code></a>, in the spirit of SQL’s GROUP BY and aggregation constructs. The input
tuples are partitioned into groups by the first element (“keys”), and for each group the values
in the second element are accumulated via the <code>comb</code> closure.</p>
<p>The input stream must have a <a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, which means that the <code>comb</code> closure is allowed
to depend on the order of elements in the stream.</p>
<p>If the input and output value types are the same and do not require initialization then use
<a href="../struct.Stream.html#method.reduce_keyed" title="method hydro_lang::live_collections::Stream::reduce_keyed"><code>Stream::reduce_keyed</code></a>.</p>
<h5 id="example-44"><a class="doc-anchor" href="#example-44">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold_keyed(<span class="macro">q!</span>(|| <span class="number">0</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .all_ticks()
<span class="comment">// (1, 5), (2, 7)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_keyed" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1979-1996">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_keyed" class="fn">reduce_keyed</a>&lt;F&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use .into_keyed().reduce(…) instead</span></div></span></summary><div class="docblock"><p>A special case of <a href="../struct.Stream.html#method.reduce" title="method hydro_lang::live_collections::Stream::reduce"><code>Stream::reduce</code></a>, in the spirit of SQL’s GROUP BY and aggregation constructs. The input
tuples are partitioned into groups by the first element (“keys”), and for each group the values
in the second element are accumulated via the <code>comb</code> closure.</p>
<p>The input stream must have a <a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a> guarantee, which means that the <code>comb</code> closure is allowed
to depend on the order of elements in the stream.</p>
<p>If you need the accumulated value to have a different type than the input, use <a href="../struct.Stream.html#method.fold_keyed" title="method hydro_lang::live_collections::Stream::fold_keyed"><code>Stream::fold_keyed</code></a>.</p>
<h5 id="example-45"><a class="doc-anchor" href="#example-45">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.reduce_keyed(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x)).all_ticks()
<span class="comment">// (1, 5), (2, 7)</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C(K,+V),+Tick%3CL%3E,+Bounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#1999-2106">Source</a><a href="#impl-Stream%3C(K,+V),+Tick%3CL%3E,+Bounded,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_keyed_commutative_idempotent" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2032-2044">Source</a><h4 class="code-header">pub fn <a href="#method.fold_keyed_commutative_idempotent" class="fn">fold_keyed_commutative_idempotent</a>&lt;A, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, A)</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V) + 'a,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use .into_keyed().fold_commutative_idempotent(…) instead</span></div></span></summary><div class="docblock"><p>A special case of <a href="../struct.Stream.html#method.fold_commutative_idempotent" title="method hydro_lang::live_collections::Stream::fold_commutative_idempotent"><code>Stream::fold_commutative_idempotent</code></a>, in the spirit of SQL’s GROUP BY and aggregation constructs.
The input tuples are partitioned into groups by the first element (“keys”), and for each group the values
in the second element are accumulated via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed, and <strong>idempotent</strong>,
as there may be non-deterministic duplicates.</p>
<p>If the input and output value types are the same and do not require initialization then use
<a href="../struct.Stream.html#method.reduce_keyed_commutative_idempotent" title="method hydro_lang::live_collections::Stream::reduce_keyed_commutative_idempotent"><code>Stream::reduce_keyed_commutative_idempotent</code></a>.</p>
<h5 id="example-46"><a class="doc-anchor" href="#example-46">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>)]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold_keyed_commutative_idempotent(<span class="macro">q!</span>(|| <span class="bool-val">false</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .all_ticks()
<span class="comment">// (1, false), (2, true)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.keys" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2062-2066">Source</a><h4 class="code-header">pub fn <a href="#method.keys" class="fn">keys</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;K, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;</h4></section></summary><div class="docblock"><p>Given a stream of pairs <code>(K, V)</code>, produces a new stream of unique keys <code>K</code>.</p>
<h5 id="example-47"><a class="doc-anchor" href="#example-47">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch.keys().all_ticks()
<span class="comment">// 1, 2</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_keyed_commutative_idempotent" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2095-2105">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_keyed_commutative_idempotent" class="fn">reduce_keyed_commutative_idempotent</a>&lt;F&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use .into_keyed().reduce_commutative_idempotent(…) instead</span></div></span></summary><div class="docblock"><p>A special case of <a href="../struct.Stream.html#method.reduce_commutative_idempotent" title="method hydro_lang::live_collections::Stream::reduce_commutative_idempotent"><code>Stream::reduce_commutative_idempotent</code></a>, in the spirit of SQL’s GROUP BY and aggregation constructs.
The input tuples are partitioned into groups by the first element (“keys”), and for each group the values
in the second element are accumulated via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed, and <strong>idempotent</strong>,
as there may be non-deterministic duplicates.</p>
<p>If you need the accumulated value to have a different type than the input, use <a href="../struct.Stream.html#method.fold_keyed_commutative_idempotent" title="method hydro_lang::live_collections::Stream::fold_keyed_commutative_idempotent"><code>Stream::fold_keyed_commutative_idempotent</code></a>.</p>
<h5 id="example-48"><a class="doc-anchor" href="#example-48">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>)]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_keyed_commutative_idempotent(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .all_ticks()
<span class="comment">// (1, false), (2, true)</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C(K,+V),+Tick%3CL%3E,+Bounded,+O%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2108-2187">Source</a><a href="#impl-Stream%3C(K,+V),+Tick%3CL%3E,+Bounded,+O%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_keyed_commutative" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2140-2150">Source</a><h4 class="code-header">pub fn <a href="#method.fold_keyed_commutative" class="fn">fold_keyed_commutative</a>&lt;A, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, A)</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V) + 'a,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use .into_keyed().fold_commutative(…) instead</span></div></span></summary><div class="docblock"><p>A special case of <a href="../struct.Stream.html#method.fold_commutative" title="method hydro_lang::live_collections::Stream::fold_commutative"><code>Stream::fold_commutative</code></a>, in the spirit of SQL’s GROUP BY and aggregation constructs. The input
tuples are partitioned into groups by the first element (“keys”), and for each group the values
in the second element are accumulated via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed.</p>
<p>If the input and output value types are the same and do not require initialization then use
<a href="../struct.Stream.html#method.reduce_keyed_commutative" title="method hydro_lang::live_collections::Stream::reduce_keyed_commutative"><code>Stream::reduce_keyed_commutative</code></a>.</p>
<h5 id="example-49"><a class="doc-anchor" href="#example-49">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold_keyed_commutative(<span class="macro">q!</span>(|| <span class="number">0</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .all_ticks()
<span class="comment">// (1, 5), (2, 7)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_keyed_commutative" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2178-2186">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_keyed_commutative" class="fn">reduce_keyed_commutative</a>&lt;F&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use .into_keyed().reduce_commutative(…) instead</span></div></span></summary><div class="docblock"><p>A special case of <a href="../struct.Stream.html#method.reduce_commutative" title="method hydro_lang::live_collections::Stream::reduce_commutative"><code>Stream::reduce_commutative</code></a>, in the spirit of SQL’s GROUP BY and aggregation constructs. The input
tuples are partitioned into groups by the first element (“keys”), and for each group the values
in the second element are accumulated via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>commutative</strong>, as the order of input items is not guaranteed.</p>
<p>If you need the accumulated value to have a different type than the input, use <a href="../struct.Stream.html#method.fold_keyed_commutative" title="method hydro_lang::live_collections::Stream::fold_keyed_commutative"><code>Stream::fold_keyed_commutative</code></a>.</p>
<h5 id="example-50"><a class="doc-anchor" href="#example-50">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_keyed_commutative(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc += x))
    .all_ticks()
<span class="comment">// (1, 5), (2, 7)</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3C(K,+V),+Tick%3CL%3E,+Bounded,+TotalOrder,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2189-2268">Source</a><a href="#impl-Stream%3C(K,+V),+Tick%3CL%3E,+Bounded,+TotalOrder,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, K, V, L, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, R&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fold_keyed_idempotent" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2221-2231">Source</a><h4 class="code-header">pub fn <a href="#method.fold_keyed_idempotent" class="fn">fold_keyed_idempotent</a>&lt;A, I, F&gt;(
    self,
    init: impl IntoQuotedMut&lt;'a, I, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
    comb: impl IntoQuotedMut&lt;'a, F, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, A)</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>() -&gt; A + 'a,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut A</a>, V) + 'a,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use .into_keyed().fold_idempotent(…) instead</span></div></span></summary><div class="docblock"><p>A special case of <a href="../struct.Stream.html#method.fold_idempotent" title="method hydro_lang::live_collections::Stream::fold_idempotent"><code>Stream::fold_idempotent</code></a>, in the spirit of SQL’s GROUP BY and aggregation constructs.
The input tuples are partitioned into groups by the first element (“keys”), and for each group the values
in the second element are accumulated via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>idempotent</strong> as there may be non-deterministic duplicates.</p>
<p>If the input and output value types are the same and do not require initialization then use
<a href="../struct.Stream.html#method.reduce_keyed_idempotent" title="method hydro_lang::live_collections::Stream::reduce_keyed_idempotent"><code>Stream::reduce_keyed_idempotent</code></a>.</p>
<h5 id="example-51"><a class="doc-anchor" href="#example-51">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>)]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .fold_keyed_idempotent(<span class="macro">q!</span>(|| <span class="bool-val">false</span>), <span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .all_ticks()
<span class="comment">// (1, false), (2, true)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce_keyed_idempotent" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2259-2267">Source</a><h4 class="code-header">pub fn <a href="#method.reduce_keyed_idempotent" class="fn">reduce_keyed_idempotent</a>&lt;F&gt;(
    self,
    comb: impl IntoQuotedMut&lt;'a, F, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(K, V)</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut V</a>, V) + 'a,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use .into_keyed().reduce_idempotent(…) instead</span></div></span></summary><div class="docblock"><p>A special case of <a href="../struct.Stream.html#method.reduce_idempotent" title="method hydro_lang::live_collections::Stream::reduce_idempotent"><code>Stream::reduce_idempotent</code></a>, in the spirit of SQL’s GROUP BY and aggregation constructs.
The input tuples are partitioned into groups by the first element (“keys”), and for each group the values
in the second element are accumulated via the <code>comb</code> closure.</p>
<p>The <code>comb</code> closure must be <strong>idempotent</strong>, as there may be non-deterministic duplicates.</p>
<p>If you need the accumulated value to have a different type than the input, use <a href="../struct.Stream.html#method.fold_keyed_idempotent" title="method hydro_lang::live_collections::Stream::fold_keyed_idempotent"><code>Stream::fold_keyed_idempotent</code></a>.</p>
<h5 id="example-52"><a class="doc-anchor" href="#example-52">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="kw">let </span>numbers = process.source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[(<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">true</span>), (<span class="number">1</span>, <span class="bool-val">false</span>), (<span class="number">2</span>, <span class="bool-val">false</span>)]));
<span class="kw">let </span>batch = numbers.batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
batch
    .reduce_keyed_idempotent(<span class="macro">q!</span>(|acc, x| <span class="kw-2">*</span>acc |= x))
    .all_ticks()
<span class="comment">// (1, false), (2, true)</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+Atomic%3CL%3E,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2270-2300">Source</a><a href="#impl-Stream%3CT,+Atomic%3CL%3E,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, B, O, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.batch" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2280-2288">Source</a><h4 class="code-header">pub fn <a href="#method.batch" class="fn">batch</a>(self, _nondet: <a class="struct" href="../../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Returns a stream corresponding to the latest batch of elements being atomically
processed. These batches are guaranteed to be contiguous across ticks and preserve
the order of the input.</p>
<h5 id="non-determinism-5"><a class="doc-anchor" href="#non-determinism-5">§</a>Non-Determinism</h5>
<p>The batch boundaries are non-deterministic and may change across executions.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.end_atomic" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2292-2294">Source</a><h4 class="code-header">pub fn <a href="#method.end_atomic" class="fn">end_atomic</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R&gt;</h4></section></summary><div class="docblock"><p>Yields the elements of this stream back into a top-level, asynchronous execution context.
See <a href="../struct.Stream.html#method.atomic" title="method hydro_lang::live_collections::Stream::atomic"><code>Stream::atomic</code></a> for more details.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.atomic_source" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2297-2299">Source</a><h4 class="code-header">pub fn <a href="#method.atomic_source" class="fn">atomic_source</a>(&amp;self) -&gt; <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;</h4></section></summary><div class="docblock"><p>Gets the <a href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> inside which this stream is synchronously processed. See <a href="../struct.Stream.html#method.atomic" title="method hydro_lang::live_collections::Stream::atomic"><code>Stream::atomic</code></a>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B,+O,+R%3E-2" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2302-2430">Source</a><a href="#impl-Stream%3CT,+L,+B,+O,+R%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a> + <a class="trait" href="../../location/tick/trait.NoAtomic.html" title="trait hydro_lang::location::tick::NoAtomic">NoAtomic</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.atomic" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2314-2316">Source</a><h4 class="code-header">pub fn <a href="#method.atomic" class="fn">atomic</a>(self, tick: &amp;<a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, B, O, R&gt;</h4></section></summary><div class="docblock"><p>Shifts this stream into an atomic context, which guarantees that any downstream logic
will all be executed synchronously before any outputs are yielded (in <a href="../struct.Stream.html#method.end_atomic" title="method hydro_lang::live_collections::Stream::end_atomic"><code>Stream::end_atomic</code></a>).</p>
<p>This is useful to enforce local consistency constraints, such as ensuring that a write is
processed before an acknowledgement is emitted. Entering an atomic section requires a <a href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a>
argument that declares where the stream will be atomically processed. Batching a stream into
the <em>same</em> <a href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> will preserve the synchronous execution, while batching into a different
<a href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> will introduce asynchrony.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resolve_futures" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2346-2357">Source</a><h4 class="code-header">pub fn <a href="#method.resolve_futures" class="fn">resolve_futures</a>&lt;T2&gt;(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T2, L, B, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = T2&gt;,</div></h4></section></summary><div class="docblock"><p>Consumes a stream of <code>Future&lt;T&gt;</code>, produces a new stream of the resulting <code>T</code> outputs.
Future outputs are produced as available, regardless of input arrival order.</p>
<h5 id="example-53"><a class="doc-anchor" href="#example-53">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process.source_iter(<span class="macro">q!</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>]))
    .map(<span class="macro">q!</span>(|x| <span class="kw">async move </span>{
        tokio::time::sleep(tokio::time::Duration::from_millis(<span class="number">10</span>)).<span class="kw">await</span>;
        x
    }))
    .resolve_futures()
<span class="comment">// 1, 2, 3, 4, 5, 6, 7, 8, 9 (in any order)</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.batch-1" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2366-2368">Source</a><h4 class="code-header">pub fn <a href="#method.batch-1" class="fn">batch</a>(
    self,
    tick: &amp;<a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;,
    nondet: <a class="struct" href="../../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Given a tick, returns a stream corresponding to a batch of elements segmented by
that tick. These batches are guaranteed to be contiguous across ticks and preserve
the order of the input. The output stream will execute in the <a href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> that was
used to create the atomic section.</p>
<h5 id="non-determinism-6"><a class="doc-anchor" href="#non-determinism-6">§</a>Non-Determinism</h5>
<p>The batch boundaries are non-deterministic and may change across executions.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sample_every" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2378-2390">Source</a><h4 class="code-header">pub fn <a href="#method.sample_every" class="fn">sample_every</a>(
    self,
    interval: impl QuotedWithContext&lt;'a, <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>, L&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> + 'a,
    nondet: <a class="struct" href="../../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, <a class="enum" href="enum.AtLeastOnce.html" title="enum hydro_lang::live_collections::stream::AtLeastOnce">AtLeastOnce</a>&gt;</h4></section></summary><div class="docblock"><p>Given a time interval, returns a stream corresponding to samples taken from the
stream roughly at that interval. The output will have elements in the same order
as the input, but with arbitrary elements skipped between samples. There is also
no guarantee on the exact timing of the samples.</p>
<h5 id="non-determinism-7"><a class="doc-anchor" href="#non-determinism-7">§</a>Non-Determinism</h5>
<p>The output stream is non-deterministic in which elements are sampled, since this
is controlled by a clock.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timeout" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2401-2429">Source</a><h4 class="code-header">pub fn <a href="#method.timeout" class="fn">timeout</a>(
    self,
    duration: impl QuotedWithContext&lt;'a, <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> + 'a,
    nondet: <a class="struct" href="../../nondet/struct.NonDet.html" title="struct hydro_lang::nondet::NonDet">NonDet</a>,
) -&gt; <a class="struct" href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional">Optional</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>&gt;</h4></section></summary><div class="docblock"><p>Given a timeout duration, returns an <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a>  which will have a value if the
stream has not emitted a value since that duration.</p>
<h5 id="non-determinism-8"><a class="doc-anchor" href="#non-determinism-8">§</a>Non-Determinism</h5>
<p>Timeout relies on non-deterministic sampling of the stream, so depending on when
samples take place, timeouts may be non-deterministically generated or missed,
and the notification of the timeout may be delayed as well. There is also no
guarantee on how long the <a href="../struct.Optional.html" title="struct hydro_lang::live_collections::Optional"><code>Optional</code></a> will have a value after the timeout is
detected based on when the next sample is taken.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CF,+L,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2432-2474">Source</a><a href="#impl-Stream%3CF,+L,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, F, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;F, L, B, O, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a> + <a class="trait" href="../../location/tick/trait.NoAtomic.html" title="trait hydro_lang::location::tick::NoAtomic">NoAtomic</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.resolve_futures_ordered" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2465-2473">Source</a><h4 class="code-header">pub fn <a href="#method.resolve_futures_ordered" class="fn">resolve_futures_ordered</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R&gt;</h4></section></summary><div class="docblock"><p>Consumes a stream of <code>Future&lt;T&gt;</code>, produces a new stream of the resulting <code>T</code> outputs.
Future outputs are produced in the same order as the input stream.</p>
<h5 id="example-54"><a class="doc-anchor" href="#example-54">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>process.source_iter(<span class="macro">q!</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>]))
    .map(<span class="macro">q!</span>(|x| <span class="kw">async move </span>{
        tokio::time::sleep(tokio::time::Duration::from_millis(<span class="number">10</span>)).<span class="kw">await</span>;
        x
    }))
    .resolve_futures_ordered()
<span class="comment">// 2, 3, 1, 9, 6, 5, 4, 7, 8</span></code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+L,+B%3E-1" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2476-2520">Source</a><a href="#impl-Stream%3CT,+L,+B%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt; + <a class="trait" href="../../location/tick/trait.NoTick.html" title="trait hydro_lang::location::tick::NoTick">NoTick</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.for_each" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2486-2500">Source</a><h4 class="code-header">pub fn <a href="#method.for_each" class="fn">for_each</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) + 'a&gt;(self, f: impl IntoQuotedMut&lt;'a, F, L&gt;)</h4></section></summary><div class="docblock"><p>Executes the provided closure for every element in this stream.</p>
<p>Because the closure may have side effects, the stream must have deterministic order
(<a href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder"><code>TotalOrder</code></a>) and no retries (<a href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce"><code>ExactlyOnce</code></a>). If the side effects can tolerate
out-of-order or duplicate execution, use <a href="../struct.Stream.html#method.assume_ordering" title="method hydro_lang::live_collections::Stream::assume_ordering"><code>Stream::assume_ordering</code></a> and
<a href="../struct.Stream.html#method.assume_retries" title="method hydro_lang::live_collections::Stream::assume_retries"><code>Stream::assume_retries</code></a> with an explanation for why this is the case.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dest_sink" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2507-2519">Source</a><h4 class="code-header">pub fn <a href="#method.dest_sink" class="fn">dest_sink</a>&lt;S&gt;(self, sink: impl QuotedWithContext&lt;'a, S, L&gt;)<div class="where">where
    S: 'a + Sink&lt;T&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h4></section></summary><div class="docblock"><p>Sends all elements of this stream to a provided [<code>futures::Sink</code>], such as an external
TCP socket to some other server. You should <em>not</em> use this API for interacting with
external clients, instead see <a href="../../location/trait.Location.html#method.bidi_external_many_bytes" title="method hydro_lang::location::Location::bidi_external_many_bytes"><code>Location::bidi_external_many_bytes</code></a> and
<a href="../../location/trait.Location.html#method.bidi_external_many_bincode" title="method hydro_lang::location::Location::bidi_external_many_bincode"><code>Location::bidi_external_many_bincode</code></a>. This should be used for custom, low-level
interaction with asynchronous sinks.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Stream%3CT,+Tick%3CL%3E,+Bounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2522-2612">Source</a><a href="#impl-Stream%3CT,+Tick%3CL%3E,+Bounded,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.all_ticks" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2528-2536">Source</a><h4 class="code-header">pub fn <a href="#method.all_ticks" class="fn">all_ticks</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Asynchronously yields this batch of elements outside the tick as an unbounded stream,
which will stream all the elements across <em>all</em> tick iterations by concatenating the batches.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.all_ticks_atomic" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2544-2554">Source</a><h4 class="code-header">pub fn <a href="#method.all_ticks_atomic" class="fn">all_ticks_atomic</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic">Atomic</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;</h4></section></summary><div class="docblock"><p>Synchronously yields this batch of elements outside the tick as an unbounded stream,
which will stream all the elements across <em>all</em> tick iterations by concatenating the batches.</p>
<p>Unlike <a href="../struct.Stream.html#method.all_ticks" title="method hydro_lang::live_collections::Stream::all_ticks"><code>Stream::all_ticks</code></a>, this preserves synchronous execution, as the output stream
is emitted in an <a href="../../location/tick/struct.Atomic.html" title="struct hydro_lang::location::tick::Atomic"><code>Atomic</code></a> context that will process elements synchronously with the input
stream’s <a href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick"><code>Tick</code></a> context.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.persist" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2589-2600">Source</a><h4 class="code-header">pub fn <a href="#method.persist" class="fn">persist</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h4></section></summary><div class="docblock"><p>Accumulates the elements of this stream <strong>across ticks</strong> by concatenating them together.</p>
<p>The output stream in tick T will contain the elements of the input at tick 0, 1, …, up to
and including tick T. This is useful for accumulating streaming inputs across ticks, but be
careful when using this operator, as its memory usage will grow linearly over time since it
must store its inputs indefinitely.</p>
<h5 id="example-55"><a class="doc-anchor" href="#example-55">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>tick = process.tick();
<span class="comment">// ticks are lazy by default, forces the second tick to run
</span>tick.spin_batch(<span class="macro">q!</span>(<span class="number">1</span>)).all_ticks().for_each(<span class="macro">q!</span>(|<span class="kw">_</span>| {}));

<span class="kw">let </span>batch_first_tick = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>));
<span class="kw">let </span>batch_second_tick = process
  .source_iter(<span class="macro">q!</span>(<span class="macro">vec!</span>[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]))
  .batch(<span class="kw-2">&amp;</span>tick, <span class="macro">nondet!</span>(<span class="doccomment">/** test */</span>))
  .defer_tick(); <span class="comment">// appears on the second tick
</span>batch_first_tick.chain(batch_second_tick)
  .persist()
  .all_ticks()
<span class="comment">// [1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, ...]</span></code></pre></div></div></details><section id="method.defer_tick" class="method"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#2603-2611">Source</a><h4 class="code-header">pub fn <a href="#method.defer_tick" class="fn">defer_tick</a>(self) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;</h4></section></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Stream%3CT,+L,+B,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#304-332">Source</a><a href="#impl-Clone-for-Stream%3CT,+L,+B,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, R&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#309-331">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DeferTick-for-Stream%3CT,+Tick%3CL%3E,+Bounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#206-213">Source</a><a href="#impl-DeferTick-for-Stream%3CT,+Tick%3CL%3E,+Bounded,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="trait" href="../../location/tick/trait.DeferTick.html" title="trait hydro_lang::location::tick::DeferTick">DeferTick</a> for <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, <a class="struct" href="../../location/tick/struct.Tick.html" title="struct hydro_lang::location::tick::Tick">Tick</a>&lt;L&gt;, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.defer_tick-1" class="method trait-impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#210-212">Source</a><a href="#method.defer_tick-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../location/tick/trait.DeferTick.html#tymethod.defer_tick" class="fn">defer_tick</a>(self) -&gt; Self</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CStream%3CT,+L,+B,+O%3E%3E-for-Stream%3CT,+L,+B,+O,+AtLeastOnce%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#192-204">Source</a><a href="#impl-From%3CStream%3CT,+L,+B,+O%3E%3E-for-Stream%3CT,+L,+B,+O,+AtLeastOnce%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O&gt;&gt; for <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, <a class="enum" href="enum.AtLeastOnce.html" title="enum hydro_lang::live_collections::stream::AtLeastOnce">AtLeastOnce</a>&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#197-203">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(
    stream: <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt;,
) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, O, <a class="enum" href="enum.AtLeastOnce.html" title="enum hydro_lang::live_collections::stream::AtLeastOnce">AtLeastOnce</a>&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CStream%3CT,+L,+B,+TotalOrder,+R%3E%3E-for-Stream%3CT,+L,+B,+NoOrder,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#178-190">Source</a><a href="#impl-From%3CStream%3CT,+L,+B,+TotalOrder,+R%3E%3E-for-Stream%3CT,+L,+B,+NoOrder,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, B: <a class="trait" href="../boundedness/trait.Boundedness.html" title="trait hydro_lang::live_collections::boundedness::Boundedness">Boundedness</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, R&gt;&gt; for <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#183-189">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(stream: <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, R&gt;) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, B, <a class="enum" href="enum.NoOrder.html" title="enum hydro_lang::live_collections::stream::NoOrder">NoOrder</a>, R&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CStream%3CT,+L,+Bounded,+O,+R%3E%3E-for-Stream%3CT,+L,+Unbounded,+O,+R%3E" class="impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#164-176">Source</a><a href="#impl-From%3CStream%3CT,+L,+Bounded,+O,+R%3E%3E-for-Stream%3CT,+L,+Unbounded,+O,+R%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, L, O: <a class="trait" href="trait.Ordering.html" title="trait hydro_lang::live_collections::stream::Ordering">Ordering</a>, R: <a class="trait" href="trait.Retries.html" title="trait hydro_lang::live_collections::stream::Retries">Retries</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;&gt; for <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;<div class="where">where
    L: <a class="trait" href="../../location/trait.Location.html" title="trait hydro_lang::location::Location">Location</a>&lt;'a&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../../src/hydro_lang/live_collections/stream/mod.rs.html#169-175">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(stream: <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Bounded.html" title="enum hydro_lang::live_collections::boundedness::Bounded">Bounded</a>, O, R&gt;) -&gt; <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;T, L, <a class="enum" href="../boundedness/enum.Unbounded.html" title="enum hydro_lang::live_collections::boundedness::Unbounded">Unbounded</a>, O, R&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-Freeze-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Type, Loc, Bound, Order = <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;Type, Loc, Bound, Order, Retry&gt;</h3></section><section id="impl-RefUnwindSafe-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Type, Loc, Bound, Order = <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;Type, Loc, Bound, Order, Retry&gt;</h3></section><section id="impl-Send-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-Send-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Type, Loc, Bound, Order = <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;Type, Loc, Bound, Order, Retry&gt;</h3></section><section id="impl-Sync-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-Sync-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Type, Loc, Bound, Order = <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;Type, Loc, Bound, Order, Retry&gt;</h3></section><section id="impl-Unpin-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-Unpin-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Type, Loc, Bound, Order, Retry&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;Type, Loc, Bound, Order, Retry&gt;<div class="where">where
    Loc: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Type: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Bound: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Order: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    Retry: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" class="impl"><a href="#impl-UnwindSafe-for-Stream%3CType,+Loc,+Bound,+Order,+Retry%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Type, Loc, Bound, Order = <a class="enum" href="enum.TotalOrder.html" title="enum hydro_lang::live_collections::stream::TotalOrder">TotalOrder</a>, Retry = <a class="enum" href="enum.ExactlyOnce.html" title="enum hydro_lang::live_collections::stream::ExactlyOnce">ExactlyOnce</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../struct.Stream.html" title="struct hydro_lang::live_collections::Stream">Stream</a>&lt;Type, Loc, Bound, Order, Retry&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#515">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#517">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-DynClone-for-T" class="impl"><a class="src rightside" href="https://docs.rs/dyn-clone/1.0.20/src/dyn_clone/lib.rs.html#196-198">Source</a><a href="#impl-DynClone-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/dyn-clone/1.0.20/dyn_clone/trait.DynClone.html" title="trait dyn_clone::DynClone">DynClone</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><section id="method.__clone_box" class="method trait-impl"><a class="src rightside" href="https://docs.rs/dyn-clone/1.0.20/src/dyn_clone/lib.rs.html#200">Source</a><a href="#method.__clone_box" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/dyn-clone/1.0.20/dyn_clone/trait.DynClone.html#tymethod.__clone_box" class="fn">__clone_box</a>(&amp;self, _: Private) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a></h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Instrument for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a class="fn">instrument</a>(self, span: Span) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided [<code>Span</code>], returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a class="fn">in_current_span</a>(self) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="super::Span::current()">current</a> <a href="crate::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-PolicyExt-for-T" class="impl"><a href="#impl-PolicyExt-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; PolicyExt for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.and" class="method trait-impl"><a href="#method.and" class="anchor">§</a><h4 class="code-header">fn <a class="fn">and</a>&lt;P, B, E&gt;(self, other: P) -&gt; And&lt;T, P&gt;<div class="where">where
    T: Policy&lt;B, E&gt;,
    P: Policy&lt;B, E&gt;,</div></h4></section></summary><div class='docblock'>Create a new <code>Policy</code> that returns [<code>Action::Follow</code>] only if <code>self</code> and <code>other</code> return
<code>Action::Follow</code>. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.or" class="method trait-impl"><a href="#method.or" class="anchor">§</a><h4 class="code-header">fn <a class="fn">or</a>&lt;P, B, E&gt;(self, other: P) -&gt; Or&lt;T, P&gt;<div class="where">where
    T: Policy&lt;B, E&gt;,
    P: Policy&lt;B, E&gt;,</div></h4></section></summary><div class='docblock'>Create a new <code>Policy</code> that returns [<code>Action::Follow</code>] if either <code>self</code> or <code>other</code> returns
<code>Action::Follow</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.18.0/src/typenum/type_operators.rs.html#34">Source</a><a href="#impl-Same-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.18.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="https://docs.rs/typenum/1.18.0/src/typenum/type_operators.rs.html#35">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.18.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#84-86">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#88">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#93">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a href="#impl-WithSubscriber-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; WithSubscriber for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a href="#method.with_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; WithDispatch&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Dispatch&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a href="#method.with_current_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_current_subscriber</a>(self) -&gt; WithDispatch&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="crate::dispatcher#setting-the-default-subscriber">default</a> <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details></div></details><section id="impl-ErasedDestructor-for-T" class="impl"><a href="#impl-ErasedDestructor-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; ErasedDestructor for T<div class="where">where
    T: 'static,</div></h3></section></div></section></div></main></body></html>