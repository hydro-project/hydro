<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="HTML template for ReactFlow visualization"><title>REACTFLOW_TEMPLATE in hydro_lang::graph::template - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="hydro_lang" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (9f32ccf35 2025-09-21)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-061df703.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">REACTFLOW_TEMPLATE</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../hydro_lang/index.html">hydro_<wbr>lang</a><span class="version">0.14.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In hydro_<wbr>lang::<wbr>graph::<wbr>template</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">hydro_lang</a>::<wbr><a href="../index.html">graph</a>::<wbr><a href="index.html">template</a></div><h1>Constant <span class="constant">REACTFLOW_<wbr>TEMPLATE</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/hydro_lang/graph/template.rs.html#2">Source</a> </span></div><pre class="rust item-decl"><code>pub const REACTFLOW_TEMPLATE: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = &quot;&lt;!DOCTYPE html&gt;\n&lt;html lang=\&quot;en\&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=\&quot;UTF-8\&quot;&gt;\n    &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1.0\&quot;&gt;\n    &lt;title&gt;Hydro IR Graph - ReactFlow.js&lt;/title&gt;\n    &lt;script crossorigin src=\&quot;https://unpkg.com/react@17/umd/react.production.min.js\&quot;&gt;&lt;/script&gt;\n    &lt;script crossorigin src=\&quot;https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\&quot;&gt;&lt;/script&gt;\n    &lt;script src=\&quot;https://unpkg.com/@babel/standalone/babel.min.js\&quot;&gt;&lt;/script&gt;\n    &lt;script src=\&quot;https://unpkg.com/reactflow@11.11.4/dist/umd/index.js\&quot;&gt;&lt;/script&gt;\n    &lt;script src=\&quot;https://unpkg.com/elkjs@0.8.2/lib/elk.bundled.js\&quot;&gt;&lt;/script&gt;\n    &lt;link rel=\&quot;stylesheet\&quot; href=\&quot;https://unpkg.com/reactflow@11.11.4/dist/style.css\&quot; /&gt;\n    &lt;style&gt;\n        body {\n            margin: 0;\n            padding: 0;\n            font-family: -apple-system, BlinkMacSystemFont, \&#39;Segoe UI\&#39;, \&#39;Roboto\&#39;, \&#39;Oxygen\&#39;,\n                \&#39;Ubuntu\&#39;, \&#39;Cantarell\&#39;, \&#39;Fira Sans\&#39;, \&#39;Droid Sans\&#39;, \&#39;Helvetica Neue\&#39;,\n                sans-serif;\n            -webkit-font-smoothing: antialiased;\n            -moz-osx-font-smoothing: grayscale;\n        }\n        .reactflow-wrapper {\n            width: 100vw;\n            height: 100vh;\n        }\n        /* Compact unified legend in upper right */\n        .unified-legend {\n            position: absolute;\n            top: 90px;\n            right: 10px;\n            z-index: 10;\n            background: rgba(255, 255, 255, 0.95);\n            backdrop-filter: blur(10px);\n            padding: 8px;\n            border-radius: 6px;\n            box-shadow: 0 2px 8px rgba(0,0,0,0.15);\n            max-width: 220px;\n            font-size: 11px;\n        }\n        /* Layout controls above legend */\n        .layout-controls {\n            position: absolute;\n            top: 40px;\n            right: 10px;\n            z-index: 10;\n            background: rgba(255, 255, 255, 0.95);\n            backdrop-filter: blur(10px);\n            border-radius: 6px;\n            box-shadow: 0 2px 8px rgba(0,0,0,0.15);\n            padding: 6px;\n            display: flex;\n            align-items: center;\n            gap: 4px;\n        }\n        .unified-legend h4 {\n            margin: 0 0 6px 0;\n            font-size: 12px;\n            font-weight: 600;\n            color: #333;\n            border-bottom: 1px solid #eee;\n            padding-bottom: 3px;\n        }\n        .legend-section {\n            margin-bottom: 8px;\n        }\n        .legend-section:last-child {\n            margin-bottom: 0;\n        }\n        .legend-item {\n            display: flex;\n            align-items: center;\n            margin: 3px 0;\n            font-size: 10px;\n        }\n        .legend-color {\n            width: 12px;\n            height: 12px;\n            border-radius: 2px;\n            margin-right: 6px;\n            border: 1px solid #666;\n            flex-shrink: 0;\n        }\n        .location-legend-color {\n            width: 16px;\n            height: 10px;\n            border-radius: 2px;\n            margin-right: 6px;\n            border: 1px solid;\n            flex-shrink: 0;\n        }\n        .icon-button {\n            width: 28px;\n            height: 28px;\n            border: none;\n            border-radius: 4px;\n            background: #f8f9fa;\n            cursor: pointer;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-size: 14px;\n            color: #495057;\n            transition: all 0.2s ease;\n            position: relative;\n        }\n        .icon-button:hover {\n            background: #e9ecef;\n            color: #212529;\n            transform: translateY(-1px);\n        }\n        .icon-button:active {\n            transform: translateY(0);\n        }\n        .layout-select, .palette-select {\n            background: #f8f9fa;\n            border: 1px solid #dee2e6;\n            border-radius: 4px;\n            font-size: 11px;\n            padding: 4px 6px;\n            width: 80px;\n            color: #495057;\n        }\n        .layout-select:hover, .palette-select:hover {\n            border-color: #adb5bd;\n        }\n        /* Tooltip styles */\n        .tooltip {\n            position: absolute;\n            bottom: 100%;\n            left: 50%;\n            transform: translateX(-50%);\n            background: #333;\n            color: white;\n            padding: 4px 8px;\n            border-radius: 4px;\n            font-size: 10px;\n            white-space: nowrap;\n            opacity: 0;\n            pointer-events: none;\n            transition: opacity 0.2s ease;\n            margin-bottom: 4px;\n        }\n        .tooltip::after {\n            content: \&#39;\&#39;;\n            position: absolute;\n            top: 100%;\n            left: 50%;\n            transform: translateX(-50%);\n            border: 4px solid transparent;\n            border-top-color: #333;\n        }\n        /* Special positioning for rightmost button tooltip to avoid cutoff */\n        .layout-controls .icon-button:last-child .tooltip {\n            left: auto;\n            right: 0;\n            transform: none;\n        }\n        .layout-controls .icon-button:last-child .tooltip::after {\n            left: auto;\n            right: 16px;\n            transform: none;\n        }\n        .icon-button:hover .tooltip {\n            opacity: 1;\n        }\n        .react-flow__node {\n            cursor: pointer;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n            transition: all 0.2s ease;\n        }\n        .react-flow__node:hover {\n            transform: scale(1.02);\n            box-shadow: 0 4px 8px rgba(0,0,0,0.15);\n        }\n        /* Container node specific styles */\n        .react-flow__node.container-node {\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            text-align: center;\n            font-size: 12px;\n            font-weight: 500;\n            color: #333;\n            overflow: hidden;\n            text-overflow: ellipsis;\n            white-space: nowrap;\n            padding: 4px 8px;\n            box-sizing: border-box;\n        }\n        /* Ensure container labels are readable when collapsed */\n        .react-flow__node.container-node .react-flow__node-default {\n            overflow: hidden;\n            text-overflow: ellipsis;\n            white-space: nowrap;\n            width: 100%;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\&quot;root\&quot;&gt;&lt;/div&gt;\n    &lt;script type=\&quot;text/babel\&quot;&gt;\n        // @ts-nocheck\n        // eslint-disable-next-line\n        const graphData = {{GRAPH_DATA}};\n        const { useState, useCallback, useRef, useEffect } = React;\n        // ReactFlow v11 components via reactflow\n        const ReactFlowLib = window.ReactFlow;\n        const { default: ReactFlow, Controls, MiniMap, Background, useNodesState, useEdgesState, addEdge, applyNodeChanges, applyEdgeChanges } = ReactFlowLib;\n        \n        // ColorBrewer palettes - expanded collection with various aesthetics\n        const colorPalettes = {\n            // Qualitative palettes (great for categorical data)\n            \&#39;Set3\&#39;: [\&#39;#8dd3c7\&#39;, \&#39;#ffffb3\&#39;, \&#39;#bebada\&#39;, \&#39;#fb8072\&#39;, \&#39;#80b1d3\&#39;, \&#39;#fdb462\&#39;, \&#39;#b3de69\&#39;],\n            \&#39;Pastel1\&#39;: [\&#39;#fbb4ae\&#39;, \&#39;#b3cde3\&#39;, \&#39;#ccebc5\&#39;, \&#39;#decbe4\&#39;, \&#39;#fed9a6\&#39;, \&#39;#ffffcc\&#39;, \&#39;#e5d8bd\&#39;],\n            \&#39;Pastel2\&#39;: [\&#39;#b3e2cd\&#39;, \&#39;#fdcdac\&#39;, \&#39;#cbd5e8\&#39;, \&#39;#f4cae4\&#39;, \&#39;#e6f5c9\&#39;, \&#39;#fff2ae\&#39;, \&#39;#f1e2cc\&#39;],\n            \&#39;Set1\&#39;: [\&#39;#e41a1c\&#39;, \&#39;#377eb8\&#39;, \&#39;#4daf4a\&#39;, \&#39;#984ea3\&#39;, \&#39;#ff7f00\&#39;, \&#39;#ffff33\&#39;, \&#39;#a65628\&#39;],\n            \&#39;Set2\&#39;: [\&#39;#66c2a5\&#39;, \&#39;#fc8d62\&#39;, \&#39;#8da0cb\&#39;, \&#39;#e78ac3\&#39;, \&#39;#a6d854\&#39;, \&#39;#ffd92f\&#39;, \&#39;#e5c494\&#39;],\n            \&#39;Dark2\&#39;: [\&#39;#1b9e77\&#39;, \&#39;#d95f02\&#39;, \&#39;#7570b3\&#39;, \&#39;#e7298a\&#39;, \&#39;#66a61e\&#39;, \&#39;#e6ab02\&#39;, \&#39;#a6761d\&#39;],\n            \&#39;Accent\&#39;: [\&#39;#7fc97f\&#39;, \&#39;#beaed4\&#39;, \&#39;#fdc086\&#39;, \&#39;#ffff99\&#39;, \&#39;#386cb0\&#39;, \&#39;#f0027f\&#39;, \&#39;#bf5b17\&#39;],\n            \&#39;Paired\&#39;: [\&#39;#a6cee3\&#39;, \&#39;#1f78b4\&#39;, \&#39;#b2df8a\&#39;, \&#39;#33a02c\&#39;, \&#39;#fb9a99\&#39;, \&#39;#e31a1c\&#39;, \&#39;#fdbf6f\&#39;],\n            \n            // Sequential palettes (good for intensity/hierarchy)\n            \&#39;Blues\&#39;: [\&#39;#f7fbff\&#39;, \&#39;#deebf7\&#39;, \&#39;#c6dbef\&#39;, \&#39;#9ecae1\&#39;, \&#39;#6baed6\&#39;, \&#39;#4292c6\&#39;, \&#39;#2171b5\&#39;],\n            \&#39;Greens\&#39;: [\&#39;#f7fcf5\&#39;, \&#39;#e5f5e0\&#39;, \&#39;#c7e9c0\&#39;, \&#39;#a1d99b\&#39;, \&#39;#74c476\&#39;, \&#39;#41ab5d\&#39;, \&#39;#238b45\&#39;],\n            \&#39;Oranges\&#39;: [\&#39;#fff5eb\&#39;, \&#39;#fee6ce\&#39;, \&#39;#fdd0a2\&#39;, \&#39;#fdae6b\&#39;, \&#39;#fd8d3c\&#39;, \&#39;#f16913\&#39;, \&#39;#d94801\&#39;],\n            \&#39;Purples\&#39;: [\&#39;#fcfbfd\&#39;, \&#39;#efedf5\&#39;, \&#39;#dadaeb\&#39;, \&#39;#bcbddc\&#39;, \&#39;#9e9ac8\&#39;, \&#39;#807dba\&#39;, \&#39;#6a51a3\&#39;],\n            \&#39;Reds\&#39;: [\&#39;#fff5f0\&#39;, \&#39;#fee0d2\&#39;, \&#39;#fcbba1\&#39;, \&#39;#fc9272\&#39;, \&#39;#fb6a4a\&#39;, \&#39;#ef3b2c\&#39;, \&#39;#cb181d\&#39;],\n            \n            // Diverging palettes (great for showing contrasts)\n            \&#39;Spectral\&#39;: [\&#39;#9e0142\&#39;, \&#39;#d53e4f\&#39;, \&#39;#f46d43\&#39;, \&#39;#fdae61\&#39;, \&#39;#fee08b\&#39;, \&#39;#e6f598\&#39;, \&#39;#abdda4\&#39;],\n            \&#39;RdYlBu\&#39;: [\&#39;#d73027\&#39;, \&#39;#f46d43\&#39;, \&#39;#fdae61\&#39;, \&#39;#fee090\&#39;, \&#39;#e0f3f8\&#39;, \&#39;#abd9e9\&#39;, \&#39;#74add1\&#39;],\n            \&#39;RdYlGn\&#39;: [\&#39;#d73027\&#39;, \&#39;#f46d43\&#39;, \&#39;#fdae61\&#39;, \&#39;#fee08b\&#39;, \&#39;#d9ef8b\&#39;, \&#39;#a6d96a\&#39;, \&#39;#66bd63\&#39;],\n            \&#39;PiYG\&#39;: [\&#39;#d01c8b\&#39;, \&#39;#f1b6da\&#39;, \&#39;#fde0ef\&#39;, \&#39;#f7f7f7\&#39;, \&#39;#e6f5d0\&#39;, \&#39;#b8e186\&#39;, \&#39;#4d9221\&#39;],\n            \&#39;BrBG\&#39;: [\&#39;#8c510a\&#39;, \&#39;#bf812d\&#39;, \&#39;#dfc27d\&#39;, \&#39;#f6e8c3\&#39;, \&#39;#c7eae5\&#39;, \&#39;#80cdc1\&#39;, \&#39;#35978f\&#39;],\n            \n            // Modern/trendy palettes\n            \&#39;Viridis\&#39;: [\&#39;#440154\&#39;, \&#39;#482777\&#39;, \&#39;#3f4a8a\&#39;, \&#39;#31678e\&#39;, \&#39;#26838f\&#39;, \&#39;#1f9d8a\&#39;, \&#39;#6cce5a\&#39;],\n            \&#39;Plasma\&#39;: [\&#39;#0d0887\&#39;, \&#39;#6a00a8\&#39;, \&#39;#b12a90\&#39;, \&#39;#e16462\&#39;, \&#39;#fca636\&#39;, \&#39;#f0f921\&#39;, \&#39;#fcffa4\&#39;],\n            \&#39;Warm\&#39;: [\&#39;#375a7f\&#39;, \&#39;#5bc0de\&#39;, \&#39;#5cb85c\&#39;, \&#39;#f0ad4e\&#39;, \&#39;#d9534f\&#39;, \&#39;#ad4e92\&#39;, \&#39;#6f5499\&#39;],\n            \&#39;Cool\&#39;: [\&#39;#2c3e50\&#39;, \&#39;#3498db\&#39;, \&#39;#1abc9c\&#39;, \&#39;#16a085\&#39;, \&#39;#27ae60\&#39;, \&#39;#2980b9\&#39;, \&#39;#8e44ad\&#39;],\n            \&#39;Earth\&#39;: [\&#39;#8b4513\&#39;, \&#39;#a0522d\&#39;, \&#39;#cd853f\&#39;, \&#39;#daa520\&#39;, \&#39;#b8860b\&#39;, \&#39;#228b22\&#39;, \&#39;#006400\&#39;]\n        };\n        \n        // Remove sourcePosition/targetPosition from nodes for flexible edge attachment\n        const initialNodes = (graphData.nodes || []).map(node =&gt; {\n            const { sourcePosition, targetPosition, ...rest } = node;\n            return rest;\n        });\n        const initialEdges = (graphData.edges || []).map(edge =&gt; {\n            // Use \&#39;bezier\&#39; edge type for flexible routing to all sides of nodes (left, right, top, bottom)\n            const processedEdge = {\n                id: edge.id,\n                source: edge.source,\n                target: edge.target,\n                type: \&#39;bezier\&#39;,\n                zIndex: 1000,\n                markerEnd: {\n                    type: \&#39;arrowclosed\&#39;,\n                    width: 20,\n                    height: 20,\n                    color: edge.style?.stroke || \&#39;#666666\&#39;\n                },\n                style: {\n                    strokeWidth: edge.style?.strokeWidth || 2,\n                    stroke: edge.style?.stroke || \&#39;#666666\&#39;,\n                    strokeDasharray: edge.style?.strokeDasharray\n                },\n                animated: edge.animated || false,\n                interactionWidth: 20\n            };\n            if (edge.label) processedEdge.label = edge.label;\n            if (edge.labelStyle) processedEdge.labelStyle = edge.labelStyle;\n            if (edge.labelShowBg) processedEdge.labelShowBg = edge.labelShowBg;\n            if (edge.labelBgStyle) processedEdge.labelBgStyle = edge.labelBgStyle;\n            return processedEdge;\n        });\n\n        // elk.js layout configuration with hierarchical support\n        const elkLayouts = {\n            layered: {\n                \&#39;elk.algorithm\&#39;: \&#39;layered\&#39;,\n                \&#39;elk.layered.spacing.nodeNodeBetweenLayers\&#39;: 150,\n                \&#39;elk.spacing.nodeNode\&#39;: 120,\n                \&#39;elk.spacing.componentComponent\&#39;: 80,\n                \&#39;elk.direction\&#39;: \&#39;RIGHT\&#39;,\n                \&#39;elk.layered.thoroughness\&#39;: 7,\n                \&#39;elk.hierarchyHandling\&#39;: \&#39;SEPARATE_CHILDREN\&#39;\n            },\n            force: {\n                \&#39;elk.algorithm\&#39;: \&#39;force\&#39;,\n                \&#39;elk.force.repulsivePower\&#39;: 0.5,\n                \&#39;elk.spacing.nodeNode\&#39;: 150,\n                \&#39;elk.spacing.componentComponent\&#39;: 100,\n                \&#39;elk.hierarchyHandling\&#39;: \&#39;SEPARATE_CHILDREN\&#39;\n            },\n            stress: {\n                \&#39;elk.algorithm\&#39;: \&#39;stress\&#39;,\n                \&#39;elk.stress.desiredEdgeLength\&#39;: 150,\n                \&#39;elk.spacing.nodeNode\&#39;: 120,\n                \&#39;elk.spacing.componentComponent\&#39;: 80,\n                \&#39;elk.hierarchyHandling\&#39;: \&#39;SEPARATE_CHILDREN\&#39;\n            },\n            mrtree: {\n                \&#39;elk.algorithm\&#39;: \&#39;mrtree\&#39;,\n                \&#39;elk.mrtree.searchOrder\&#39;: \&#39;DFS\&#39;,\n                \&#39;elk.spacing.nodeNode\&#39;: 120,\n                \&#39;elk.spacing.componentComponent\&#39;: 80,\n                \&#39;elk.hierarchyHandling\&#39;: \&#39;SEPARATE_CHILDREN\&#39;\n            },\n            radial: {\n                \&#39;elk.algorithm\&#39;: \&#39;radial\&#39;,\n                \&#39;elk.radial.radius\&#39;: 250,\n                \&#39;elk.spacing.nodeNode\&#39;: 120,\n                \&#39;elk.spacing.componentComponent\&#39;: 80,\n                \&#39;elk.hierarchyHandling\&#39;: \&#39;SEPARATE_CHILDREN\&#39;\n            },\n            disco: {\n                \&#39;elk.algorithm\&#39;: \&#39;disco\&#39;,\n                \&#39;elk.disco.componentCompaction.strategy\&#39;: \&#39;POLYOMINO\&#39;,\n                \&#39;elk.spacing.nodeNode\&#39;: 80,\n                \&#39;elk.hierarchyHandling\&#39;: \&#39;INCLUDE_CHILDREN\&#39;\n            }\n        };\n\n        // Generate colors based on selected palette\n        const generateNodeColors = (nodeType, palette = \&#39;Set3\&#39;) =&gt; {\n            const colors = colorPalettes[palette];\n            const typeMap = {\n                \&#39;Source\&#39;: 0,\n                \&#39;Transform\&#39;: 1,\n                \&#39;Join\&#39;: 2,\n                \&#39;Aggregation\&#39;: 3,\n                \&#39;Network\&#39;: 4,\n                \&#39;Sink\&#39;: 5,\n                \&#39;Tee\&#39;: 6\n            };\n            \n            const baseColor = colors[typeMap[nodeType] || 0];\n            \n            // Create gradient colors\n            const primary = baseColor;\n            const secondary = lightenColor(baseColor, 10);\n            const tertiary = lightenColor(baseColor, 25);\n            const border = darkenColor(baseColor, 5);\n            \n            // Create a gentle linear gradient\n            const gradient = `linear-gradient(0deg, ${tertiary} 0%, ${secondary} 80%, ${primary} 100%)`;\n            \n            return { primary, secondary, tertiary, border, gradient };\n        };\n        \n        // Simplified color manipulation using CSS color-mix\n        const lightenColor = (color, percent) =&gt; `color-mix(in srgb, ${color} ${100-percent}%, white)`;\n        const darkenColor = (color, percent) =&gt; `color-mix(in srgb, ${color} ${100-percent}%, black)`;\n\n        // Helper function to truncate long labels for collapsed containers\n        const leftTruncateRustPath = (label, isCollapsed) =&gt; {\n            if (!isCollapsed) return label;\n            if (!label || typeof label !== \&#39;string\&#39;) return \&#39;Unknown\&#39;;\n            \n            // For collapsed containers, we have about 180px width (200px - padding)\n            // Assuming average character width of ~8px, we can fit about 22 characters\n            let maxLength = 22;\n            \n            if (label.length &lt;= maxLength) return label;\n            \n            // If it contains \&quot;::\&quot; separators, left-truncate with ellipses on the left\n            if (label.includes(\&#39;::\&#39;)) {\n                const segments = label.split(\&#39;::\&#39;);\n                const lastComponent = segments[segments.length - 1];\n                \n                // Always show at least \&quot;...::lastComponent\&quot;\n                const minTruncated = \&#39;...\&#39; + \&#39;::\&#39; + lastComponent;\n                \n                // If the minimum required format is longer than our standard width,\n                // we\&#39;ll need a wider container - return the minimum format\n                if (minTruncated.length &gt; maxLength) {\n                    return minTruncated;\n                }\n                \n                // Try to include more segments while keeping ellipses on the left\n                let truncated = lastComponent;\n                for (let i = segments.length - 2; i &gt;= 0; i--) {\n                    const withNext = segments[i] + \&#39;::\&#39; + truncated;\n                    const withEllipsis = \&#39;...\&#39; + \&#39;::\&#39; + truncated;\n                    \n                    if (withNext.length &lt;= maxLength) {\n                        // Can fit without ellipses\n                        truncated = withNext;\n                    } else if (withEllipsis.length &lt;= maxLength) {\n                        // Need ellipses but it fits\n                        truncated = withEllipsis;\n                        break;\n                    } else {\n                        // Even with ellipses it doesn\&#39;t fit, use previous iteration result\n                        truncated = \&#39;...\&#39; + \&#39;::\&#39; + truncated;\n                        break;\n                    }\n                }\n                \n                return truncated;\n            } else {\n                // No \&quot;::\&quot; separators, just truncate from the left with ellipses\n                return \&#39;...\&#39; + label.slice(-(maxLength - 3));\n            }\n        };\n\n        // Helper function to calculate minimum width needed for a collapsed container\n        const getMinCollapsedWidth = (label) =&gt; {\n            if (!label || typeof label !== \&#39;string\&#39;) label = \&#39;Unknown\&#39;;\n            const truncated = leftTruncateRustPath(label, true);\n            // Assuming 8px per character + 16px padding\n            const minWidth = Math.max(200, truncated.length * 8 + 16);\n            return minWidth;\n        };\n\n\n\n        // Simplified location color generation\n        const generateLocationColor = (locationId, totalLocations, palette = \&#39;Set3\&#39;) =&gt; {\n            const colors = colorPalettes[palette];\n            const color = colors[locationId % colors.length];\n            return `${color}40`; // Add transparency\n        };\n\n        const generateLocationBorderColor = (locationId, totalLocations, palette = \&#39;Set3\&#39;) =&gt; {\n            const colors = colorPalettes[palette];\n            return colors[locationId % colors.length];\n        };\n\n        const elk = new ELK();\n\n        // Helper function to generate hyperedges between containers\n        const generateHyperedges = (nodes, edges) =&gt; {\n            const hyperedges = [];\n            const containerPairs = new Set();\n            \n            // Find all edges that cross container boundaries\n            edges.forEach(edge =&gt; {\n                const sourceNode = nodes.find(n =&gt; n.id === edge.source);\n                const targetNode = nodes.find(n =&gt; n.id === edge.target);\n                \n                if (sourceNode &amp;&amp; targetNode) {\n                    const sourceLocationId = sourceNode.data?.locationId;\n                    const targetLocationId = targetNode.data?.locationId;\n                    \n                    // Only create hyperedges between different locations (containers)\n                    if (sourceLocationId !== undefined &amp;&amp; targetLocationId !== undefined &amp;&amp; \n                        sourceLocationId !== targetLocationId) {\n                        \n                        const sourceContainerId = `container_${sourceLocationId}`;\n                        const targetContainerId = `container_${targetLocationId}`;\n                        const pairKey = `${sourceContainerId}-&gt;${targetContainerId}`;\n                        \n                        // Avoid duplicate hyperedges between the same container pair\n                        if (!containerPairs.has(pairKey)) {\n                            containerPairs.add(pairKey);\n                            hyperedges.push({\n                                id: `hyperedge_${sourceLocationId}_to_${targetLocationId}`,\n                                sources: [sourceContainerId],\n                                targets: [targetContainerId],\n                            });\n                        }\n                    }\n                }\n            });\n            \n            return hyperedges;\n        };\n\n        // Shared edge routing logic for collapsed containers\n        const routeEdgesForCollapsedContainers = (edges, collapsedLocations, childNodeIdsByParent) =&gt; {\n            return edges.map(edge =&gt; {\n                let newEdge = { ...edge };\n                \n                // Reset any previous modifications\n                if (newEdge.data?.originalSource) {\n                    newEdge.source = newEdge.data.originalSource;\n                    newEdge.data = { ...newEdge.data };\n                    delete newEdge.data.originalSource;\n                }\n                if (newEdge.data?.originalTarget) {\n                    newEdge.target = newEdge.data.originalTarget;\n                    newEdge.data = { ...newEdge.data };\n                    delete newEdge.data.originalTarget;\n                }\n                newEdge.hidden = false;\n\n                // Find collapsed containers containing source/target\n                let sourceInCollapsedContainer = null;\n                let targetInCollapsedContainer = null;\n                \n                for (const locationId in collapsedLocations) {\n                    if (collapsedLocations[locationId]) {\n                        const containerId = `container_${locationId}`;\n                        const childIds = childNodeIdsByParent[containerId] || new Set();\n\n                        if (childIds.has(newEdge.source)) {\n                            sourceInCollapsedContainer = containerId;\n                        }\n                        if (childIds.has(newEdge.target)) {\n                            targetInCollapsedContainer = containerId;\n                        }\n                    }\n                }\n                \n                // Apply routing based on container states\n                if (sourceInCollapsedContainer &amp;&amp; targetInCollapsedContainer) {\n                    if (sourceInCollapsedContainer === targetInCollapsedContainer) {\n                        newEdge.hidden = true; // Hide internal edges\n                    } else {\n                        // Route container to container\n                        newEdge.data = { ...newEdge.data, originalSource: newEdge.source, originalTarget: newEdge.target };\n                        newEdge.source = sourceInCollapsedContainer;\n                        newEdge.target = targetInCollapsedContainer;\n                    }\n                } else if (sourceInCollapsedContainer) {\n                    newEdge.data = { ...newEdge.data, originalSource: newEdge.source };\n                    newEdge.source = sourceInCollapsedContainer;\n                } else if (targetInCollapsedContainer) {\n                    newEdge.data = { ...newEdge.data, originalTarget: newEdge.target };\n                    newEdge.target = targetInCollapsedContainer;\n                }\n                \n                return newEdge;\n            });\n        };\n\n        // Function to apply ELK layout with hierarchical grouping and hyperedges\n        const applyElkLayout = async (nodes, edges, layoutType = \&#39;layered\&#39;, precomputedHyperedges = []) =&gt; {\n            const elkOptions = elkLayouts[layoutType] || elkLayouts.layered;\n            \n            // Group nodes by location first\n            const locationGroups = new Map();\n            const orphanNodes = [];\n            \n            nodes.forEach(node =&gt; {\n                const nodeLocationId = node.data?.locationId;\n                if (nodeLocationId !== null &amp;&amp; nodeLocationId !== undefined) {\n                    if (!locationGroups.has(nodeLocationId)) {\n                        locationGroups.set(nodeLocationId, []);\n                    }\n                    locationGroups.get(nodeLocationId).push(node);\n                } else {\n                    orphanNodes.push(node);\n                }\n            });\n            \n            // Create hierarchical ELK structure with proper container spacing\n            const elkChildren = [];\n            \n            // Process each location as a separate container\n            for (const [locationId, locationNodes] of locationGroups) {\n                const elkNodes = locationNodes.map(node =&gt; {\n                    const actualNode = nodes.find(n =&gt; n.id === node.id);\n                    const nodeWidth = actualNode?.style?.width ? \n                        parseFloat(actualNode.style.width.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) : 200;\n                    const nodeHeight = actualNode?.style?.height ? \n                        parseFloat(actualNode.style.height.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) : 60;\n                        \n                    return {\n                        id: node.id,\n                        width: nodeWidth,\n                        height: nodeHeight,\n                    };\n                });\n\n                const elkEdgesInLocation = edges.filter(edge =&gt; {\n                    const sourceInLocation = locationNodes.some(n =&gt; n.id === edge.source);\n                    const targetInLocation = locationNodes.some(n =&gt; n.id === edge.target);\n                    return sourceInLocation &amp;&amp; targetInLocation;\n                }).map(edge =&gt; ({\n                    id: edge.id,\n                    sources: [edge.source],\n                    targets: [edge.target],\n                }));\n\n                // Use default container dimensions for ELK layout\n                const containerWidth = 400;\n                const containerHeight = 300;\n\n                elkChildren.push({\n                    id: `container_${locationId}`,\n                    width: containerWidth,\n                    height: containerHeight,\n                    layoutOptions: {\n                        ...elkOptions,\n                        \&#39;elk.padding\&#39;: \&#39;[top=40,left=20,bottom=20,right=20]\&#39;,\n                        \&#39;elk.spacing.nodeNode\&#39;: 60,\n                    },\n                    children: elkNodes,\n                    edges: elkEdgesInLocation,\n                });\n            }\n            \n            // Add orphan nodes as top-level nodes with actual dimensions\n            orphanNodes.forEach(node =&gt; {\n                const actualNode = nodes.find(n =&gt; n.id === node.id);\n                const nodeWidth = actualNode?.style?.width ? \n                    parseFloat(actualNode.style.width.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) : 200;\n                const nodeHeight = actualNode?.style?.height ? \n                    parseFloat(actualNode.style.height.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) : 60;\n                    \n                elkChildren.push({\n                    id: node.id,\n                    width: nodeWidth,\n                    height: nodeHeight,\n                });\n            });\n\n            // Use precomputed hyperedges if available, otherwise generate them\n            const hyperedges = precomputedHyperedges.length &gt; 0 ? precomputedHyperedges : generateHyperedges(nodes, edges);\n            \n            const elkGraph = {\n                id: \&#39;root\&#39;,\n                layoutOptions: {\n                    ...elkOptions,\n                    \&#39;elk.spacing.nodeNode\&#39;: 150,\n                    \&#39;elk.spacing.componentComponent\&#39;: 100,\n                    \&#39;elk.layered.spacing.nodeNodeBetweenLayers\&#39;: 150,\n                },\n                children: elkChildren,\n                edges: hyperedges, // Use hyperedges for container layout\n            };\n\n            try {\n                const layoutedGraph = await elk.layout(elkGraph);\n                \n                // Apply positions from ELK layout\n                const layoutedNodes = nodes.map((node) =&gt; {\n                    // Find the node in the layout result\n                    let elkNode = null;\n                    let containerOffset = { x: 0, y: 0 };\n                    \n                    // Look for the node in containers first\n                    for (const container of layoutedGraph.children || []) {\n                        if (container.children) {\n                            const foundNode = container.children.find(n =&gt; n.id === node.id);\n                            if (foundNode) {\n                                elkNode = foundNode;\n                                containerOffset = { x: container.x || 0, y: container.y || 0 };\n                                break;\n                            }\n                        }\n                    }\n                    \n                    // If not found in containers, look at top level\n                    if (!elkNode) {\n                        elkNode = layoutedGraph.children?.find(n =&gt; n.id === node.id);\n                    }\n                    \n                    return {\n                        ...node,\n                        position: {\n                            x: elkNode ? (elkNode.x || 0) + containerOffset.x : Math.random() * 500,\n                            y: elkNode ? (elkNode.y || 0) + containerOffset.y : Math.random() * 500,\n                        },\n                    };\n                });\n\n                return layoutedNodes;\n            } catch (error) {\n                console.error(\&#39;ELK layout failed:\&#39;, error);\n                return nodes; // Fallback to original positions\n            }\n        };\n\n        // Helper function to create a container for a location\n        const createLocationContainer = (location, locationNodes, currentPalette) =&gt; {\n            // Calculate actual bounds based on real node dimensions\n            const bounds = locationNodes.reduce((acc, node) =&gt; {\n                // Get actual node dimensions from style or use defaults\n                const nodeWidth = node.style?.width ? \n                    parseFloat(node.style.width.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) : 200;\n                const nodeHeight = node.style?.height ? \n                    parseFloat(node.style.height.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) : 60;\n                \n                const nodeRight = node.position.x + nodeWidth;\n                const nodeBottom = node.position.y + nodeHeight;\n                \n                return {\n                    minX: Math.min(acc.minX, node.position.x),\n                    minY: Math.min(acc.minY, node.position.y),\n                    maxX: Math.max(acc.maxX, nodeRight),\n                    maxY: Math.max(acc.maxY, nodeBottom)\n                };\n            }, {\n                minX: locationNodes[0]?.position.x || 0,\n                minY: locationNodes[0]?.position.y || 0,\n                maxX: locationNodes[0]?.position.x || 0,\n                maxY: locationNodes[0]?.position.y || 0\n            });\n            \n            const padding = 30;\n            const containerX = bounds.minX - padding;\n            const containerY = bounds.minY - padding - 30; // Extra space for label\n            \n            const backgroundColor = generateLocationColor(location.id, 1, currentPalette);\n            const borderColor = generateLocationBorderColor(location.id, 1, currentPalette);\n            \n            return {\n                id: `container_${location.id}`,\n                type: \&#39;default\&#39;,\n                position: { x: containerX, y: containerY },\n                className: \&#39;container-node\&#39;,\n                style: {\n                    width: bounds.maxX - bounds.minX + 2 * padding,\n                    height: bounds.maxY - bounds.minY + 2 * padding + 30, // Extra 30px for label\n                    backgroundColor: backgroundColor,\n                    border: `2px solid ${borderColor}`,\n                    borderRadius: \&#39;8px\&#39;,\n                    cursor: \&#39;pointer\&#39;,\n                    zIndex: 1,\n                },\n                data: { \n                    label: location.label,\n                    isContainer: true\n                },\n                draggable: true,\n            };\n        };\n\n        // Helper function to create child nodes for a container\n        const createChildNodes = (locationNodes, containerId, containerPosition) =&gt; {\n            return locationNodes.map(node =&gt; ({\n                ...node,\n                parentNode: containerId,\n                extent: \&#39;parent\&#39;,\n                position: {\n                    x: node.position.x - containerPosition.x,\n                    y: node.position.y - containerPosition.y\n                }\n            }));\n        };\n\n        // STEP 2: Smart container layout using ELK with position preservation and hyperedges\n        const layoutContainersWithELK = async (containerNodes, allNodes, allEdges, changedContainerId = null, precomputedHyperedges = []) =&gt; {\n            if (containerNodes.length === 0) return containerNodes;\n            \n            // Use precomputed hyperedges if available, otherwise generate them\n            const hyperedges = precomputedHyperedges.length &gt; 0 ? precomputedHyperedges : generateHyperedges(allNodes, allEdges);\n            \n            // Prepare ELK layout for containers only\n            const elkContainers = containerNodes.map(container =&gt; {\n                const width = parseFloat(container.style?.width?.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 400;\n                const height = parseFloat(container.style?.height?.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 300;\n                \n                const elkContainer = {\n                    id: container.id,\n                    width: width,\n                    height: height,\n                };\n                \n                // If this container hasn\&#39;t changed, COMPLETELY FIX its position\n                if (changedContainerId &amp;&amp; container.id !== changedContainerId) {\n                    elkContainer.x = container.position.x;\n                    elkContainer.y = container.position.y;\n                    // Use ELK\&#39;s position fixing to completely lock this container in place\n                    elkContainer.layoutOptions = {\n                        \&#39;elk.position.x\&#39;: container.position.x.toString(),\n                        \&#39;elk.position.y\&#39;: container.position.y.toString(),\n                        \&#39;elk.nodeSize.constraints\&#39;: \&#39;FIXED_POS\&#39;, // This fixes the position completely\n                        \&#39;elk.nodeSize.options\&#39;: \&#39;FIXED_POS\&#39;\n                    };\n                } else {\n                    // For the changed container, allow ELK to position it freely\n                    elkContainer.layoutOptions = {\n                        \&#39;elk.nodeSize.constraints\&#39;: \&#39;\&#39;,\n                        \&#39;elk.nodeSize.options\&#39;: \&#39;\&#39;\n                    };\n                }\n                \n                return elkContainer;\n            });\n            \n            // Create a simple ELK graph for container layout with hyperedges\n            const elkGraph = {\n                id: \&#39;container_root\&#39;,\n                layoutOptions: {\n                    \&#39;elk.algorithm\&#39;: \&#39;org.eclipse.elk.layered\&#39;, // Use layered for better hyperedge handling\n                    \&#39;elk.direction\&#39;: \&#39;RIGHT\&#39;,\n                    \&#39;elk.spacing.nodeNode\&#39;: 100,\n                    \&#39;elk.spacing.componentComponent\&#39;: 100,\n                    \&#39;elk.layered.spacing.nodeNodeBetweenLayers\&#39;: 150,\n                    // More iterations for the changed container to find a good position\n                    \&#39;elk.layered.thoroughness\&#39;: changedContainerId ? 10 : 5,\n                    // Respect fixed positions\n                    \&#39;elk.partitioning.activate\&#39;: \&#39;false\&#39;\n                },\n                children: elkContainers,\n                edges: hyperedges // Use hyperedges for better container layout\n            };\n            \n            try {\n                const layoutedGraph = await elk.layout(elkGraph);\n                \n                // Apply the new positions back to containers\n                return containerNodes.map(container =&gt; {\n                    const elkContainer = layoutedGraph.children?.find(c =&gt; c.id === container.id);\n                    if (elkContainer) {\n                        // Only update position if this was the changed container OR if no specific container was changed\n                        if (!changedContainerId || container.id === changedContainerId) {\n                            return {\n                                ...container,\n                                position: {\n                                    x: elkContainer.x || container.position.x,\n                                    y: elkContainer.y || container.position.y\n                                }\n                            };\n                        } else {\n                            // Keep the original position for unchanged containers\n                            return container;\n                        }\n                    }\n                    return container;\n                });\n            } catch (error) {\n                console.error(\&#39;Container layout with ELK failed:\&#39;, error);\n                return containerNodes; // Fallback to original positions\n            }\n        };\n\n\n        // Helper function to determine if graph should be auto-collapsed\n        const shouldAutoCollapse = (locationContainers) =&gt; {\n            if (locationContainers.length === 0) return false;\n            \n            const minLegibleZoom = 0.5;\n            const graphWidth = Math.max(...locationContainers.map(c =&gt; c.position.x + parseFloat(c.style.width.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 400)) - \n                             Math.min(...locationContainers.map(c =&gt; c.position.x));\n            const graphHeight = Math.max(...locationContainers.map(c =&gt; c.position.y + parseFloat(c.style.height.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 300)) - \n                              Math.min(...locationContainers.map(c =&gt; c.position.y));\n                              \n            const wouldBeZoomX = (window.innerWidth * 0.85) / graphWidth;\n            const wouldBeZoomY = (window.innerHeight * 0.85) / graphHeight;\n            const wouldBeZoom = Math.min(wouldBeZoomX, wouldBeZoomY);\n            \n            return wouldBeZoom &lt; minLegibleZoom;\n        };\n\n        // Greedy expansion algorithm for small graphs\n        const determineInitialContainerStates = (allContainers, locationNodes) =&gt; {\n            const minLegibleZoom = 0.4; // Relaxed threshold to allow more expansion\n            const viewWidth = window.innerWidth * 0.85;\n            const viewHeight = window.innerHeight * 0.85;\n            \n            // Create container info with areas for sorting\n            const containerInfo = allContainers.map(container =&gt; {\n                const locationId = container.id.replace(\&#39;container_\&#39;, \&#39;\&#39;);\n                const nodes = locationNodes[locationId] || [];\n                \n                // Calculate area based on number of nodes and their layout\n                const nodeCount = nodes.length;\n                const estimatedArea = nodeCount * 200 * 60; // rough node area estimate\n                \n                const expandedWidth = parseFloat(container.style.width.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 400;\n                const expandedHeight = parseFloat(container.style.height.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 300;\n                \n                return {\n                    container,\n                    locationId,\n                    nodeCount,\n                    estimatedArea,\n                    expandedWidth,\n                    expandedHeight,\n                    collapsedWidth: getMinCollapsedWidth(container.data.label),\n                    collapsedHeight: 50\n                };\n            });\n            \n            // Sort by area (smallest first for greedy expansion)\n            containerInfo.sort((a, b) =&gt; a.estimatedArea - b.estimatedArea);\n            \n            const finalStates = {};\n            const expandedContainers = [];\n            \n            // Greedy expansion algorithm\n            for (const info of containerInfo) {\n                // Create a test scenario where this container is expanded\n                const testContainers = allContainers.map(c =&gt; {\n                    const cInfo = containerInfo.find(ci =&gt; ci.container.id === c.id);\n                    const isExpanded = expandedContainers.includes(cInfo.locationId) || \n                                     cInfo.locationId === info.locationId;\n                    \n                    return {\n                        ...c,\n                        style: {\n                            ...c.style,\n                            width: isExpanded ? cInfo.expandedWidth : cInfo.collapsedWidth,\n                            height: isExpanded ? cInfo.expandedHeight : cInfo.collapsedHeight\n                        }\n                    };\n                });\n                \n                // Calculate bounds with this expansion\n                const bounds = testContainers.reduce((acc, c) =&gt; {\n                    const width = parseFloat(c.style.width.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 400;\n                    const height = parseFloat(c.style.height.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 300;\n                    const right = c.position.x + width;\n                    const bottom = c.position.y + height;\n                    \n                    return {\n                        minX: Math.min(acc.minX, c.position.x),\n                        minY: Math.min(acc.minY, c.position.y),\n                        maxX: Math.max(acc.maxX, right),\n                        maxY: Math.max(acc.maxY, bottom)\n                    };\n                }, {\n                    minX: testContainers[0]?.position.x || 0,\n                    minY: testContainers[0]?.position.y || 0,\n                    maxX: testContainers[0]?.position.x || 0,\n                    maxY: testContainers[0]?.position.y || 0\n                });\n                \n                const graphWidth = bounds.maxX - bounds.minX;\n                const graphHeight = bounds.maxY - bounds.minY;\n                \n                const wouldBeZoomX = viewWidth / graphWidth;\n                const wouldBeZoomY = viewHeight / graphHeight;\n                const wouldBeZoom = Math.min(wouldBeZoomX, wouldBeZoomY);\n                \n                if (wouldBeZoom &gt;= minLegibleZoom) {\n                    // Safe to expand this container\n                    expandedContainers.push(info.locationId);\n                    finalStates[info.locationId] = false; // false = expanded\n                } else {\n                    // Would make zoom too small, keep collapsed\n                    finalStates[info.locationId] = true; // true = collapsed\n                }\n            }\n            \n            return finalStates;\n        };\n\n        function UnifiedLegend({ palette }) {\n            const nodeTypes = [\&#39;Source\&#39;, \&#39;Transform\&#39;, \&#39;Join\&#39;, \&#39;Aggregation\&#39;, \&#39;Network\&#39;, \&#39;Sink\&#39;, \&#39;Tee\&#39;];\n            const locations = graphData.locations || [];\n\n            return (\n                &lt;div className=\&quot;unified-legend\&quot;&gt;\n                    &lt;div className=\&quot;legend-section\&quot;&gt;\n                        &lt;h4&gt;Node Types&lt;/h4&gt;\n                        {nodeTypes.map(type =&gt; {\n                            const colors = generateNodeColors(type, palette);\n                            return (\n                                &lt;div key={type} className=\&quot;legend-item\&quot;&gt;\n                                    &lt;div className=\&quot;legend-color\&quot; style={{ background: colors.gradient, borderColor: colors.border }}&gt;&lt;/div&gt;\n                                    {type}\n                                &lt;/div&gt;\n                            );\n                        })}\n                    &lt;/div&gt;\n                    {locations.length &gt; 0 &amp;&amp; (\n                        &lt;div className=\&quot;legend-section\&quot;&gt;\n                            &lt;h4&gt;Locations&lt;/h4&gt;\n                            {locations.map(location =&gt; {\n                                const backgroundColor = generateLocationColor(location.id, locations.length, palette);\n                                const borderColor = generateLocationBorderColor(location.id, locations.length, palette);\n                                return (\n                                    &lt;div key={location.id} className=\&quot;legend-item\&quot;&gt;\n                                        &lt;div className=\&quot;location-legend-color\&quot; style={{ backgroundColor, borderColor }}&gt;&lt;/div&gt;\n                                        {location.label}\n                                    &lt;/div&gt;\n                                );\n                            })}\n                        &lt;/div&gt;\n                    )}\n                &lt;/div&gt;\n            );\n        }\n        \n        function HydroGraph() {\n            const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n            const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n            const [currentLayout, setCurrentLayout] = React.useState(\&#39;mrtree\&#39;);\n            const [currentPalette, setCurrentPalette] = React.useState(\&#39;Set3\&#39;);\n            const [useShortLabels, setUseShortLabels] = React.useState(true);\n            const [allContainersCollapsed, setAllContainersCollapsed] = React.useState(false);\n            \n            const [collapsedLocations, setCollapsedLocations] = React.useState({});\n            const [originalNodeDimensions, setOriginalNodeDimensions] = React.useState({});\n            const [lastChangedContainer, setLastChangedContainer] = React.useState(null);\n            const [hyperedges, setHyperedges] = React.useState([]);\n\n            const onConnect = useCallback((params) =&gt; setEdges((eds) =&gt; addEdge(params, eds)), []);\n            \n            const fitView = useCallback(() =&gt; {\n                const reactFlowInstance = window.reactFlowInstance;\n                if (reactFlowInstance) {\n                    // Check if most containers are currently collapsed\n                    const currentNodes = reactFlowInstance.getNodes();\n                    const containerNodes = currentNodes.filter(node =&gt; node.data?.isContainer);\n                    const collapsedContainers = containerNodes.filter(node =&gt; {\n                        const width = parseFloat(node.style?.width?.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 400;\n                        // A container is considered collapsed if it\&#39;s smaller than the normal expanded size\n                        // Collapsed containers are typically 200-300px wide, expanded are 400px+\n                        return width &lt;= 350; \n                    });\n                    \n                    const mostlyCollapsed = collapsedContainers.length &gt; containerNodes.length / 2;\n                    \n                    if (mostlyCollapsed) {\n                        // Most containers collapsed - use wider zoom range\n                        reactFlowInstance.fitView({ \n                            padding: 0.2, \n                            maxZoom: 0.5, \n                            minZoom: 0.02 \n                        });\n                    } else {\n                        // Mostly expanded - use closer zoom\n                        reactFlowInstance.fitView({ \n                            padding: 0.1, \n                            maxZoom: 1.0, \n                            minZoom: 0.2 \n                        });\n                    }\n                }\n            }, []);\n\n            const toggleAllContainers = useCallback(() =&gt; {\n                const reactFlowInstance = window.reactFlowInstance;\n                if (!reactFlowInstance) return;\n                \n                const currentNodes = reactFlowInstance.getNodes();\n                const containerNodes = currentNodes.filter(node =&gt; node.data?.isContainer);\n                const newCollapsedState = {};\n                const newOriginalDimensions = {};\n                \n                const shouldCollapse = !allContainersCollapsed;\n                \n                if (shouldCollapse) {\n                    // Collapse all containers\n                    containerNodes.forEach(container =&gt; {\n                        const locationId = container.id.replace(\&#39;container_\&#39;, \&#39;\&#39;);\n                        \n                        // Store original dimensions if not already stored\n                        if (!originalNodeDimensions[locationId]) {\n                            const width = parseFloat(container.style?.width?.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 400;\n                            const height = parseFloat(container.style?.height?.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 300;\n                            newOriginalDimensions[locationId] = { width, height };\n                        } else {\n                            newOriginalDimensions[locationId] = originalNodeDimensions[locationId];\n                        }\n                        \n                        newCollapsedState[locationId] = true;\n                    });\n                    \n                    const updatedNodes = currentNodes.map(node =&gt; {\n                        if (node.data?.isContainer) {\n                            // Store original label and set truncated label for collapsed state\n                            const originalLabel = node.data.originalLabel || node.data.label;\n                            const collapsedWidth = getMinCollapsedWidth(originalLabel);\n                            return { \n                                ...node, \n                                style: { ...node.style, width: collapsedWidth + \&#39;px\&#39;, height: \&#39;50px\&#39; },\n                                data: {\n                                    ...node.data,\n                                    originalLabel: originalLabel,\n                                    label: leftTruncateRustPath(originalLabel, true)\n                                }\n                            };\n                        } else if (node.parentNode) {\n                            return { ...node, hidden: true };\n                        }\n                        return node;\n                    });\n                    \n                    setNodes(updatedNodes);\n                    \n                    // Fit view after collapse\n                    setTimeout(() =&gt; {\n                        reactFlowInstance.fitView({ padding: 0.2, maxZoom: 0.5, minZoom: 0.02 });\n                    }, 100);\n                } else {\n                    // Expand all containers\n                    containerNodes.forEach(container =&gt; {\n                        const locationId = container.id.replace(\&#39;container_\&#39;, \&#39;\&#39;);\n                        newCollapsedState[locationId] = false;\n                        \n                        // Keep existing original dimensions\n                        if (originalNodeDimensions[locationId]) {\n                            newOriginalDimensions[locationId] = originalNodeDimensions[locationId];\n                        }\n                    });\n                    \n                    const updatedNodes = currentNodes.map(node =&gt; {\n                        if (node.data?.isContainer) {\n                            const locationId = node.id.replace(\&#39;container_\&#39;, \&#39;\&#39;);\n                            const originalDims = originalNodeDimensions[locationId];\n                            const originalLabel = node.data.originalLabel || node.data.label;\n                            \n                            if (originalDims) {\n                                return { \n                                    ...node, \n                                    style: { ...node.style, width: originalDims.width, height: originalDims.height },\n                                    data: { \n                                        ...node.data, \n                                        label: originalLabel\n                                    }\n                                };\n                            } else {\n                                // Default expanded size if no stored dimensions\n                                return { \n                                    ...node, \n                                    style: { ...node.style, width: 400, height: 300 },\n                                    data: { \n                                        ...node.data, \n                                        label: originalLabel\n                                    }\n                                };\n                            }\n                        } else if (node.parentNode) {\n                            return { ...node, hidden: false };\n                        }\n                        return node;\n                    });\n                    \n                    setNodes(updatedNodes);\n                    \n                    // Fit view after expand\n                    setTimeout(() =&gt; {\n                        reactFlowInstance.fitView({ padding: 0.1, maxZoom: 1.0, minZoom: 0.2 });\n                    }, 100);\n                }\n                \n                // Update states\n                setCollapsedLocations(newCollapsedState);\n                setOriginalNodeDimensions(prev =&gt; ({ ...prev, ...newOriginalDimensions }));\n                setAllContainersCollapsed(shouldCollapse);\n            }, [allContainersCollapsed, originalNodeDimensions, setCollapsedLocations, setOriginalNodeDimensions, setNodes]);\n\n            const onNodeClick = useCallback((event, node) =&gt; {\n                if (node.data?.isContainer) {\n                    const locationId = node.id.replace(\&#39;container_\&#39;, \&#39;\&#39;);\n                    \n                    // Track which container is being changed\n                    setLastChangedContainer(node.id);\n                    \n                    setCollapsedLocations(prev =&gt; {\n                        const isCollapsing = !prev[locationId];\n                        if (isCollapsing) {\n                            setOriginalNodeDimensions(dims =&gt; ({\n                                ...dims,\n                                [locationId]: { width: node.style.width, height: node.style.height }\n                            }));\n                        }\n                        \n                        const newState = { ...prev, [locationId]: isCollapsing };\n                        \n                        // Update allContainersCollapsed state\n                        setTimeout(() =&gt; {\n                            const allCollapsed = Object.values(newState).every(collapsed =&gt; collapsed);\n                            setAllContainersCollapsed(allCollapsed);\n                        }, 0);\n                        \n                        return newState;\n                    });\n                } else if (node.data?.shortLabel &amp;&amp; node.data?.fullLabel) {\n                    // Handle regular node click to toggle between short and full label\n                    setNodes(currentNodes =&gt; {\n                        return currentNodes.map(n =&gt; {\n                            if (n.id === node.id) {\n                                const isCurrentlyExpanded = n.data.expanded || false;\n                                const newLabel = isCurrentlyExpanded ? n.data.shortLabel : n.data.fullLabel;\n                                \n                                return {\n                                    ...n,\n                                    data: {\n                                        ...n.data,\n                                        label: newLabel,\n                                        expanded: !isCurrentlyExpanded\n                                    }\n                                };\n                            }\n                            return n;\n                        });\n                    });\n                }\n            }, [collapsedLocations, setNodes]);\n\n            React.useEffect(() =&gt; {\n                // Update node visibility and container sizes based on collapsed state\n                setNodes(currentNodes =&gt; {\n                    const updatedNodes = currentNodes.map(n =&gt; {\n                        if (n.data?.isContainer) {\n                            const locationId = n.id.replace(\&#39;container_\&#39;, \&#39;\&#39;);\n                            const isCollapsed = collapsedLocations[locationId];\n                            if (typeof isCollapsed !== \&#39;boolean\&#39;) return n;\n\n                            // Get the original label for this container\n                            let originalLabel = n.data.label;\n                            \n                            // If this container has a stored original label, use that\n                            if (n.data.originalLabel) {\n                                originalLabel = n.data.originalLabel;\n                            }\n\n                            if (isCollapsed) {\n                                return { \n                                    ...n, \n                                    style: { \n                                        ...n.style, \n                                        width: getMinCollapsedWidth(originalLabel), \n                                        height: 50 \n                                    },\n                                    data: { \n                                        ...n.data, \n                                        originalLabel: originalLabel, // Store original label\n                                        label: leftTruncateRustPath(originalLabel, true) \n                                    }\n                                };\n                            } else {\n                                // When expanding, use stored dimensions if available, otherwise use default size\n                                const originalDims = originalNodeDimensions[locationId];\n                                if (originalDims) {\n                                    return { \n                                        ...n, \n                                        style: { ...n.style, width: originalDims.width, height: originalDims.height },\n                                        data: { \n                                            ...n.data, \n                                            label: originalLabel // Restore original label\n                                        }\n                                    };\n                                } else {\n                                    // Default expanded size if no stored dimensions\n                                    return { \n                                        ...n, \n                                        style: { ...n.style, width: 400, height: 300 },\n                                        data: { \n                                            ...n.data, \n                                            label: originalLabel // Restore original label\n                                        }\n                                    };\n                                }\n                            }\n                        } else if (n.parentNode) {\n                            const parentLocationId = n.parentNode.replace(\&#39;container_\&#39;, \&#39;\&#39;);\n                            const isParentCollapsed = collapsedLocations[parentLocationId];\n                            if (typeof isParentCollapsed === \&#39;boolean\&#39;) {\n                                return { ...n, hidden: isParentCollapsed };\n                            }\n                        }\n                        return n;\n                    });\n\n                    // Update edges using the shared routing function\n                    setEdges(currentEdges =&gt; {\n                        const childNodeIdsByParent = {};\n                        updatedNodes.forEach(n =&gt; {\n                            if (n.parentNode) {\n                                if (!childNodeIdsByParent[n.parentNode]) {\n                                    childNodeIdsByParent[n.parentNode] = new Set();\n                                }\n                                childNodeIdsByParent[n.parentNode].add(n.id);\n                            }\n                        });\n\n                        return routeEdgesForCollapsedContainers(currentEdges, collapsedLocations, childNodeIdsByParent);\n                    });\n\n                    return updatedNodes;\n                });\n                \n                // STEP 2: Use ELK to intelligently reposition containers after expand/collapse\n                setTimeout(async () =&gt; {\n                    const reactFlowInstance = window.reactFlowInstance;\n                    if (reactFlowInstance) {\n                        try {\n                            const currentNodes = reactFlowInstance.getNodes();\n                            const containerNodes = currentNodes.filter(node =&gt; node.data?.isContainer);\n                            \n                            if (containerNodes.length &gt; 0) {\n                                // Use the tracked changed container ID for better layout preservation\n                                const changedContainerId = lastChangedContainer;\n                                \n                                // Reconstruct original internal nodes for hyperedge generation\n                                // Get all child nodes (both hidden and visible) and treat them as the internal nodes\n                                const internalNodes = currentNodes.filter(node =&gt; \n                                    !node.data?.isContainer &amp;&amp; node.parentNode\n                                );\n                                \n                                // Use original edges (not the routed container edges) for hyperedge generation\n                                const originalEdges = initialEdges;\n                                \n                                // Use ELK to layout containers while preserving positions of unchanged ones\n                                const layoutedContainers = await layoutContainersWithELK(containerNodes, internalNodes, originalEdges, changedContainerId, hyperedges);\n                                \n                                // Update all nodes with the new container positions\n                                const updatedNodes = currentNodes.map(node =&gt; {\n                                    if (node.data?.isContainer) {\n                                        const layoutedContainer = layoutedContainers.find(c =&gt; c.id === node.id);\n                                        return layoutedContainer || node;\n                                    }\n                                    return node;\n                                });\n                                \n                                setNodes(updatedNodes);\n                                \n                                // Clear the changed container tracking\n                                setLastChangedContainer(null);\n                                \n                                // Re-fit view after repositioning\n                                setTimeout(() =&gt; {\n                                    reactFlowInstance.fitView({ padding: 0.1, maxZoom: 1.0, minZoom: 0.01 });\n                                }, 100);\n                            }\n                        } catch (error) {\n                            console.error(\&#39;Error re-layouting containers with ELK:\&#39;, error);\n                        }\n                    }\n                }, 300);\n            }, [collapsedLocations, originalNodeDimensions, lastChangedContainer]);\n            \n            // Apply node colors based on palette\n            const applyNodePalette = useCallback((nodes, palette) =&gt; {\n                return nodes.map(node =&gt; {\n                    if (node.data?.isContainer) return node;\n                    \n                    const nodeType = node.data?.nodeType || \&#39;Transform\&#39;;\n                    const colors = generateNodeColors(nodeType, palette);\n                    \n                    return {\n                        ...node,\n                        style: {\n                            ...node.style,\n                            background: colors.gradient,\n                            border: `1px solid ${colors.border}`,\n                            // Remove the fixed gradients that were in the data\n                            \&#39;--node-color-primary\&#39;: colors.primary,\n                            \&#39;--node-color-secondary\&#39;: colors.secondary,\n                            \&#39;--node-border-color\&#39;: colors.border,\n                        }\n                    };\n                });\n            }, []);\n            \n            const onInit = useCallback(async (reactFlowInstance) =&gt; {\n                window.reactFlowInstance = reactFlowInstance;\n                \n                // Compute hyperedges once from the initial graph structure\n                const computedHyperedges = generateHyperedges(initialNodes, initialEdges);\n                setHyperedges(computedHyperedges);\n                \n                // Apply ELK layout to get proper positions\n                const layoutedNodes = await applyElkLayout(initialNodes, initialEdges, currentLayout, computedHyperedges);\n                \n                // Group nodes by location for hierarchical display\n                const locationContainers = [];\n                const childNodes = [];\n                \n                if (graphData.locations &amp;&amp; graphData.locations.length &gt; 0) {\n                    graphData.locations.forEach(location =&gt; {\n                        // Find nodes in this location\n                        const locationNodes = layoutedNodes.filter(node =&gt; {\n                            const nodeLocationId = node.data?.locationId;\n                            return nodeLocationId !== null &amp;&amp; \n                                   nodeLocationId !== undefined &amp;&amp; \n                                   nodeLocationId.toString() === location.id.toString();\n                        });\n                        \n                        if (locationNodes.length &gt; 0) {\n                            // Create container using helper function\n                            const container = createLocationContainer(location, locationNodes, currentPalette);\n                            locationContainers.push(container);\n                            \n                            // Create child nodes using helper function\n                            const children = createChildNodes(locationNodes, container.id, container.position);\n                            childNodes.push(...children);\n                        }\n                    });\n                    \n                    // Handle orphan nodes (not in any location) - group them into a grey container\n                    const orphanNodes = layoutedNodes.filter(node =&gt; {\n                        const nodeLocationId = node.data?.locationId;\n                        if (nodeLocationId === null || nodeLocationId === undefined) return true;\n                        \n                        return !graphData.locations.some(loc =&gt; \n                            loc.id.toString() === nodeLocationId.toString()\n                        );\n                    });\n                    \n                    if (orphanNodes.length &gt; 0) {\n                        // Create orphan container using similar logic\n                        const orphanLocation = { id: \&#39;null\&#39;, label: \&#39;Internal/Unassigned\&#39; };\n                        const orphanContainer = createLocationContainer(orphanLocation, orphanNodes, currentPalette);\n                        \n                        // Override styles for orphan container\n                        orphanContainer.id = \&#39;container_null\&#39;;\n                        orphanContainer.style.backgroundColor = \&#39;rgba(200, 200, 200, 0.2)\&#39;;\n                        orphanContainer.style.border = \&#39;2px solid #999999\&#39;;\n                        \n                        locationContainers.push(orphanContainer);\n                        \n                        const orphanChildren = createChildNodes(orphanNodes, orphanContainer.id, orphanContainer.position);\n                        childNodes.push(...orphanChildren);\n                    }\n                } else {\n                    // No locations defined, use all nodes as-is\n                    childNodes.push(...layoutedNodes);\n                }\n                \n                \n                // Apply palette colors to nodes\n                const coloredChildNodes = applyNodePalette(childNodes, currentPalette);\n                \n                // Combine containers and child nodes\n                const allElements = [...locationContainers, ...coloredChildNodes];\n                \n                // STEP 1: Use greedy expansion algorithm to determine initial container states\n                const locationNodesByLocationId = {};\n                graphData.locations?.forEach(location =&gt; {\n                    const locationNodes = layoutedNodes.filter(node =&gt; {\n                        const nodeLocationId = node.data?.locationId;\n                        return nodeLocationId !== null &amp;&amp; \n                               nodeLocationId !== undefined &amp;&amp; \n                               nodeLocationId.toString() === location.id.toString();\n                    });\n                    if (locationNodes.length &gt; 0) {\n                        locationNodesByLocationId[location.id.toString()] = locationNodes;\n                    }\n                });\n                \n                // Add orphan nodes to location mapping\n                const orphanNodes = layoutedNodes.filter(node =&gt; {\n                    const nodeLocationId = node.data?.locationId;\n                    if (nodeLocationId === null || nodeLocationId === undefined) return true;\n                    return !graphData.locations.some(loc =&gt; \n                        loc.id.toString() === nodeLocationId.toString()\n                    );\n                });\n                if (orphanNodes.length &gt; 0) {\n                    locationNodesByLocationId[\&#39;null\&#39;] = orphanNodes;\n                }\n                \n                // Determine initial states using greedy expansion\n                const initialCollapsedState = determineInitialContainerStates(locationContainers, locationNodesByLocationId);\n                const initialOriginalDimensions = {};\n                \n                // Apply the determined states to containers\n                locationContainers.forEach(container =&gt; {\n                    const width = parseFloat(container.style.width.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 400;\n                    const height = parseFloat(container.style.height.toString().replace(\&#39;px\&#39;, \&#39;\&#39;)) || 300;\n                    const locationId = container.id.replace(\&#39;container_\&#39;, \&#39;\&#39;);\n                    \n                    // Store original dimensions\n                    initialOriginalDimensions[locationId] = { width, height };\n                    \n                    const isCollapsed = initialCollapsedState[locationId];\n                    \n                    if (isCollapsed) {\n                        // Store original label and modify container to collapsed state with truncated label\n                        const originalLabel = container.data.label;\n                        const collapsedWidth = getMinCollapsedWidth(originalLabel);\n                        container.style.width = collapsedWidth + \&#39;px\&#39;;\n                        container.style.height = \&#39;50px\&#39;;\n                        container.data = {\n                            ...container.data,\n                            originalLabel: originalLabel,\n                            label: leftTruncateRustPath(originalLabel, true)\n                        };\n                        \n                        // Hide child nodes for collapsed containers\n                        allElements.forEach(element =&gt; {\n                            if (element.parentNode === container.id) {\n                                element.hidden = true;\n                            }\n                        });\n                    }\n                    // If not collapsed, leave container and children as-is (expanded)\n                });\n                \n                // Set initial states\n                setCollapsedLocations(initialCollapsedState);\n                setOriginalNodeDimensions(initialOriginalDimensions);\n                \n                // Update allContainersCollapsed state based on initial container states\n                const allCollapsed = Object.values(initialCollapsedState).every(collapsed =&gt; collapsed);\n                setAllContainersCollapsed(allCollapsed);\n                \n                setNodes(allElements);\n                setEdges(initialEdges);\n                \n                // Apply initial label state to ensure consistency with useShortLabels\n                setTimeout(() =&gt; {\n                    setNodes(currentNodes =&gt; {\n                        return currentNodes.map(node =&gt; {\n                            // For container nodes, handle label toggling\n                            if (node.data?.isContainer) {\n                                const originalLabel = node.data.originalLabel || node.data.label;\n                                const newLabel = useShortLabels \n                                    ? leftTruncateRustPath(originalLabel, true)\n                                    : originalLabel;\n                                \n                                return {\n                                    ...node,\n                                    data: {\n                                        ...node.data,\n                                        label: newLabel,\n                                        originalLabel: originalLabel\n                                    }\n                                };\n                            }\n                            \n                            // For regular nodes, use shortLabel/fullLabel\n                            if (node.data?.shortLabel &amp;&amp; node.data?.fullLabel) {\n                                return {\n                                    ...node,\n                                    data: {\n                                        ...node.data,\n                                        label: useShortLabels ? node.data.shortLabel : node.data.fullLabel\n                                    }\n                                };\n                            }\n                            \n                            return node;\n                        });\n                    });\n                }, 10); // Small delay to ensure nodes are set\n                \n                // Apply initial edge routing based on determined container states\n                setTimeout(() =&gt; {\n                    setEdges(currentEdges =&gt; {\n                        const childNodeIdsByParent = {};\n                        allElements.forEach(n =&gt; {\n                            if (n.parentNode) {\n                                if (!childNodeIdsByParent[n.parentNode]) {\n                                    childNodeIdsByParent[n.parentNode] = new Set();\n                                }\n                                childNodeIdsByParent[n.parentNode].add(n.id);\n                            }\n                        });\n                        return routeEdgesForCollapsedContainers(currentEdges, initialCollapsedState, childNodeIdsByParent);\n                    });\n                }, 50);\n                \n                // Adaptive fit view based on whether containers are mostly expanded or collapsed\n                const expandedCount = Object.values(initialCollapsedState).filter(collapsed =&gt; !collapsed).length;\n                const totalCount = Object.keys(initialCollapsedState).length;\n                const mostlyExpanded = expandedCount &gt; totalCount / 2;\n                \n                if (mostlyExpanded) {\n                    // Most containers expanded - use closer zoom for details\n                    reactFlowInstance.fitView({ padding: 0.1, maxZoom: 1.0, minZoom: 0.2, duration: 300 });\n                } else {\n                    // Most containers collapsed - use wider zoom\n                    reactFlowInstance.fitView({ padding: 0.2, maxZoom: 0.5, minZoom: 0.02, duration: 300 });\n                }\n            }, [setNodes, setEdges, currentLayout, currentPalette, applyNodePalette, setHyperedges, useShortLabels]);\n\n            // Apply elk layout with selected algorithm\n            const applyLayout = useCallback(async (layoutType = currentLayout) =&gt; {\n                // Only layout the actual graph nodes, not containers\n                const actualNodes = nodes.filter(node =&gt; !node.data?.isContainer);\n                \n                if (actualNodes.length === 0) return;\n                \n                const layoutedNodes = await applyElkLayout(actualNodes, edges, layoutType, hyperedges);\n                \n                // Create new containers and child relationships using helper functions\n                const locationContainers = [];\n                const childNodes = [];\n                \n                if (graphData.locations &amp;&amp; graphData.locations.length &gt; 0) {\n                    graphData.locations.forEach(location =&gt; {\n                        const locationNodes = layoutedNodes.filter(node =&gt; {\n                            const nodeLocationId = node.data?.locationId;\n                            return nodeLocationId !== null &amp;&amp; \n                                   nodeLocationId !== undefined &amp;&amp; \n                                   nodeLocationId.toString() === location.id.toString();\n                        });\n                        \n                        if (locationNodes.length &gt; 0) {\n                            const container = createLocationContainer(location, locationNodes, currentPalette);\n                            \n                            // Check if this container is currently collapsed\n                            const locationId = location.id.toString();\n                            const isCollapsed = collapsedLocations[locationId];\n                            \n                            // ALWAYS update the original dimensions with the new layout\&#39;s correct size\n                            // This ensures that when collapsed containers are later expanded, they use\n                            // the correct dimensions for the current layout, not the old layout\n                            setOriginalNodeDimensions(prev =&gt; ({\n                                ...prev,\n                                [locationId]: { \n                                    width: container.style.width, \n                                    height: container.style.height \n                                }\n                            }));\n                            \n                            if (isCollapsed) {\n                                // If collapsed, preserve the collapsed dimensions and label for display\n                                const existingContainer = nodes.find(n =&gt; n.id === container.id);\n                                if (existingContainer) {\n                                    container.style.width = existingContainer.style.width;\n                                    container.style.height = existingContainer.style.height;\n                                    container.data = {\n                                        ...container.data,\n                                        originalLabel: existingContainer.data.originalLabel || container.data.label,\n                                        label: existingContainer.data.label\n                                    };\n                                } else {\n                                    // Fallback to standard collapsed sizing\n                                    const originalLabel = container.data.label;\n                                    const collapsedWidth = getMinCollapsedWidth(originalLabel);\n                                    container.style.width = collapsedWidth + \&#39;px\&#39;;\n                                    container.style.height = \&#39;50px\&#39;;\n                                    container.data = {\n                                        ...container.data,\n                                        originalLabel: originalLabel,\n                                        label: leftTruncateRustPath(originalLabel, true)\n                                    };\n                                }\n                            }\n                            \n                            locationContainers.push(container);\n                            \n                            const children = createChildNodes(locationNodes, container.id, container.position);\n                            // Hide children if container is collapsed\n                            const visibleChildren = children.map(child =&gt; ({\n                                ...child,\n                                hidden: isCollapsed\n                            }));\n                            childNodes.push(...visibleChildren);\n                        }\n                    });\n                    \n                    // Handle orphan nodes\n                    const orphanNodes = layoutedNodes.filter(node =&gt; {\n                        const nodeLocationId = node.data?.locationId;\n                        if (nodeLocationId === null || nodeLocationId === undefined) return true;\n                        return !graphData.locations.some(loc =&gt; \n                            loc.id.toString() === nodeLocationId.toString()\n                        );\n                    });\n                    \n                    if (orphanNodes.length &gt; 0) {\n                        const orphanLocation = { id: \&#39;null\&#39;, label: \&#39;Internal/Unassigned\&#39; };\n                        const orphanContainer = createLocationContainer(orphanLocation, orphanNodes, currentPalette);\n                        \n                        // Override styles for orphan container\n                        orphanContainer.id = \&#39;container_null\&#39;;\n                        orphanContainer.style.backgroundColor = \&#39;rgba(200, 200, 200, 0.2)\&#39;;\n                        orphanContainer.style.border = \&#39;2px solid #999999\&#39;;\n                        \n                        // ALWAYS update the original dimensions for the orphan container\n                        // This ensures correct sizing when expanded after layout changes\n                        setOriginalNodeDimensions(prev =&gt; ({\n                            ...prev,\n                            \&#39;null\&#39;: { \n                                width: orphanContainer.style.width, \n                                height: orphanContainer.style.height \n                            }\n                        }));\n                        \n                        // Check if orphan container is collapsed\n                        const isOrphanCollapsed = collapsedLocations[\&#39;null\&#39;];\n                        if (isOrphanCollapsed) {\n                            const existingOrphanContainer = nodes.find(n =&gt; n.id === \&#39;container_null\&#39;);\n                            if (existingOrphanContainer) {\n                                orphanContainer.style.width = existingOrphanContainer.style.width;\n                                orphanContainer.style.height = existingOrphanContainer.style.height;\n                                orphanContainer.data = {\n                                    ...orphanContainer.data,\n                                    originalLabel: existingOrphanContainer.data.originalLabel || orphanContainer.data.label,\n                                    label: existingOrphanContainer.data.label\n                                };\n                            } else {\n                                const originalLabel = orphanContainer.data.label;\n                                const collapsedWidth = getMinCollapsedWidth(originalLabel);\n                                orphanContainer.style.width = collapsedWidth + \&#39;px\&#39;;\n                                orphanContainer.style.height = \&#39;50px\&#39;;\n                                orphanContainer.data = {\n                                    ...orphanContainer.data,\n                                    originalLabel: originalLabel,\n                                    label: leftTruncateRustPath(originalLabel, true)\n                                };\n                            }\n                        }\n                        \n                        locationContainers.push(orphanContainer);\n                        \n                        const orphanChildren = createChildNodes(orphanNodes, orphanContainer.id, orphanContainer.position);\n                        // Hide orphan children if container is collapsed\n                        const visibleOrphanChildren = orphanChildren.map(child =&gt; ({\n                            ...child,\n                            hidden: isOrphanCollapsed\n                        }));\n                        childNodes.push(...visibleOrphanChildren);\n                    }\n                } else {\n                    childNodes.push(...layoutedNodes);\n                }\n                \n                // Apply palette colors and update nodes\n                const coloredChildNodes = applyNodePalette(childNodes, currentPalette);\n                \n                // Apply global label state to all nodes\n                const labelAdjustedNodes = coloredChildNodes.map(node =&gt; {\n                    if (node.data?.shortLabel &amp;&amp; node.data?.fullLabel) {\n                        return {\n                            ...node,\n                            data: {\n                                ...node.data,\n                                label: useShortLabels ? node.data.shortLabel : node.data.fullLabel\n                            }\n                        };\n                    }\n                    return node;\n                });\n                \n                // Also apply label state to containers\n                const labelAdjustedContainers = locationContainers.map(container =&gt; {\n                    if (container.data?.isContainer) {\n                        const originalLabel = container.data.originalLabel || container.data.label;\n                        const newLabel = useShortLabels \n                            ? leftTruncateRustPath(originalLabel, true)\n                            : originalLabel;\n                        \n                        return {\n                            ...container,\n                            data: {\n                                ...container.data,\n                                label: newLabel,\n                                originalLabel: originalLabel\n                            }\n                        };\n                    }\n                    return container;\n                });\n                \n                const allElements = [...labelAdjustedContainers, ...labelAdjustedNodes];\n                setNodes(allElements);\n                \n                // Update edges to respect current collapsed state\n                setTimeout(() =&gt; {\n                    setEdges(currentEdges =&gt; {\n                        const childNodeIdsByParent = {};\n                        allElements.forEach(n =&gt; {\n                            if (n.parentNode) {\n                                if (!childNodeIdsByParent[n.parentNode]) {\n                                    childNodeIdsByParent[n.parentNode] = new Set();\n                                }\n                                childNodeIdsByParent[n.parentNode].add(n.id);\n                            }\n                        });\n                        return routeEdgesForCollapsedContainers(currentEdges, collapsedLocations, childNodeIdsByParent);\n                    });\n                }, 50);\n                \n                // Fit view after layout change\n                setTimeout(() =&gt; {\n                    const reactFlowInstance = window.reactFlowInstance;\n                    if (reactFlowInstance) {\n                        reactFlowInstance.fitView({ padding: 0.1, maxZoom: 1.0, minZoom: 0.01 });\n                    }\n                }, 100);\n            }, [nodes, edges, currentLayout, currentPalette, collapsedLocations, setNodes, setOriginalNodeDimensions, applyNodePalette, hyperedges, useShortLabels]);\n\n            const toggleLabelMode = useCallback(() =&gt; {\n                setUseShortLabels(prev =&gt; {\n                    const newUseShortLabels = !prev;\n                    \n                    // Update all nodes with appropriate labels\n                    setNodes(currentNodes =&gt; {\n                        return currentNodes.map(node =&gt; {\n                            // For container nodes, handle label toggling\n                            if (node.data?.isContainer) {\n                                const originalLabel = node.data.originalLabel || node.data.label;\n                                const newLabel = newUseShortLabels \n                                    ? leftTruncateRustPath(originalLabel, true)\n                                    : originalLabel;\n                                \n                                return {\n                                    ...node,\n                                    data: {\n                                        ...node.data,\n                                        label: newLabel,\n                                        originalLabel: originalLabel\n                                    }\n                                };\n                            }\n                            \n                            // For regular nodes, use shortLabel/fullLabel\n                            if (node.data?.shortLabel &amp;&amp; node.data?.fullLabel) {\n                                return {\n                                    ...node,\n                                    data: {\n                                        ...node.data,\n                                        label: newUseShortLabels ? node.data.shortLabel : node.data.fullLabel\n                                    }\n                                };\n                            }\n                            \n                            return node;\n                        });\n                    });\n                    \n                    return newUseShortLabels;\n                });\n            }, [setNodes]);\n\n            const onLayoutChange = (event) =&gt; {\n                const newLayout = event.target.value;\n                setCurrentLayout(newLayout);\n                applyLayout(newLayout);\n            };\n\n            const onPaletteChange = (event) =&gt; {\n                const newPalette = event.target.value;\n                setCurrentPalette(newPalette);\n                \n                // Re-color nodes\n                const recoloredNodes = applyNodePalette(nodes, newPalette);\n                \n                // Re-color location containers\n                const finalNodes = recoloredNodes.map(node =&gt; {\n                    if (node.data?.isContainer) {\n                        const locationId = node.id.split(\&#39;_\&#39;)[1];\n                        if (locationId === \&#39;null\&#39;) {\n                            return {\n                                ...node,\n                                style: {\n                                    ...node.style,\n                                    backgroundColor: \&#39;rgba(200, 200, 200, 0.2)\&#39;,\n                                    border: \&#39;2px solid #999999\&#39;,\n                                }\n                            };\n                        }\n                        \n                        const loc = graphData.locations.find(l =&gt; l.id.toString() === locationId);\n                        if (loc) {\n                            const backgroundColor = generateLocationColor(loc.id, graphData.locations.length, newPalette);\n                            const borderColor = generateLocationBorderColor(loc.id, graphData.locations.length, newPalette);\n                            return {\n                                ...node,\n                                style: {\n                                    ...node.style,\n                                    backgroundColor: backgroundColor,\n                                    border: `2px solid ${borderColor}`,\n                                }\n                            };\n                        }\n                    }\n                    return node;\n                });\n                \n                setNodes(finalNodes);\n                \n                // Re-color edges\n                const recoloredEdges = edges.map(edge =&gt; {\n                    const sourceNode = nodes.find(n =&gt; n.id === edge.source);\n                    if (sourceNode) {\n                        const nodeType = sourceNode.data?.nodeType || \&#39;Transform\&#39;;\n                        const colors = generateNodeColors(nodeType, newPalette);\n                        return {\n                            ...edge,\n                            style: { ...edge.style, stroke: colors.border },\n                            markerEnd: { ...edge.markerEnd, color: colors.border }\n                        };\n                    }\n                    return edge;\n                });\n                setEdges(recoloredEdges);\n            };\n\n            return (\n                &lt;div className=\&quot;reactflow-wrapper\&quot;&gt;\n                    &lt;div className=\&quot;layout-controls\&quot;&gt;\n                        &lt;select className=\&quot;layout-select\&quot; value={currentLayout} onChange={onLayoutChange}&gt;\n                            {Object.keys(elkLayouts).map(key =&gt; (\n                                &lt;option key={key} value={key}&gt;{key.charAt(0).toUpperCase() + key.slice(1)}&lt;/option&gt;\n                            ))}\n                        &lt;/select&gt;\n                        &lt;select className=\&quot;palette-select\&quot; value={currentPalette} onChange={onPaletteChange}&gt;\n                            {Object.keys(colorPalettes).map(key =&gt; (\n                                &lt;option key={key} value={key}&gt;{key}&lt;/option&gt;\n                            ))}\n                        &lt;/select&gt;\n                        &lt;button className=\&quot;icon-button\&quot; onClick={() =&gt; applyLayout(currentLayout)}&gt;\n                            &lt;svg xmlns=\&quot;http://www.w3.org/2000/svg\&quot; width=\&quot;16\&quot; height=\&quot;16\&quot; fill=\&quot;currentColor\&quot; viewBox=\&quot;0 0 16 16\&quot;&gt;\n                                &lt;path fill-rule=\&quot;evenodd\&quot; d=\&quot;M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z\&quot;/&gt;\n                                &lt;path d=\&quot;M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z\&quot;/&gt;\n                            &lt;/svg&gt;\n                            &lt;span className=\&quot;tooltip\&quot;&gt;Refresh Layout&lt;/span&gt;\n                        &lt;/button&gt;\n                        &lt;button className=\&quot;icon-button\&quot; onClick={fitView}&gt;\n                            &lt;span style={{fontSize: \&#39;16px\&#39;, fontWeight: \&#39;bold\&#39;, display: \&#39;flex\&#39;, alignItems: \&#39;center\&#39;, justifyContent: \&#39;center\&#39;}}&gt;\n                                \u{26f6}\n                            &lt;/span&gt;\n                            &lt;span className=\&quot;tooltip\&quot;&gt;Fit to View&lt;/span&gt;\n                        &lt;/button&gt;\n                        &lt;button className=\&quot;icon-button\&quot; onClick={toggleAllContainers}&gt;\n                            &lt;span style={{fontSize: \&#39;16px\&#39;, fontWeight: \&#39;bold\&#39;, display: \&#39;flex\&#39;, alignItems: \&#39;center\&#39;, justifyContent: \&#39;center\&#39;}}&gt;\n                                {allContainersCollapsed ? \&#39;\u{2295}\&#39; : \&#39;\u{2296}\&#39;}\n                            &lt;/span&gt;\n                            &lt;span className=\&quot;tooltip\&quot;&gt;{allContainersCollapsed ? \&#39;Expand All Containers\&#39; : \&#39;Collapse All Containers\&#39;}&lt;/span&gt;\n                        &lt;/button&gt;\n                        &lt;button className=\&quot;icon-button\&quot; onClick={toggleLabelMode}&gt;\n                            &lt;span style={{fontSize: \&#39;14px\&#39;, fontWeight: \&#39;bold\&#39;}}&gt;\n                                {useShortLabels ? \&#39;\u{2194}\&#39; : \&#39;\u{2192}\u{2190}\&#39;}\n                            &lt;/span&gt;\n                            &lt;span className=\&quot;tooltip\&quot;&gt;{useShortLabels ? \&#39;Show Full Labels\&#39; : \&#39;Show Short Labels\&#39;}&lt;/span&gt;\n                        &lt;/button&gt;\n                    &lt;/div&gt;\n                    &lt;UnifiedLegend palette={currentPalette} /&gt;\n                    &lt;ReactFlow\n                        nodes={nodes}\n                        edges={edges}\n                        onNodesChange={onNodesChange}\n                        onEdgesChange={onEdgesChange}\n                        onConnect={onConnect}\n                        onInit={onInit}\n                        onNodeClick={onNodeClick}\n                        fitView\n                        attributionPosition=\&quot;bottom-left\&quot;\n                    &gt;\n                        &lt;Controls /&gt;\n                        &lt;MiniMap /&gt;\n                        &lt;Background /&gt;\n                    &lt;/ReactFlow&gt;\n                &lt;/div&gt;\n            );\n        }\n\n        ReactDOM.render(&lt;HydroGraph /&gt;, document.getElementById(\&#39;root\&#39;));\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;;</code></pre><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>viz</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>HTML template for ReactFlow visualization</p>
</div></details></section></div></main></body></html>