<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hydro IR Graph - ReactFlow.js</title>
    <script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/reactflow@11.11.4/dist/umd/index.js"></script>
    <script src="https://unpkg.com/elkjs@0.8.2/lib/elk.bundled.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/reactflow@11.11.4/dist/style.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .reactflow-wrapper {
            width: 100vw;
            height: 100vh;
        }
        /* Compact unified legend in upper right */
        .unified-legend {
            position: absolute;
            top: 90px;
            right: 10px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 8px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            max-width: 220px;
            font-size: 11px;
        }
        /* Layout controls above legend */
        .layout-controls {
            position: absolute;
            top: 40px;
            right: 10px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .unified-legend h4 {
            margin: 0 0 6px 0;
            font-size: 12px;
            font-weight: 600;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 3px;
        }
        .legend-section {
            margin-bottom: 8px;
        }
        .legend-section:last-child {
            margin-bottom: 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 3px 0;
            font-size: 10px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 6px;
            border: 1px solid #666;
            flex-shrink: 0;
        }
        .location-legend-color {
            width: 16px;
            height: 10px;
            border-radius: 2px;
            margin-right: 6px;
            border: 1px solid;
            flex-shrink: 0;
        }
        .icon-button {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 4px;
            background: #f8f9fa;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #495057;
            transition: all 0.2s ease;
            position: relative;
        }
        .icon-button:hover {
            background: #e9ecef;
            color: #212529;
            transform: translateY(-1px);
        }
        .icon-button:active {
            transform: translateY(0);
        }
        .layout-select, .palette-select {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 11px;
            padding: 4px 6px;
            width: 80px;
            color: #495057;
        }
        .layout-select:hover, .palette-select:hover {
            border-color: #adb5bd;
        }
        /* Tooltip styles */
        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            margin-bottom: 4px;
        }
        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 4px solid transparent;
            border-top-color: #333;
        }
        /* Special positioning for rightmost button tooltip to avoid cutoff */
        .layout-controls .icon-button:last-child .tooltip {
            left: auto;
            right: 0;
            transform: none;
        }
        .layout-controls .icon-button:last-child .tooltip::after {
            left: auto;
            right: 16px;
            transform: none;
        }
        .icon-button:hover .tooltip {
            opacity: 1;
        }
        .react-flow__node {
            cursor: pointer;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }
        .react-flow__node:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        /* Container node specific styles */
        .react-flow__node.container-node {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 12px;
            font-weight: 500;
            color: #333;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 4px 8px;
            box-sizing: border-box;
        }
        /* Ensure container labels are readable when collapsed */
        .react-flow__node.container-node .react-flow__node-default {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        // @ts-nocheck
        // eslint-disable-next-line
        const graphData = {{GRAPH_DATA}};
        const { useState, useCallback, useRef, useEffect } = React;
        // ReactFlow v11 components via reactflow
        const ReactFlowLib = window.ReactFlow;
        const { default: ReactFlow, Controls, MiniMap, Background, useNodesState, useEdgesState, addEdge, applyNodeChanges, applyEdgeChanges } = ReactFlowLib;
        
        // ColorBrewer palettes - expanded collection with various aesthetics
        const colorPalettes = {
            // Qualitative palettes (great for categorical data)
            'Set3': ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69'],
            'Pastel1': ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd'],
            'Pastel2': ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc'],
            'Set1': ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628'],
            'Set2': ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494'],
            'Dark2': ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d'],
            'Accent': ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17'],
            'Paired': ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f'],
            
            // Sequential palettes (good for intensity/hierarchy)
            'Blues': ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5'],
            'Greens': ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45'],
            'Oranges': ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801'],
            'Purples': ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3'],
            'Reds': ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d'],
            
            // Diverging palettes (great for showing contrasts)
            'Spectral': ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#e6f598', '#abdda4'],
            'RdYlBu': ['#d73027', '#f46d43', '#fdae61', '#fee090', '#e0f3f8', '#abd9e9', '#74add1'],
            'RdYlGn': ['#d73027', '#f46d43', '#fdae61', '#fee08b', '#d9ef8b', '#a6d96a', '#66bd63'],
            'PiYG': ['#d01c8b', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#4d9221'],
            'BrBG': ['#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#c7eae5', '#80cdc1', '#35978f'],
            
            // Modern/trendy palettes
            'Viridis': ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a'],
            'Plasma': ['#0d0887', '#6a00a8', '#b12a90', '#e16462', '#fca636', '#f0f921', '#fcffa4'],
            'Warm': ['#375a7f', '#5bc0de', '#5cb85c', '#f0ad4e', '#d9534f', '#ad4e92', '#6f5499'],
            'Cool': ['#2c3e50', '#3498db', '#1abc9c', '#16a085', '#27ae60', '#2980b9', '#8e44ad'],
            'Earth': ['#8b4513', '#a0522d', '#cd853f', '#daa520', '#b8860b', '#228b22', '#006400']
        };
        
        // Remove sourcePosition/targetPosition from nodes for flexible edge attachment
        const initialNodes = (graphData.nodes || []).map(node => {
            const { sourcePosition, targetPosition, ...rest } = node;
            return rest;
        });
        const initialEdges = (graphData.edges || []).map(edge => {
            // Use 'bezier' edge type for flexible routing to all sides of nodes (left, right, top, bottom)
            const processedEdge = {
                id: edge.id,
                source: edge.source,
                target: edge.target,
                type: 'bezier',
                zIndex: 1000,
                markerEnd: {
                    type: 'arrowclosed',
                    width: 20,
                    height: 20,
                    color: edge.style?.stroke || '#666666'
                },
                style: {
                    strokeWidth: edge.style?.strokeWidth || 2,
                    stroke: edge.style?.stroke || '#666666',
                    strokeDasharray: edge.style?.strokeDasharray
                },
                animated: edge.animated || false,
                interactionWidth: 20
            };
            if (edge.label) processedEdge.label = edge.label;
            if (edge.labelStyle) processedEdge.labelStyle = edge.labelStyle;
            if (edge.labelShowBg) processedEdge.labelShowBg = edge.labelShowBg;
            if (edge.labelBgStyle) processedEdge.labelBgStyle = edge.labelBgStyle;
            return processedEdge;
        });

        // elk.js layout configuration with hierarchical support
        const elkLayouts = {
            layered: {
                'elk.algorithm': 'layered',
                'elk.layered.spacing.nodeNodeBetweenLayers': 150,
                'elk.spacing.nodeNode': 120,
                'elk.spacing.componentComponent': 80,
                'elk.direction': 'RIGHT',
                'elk.layered.thoroughness': 7,
                'elk.hierarchyHandling': 'SEPARATE_CHILDREN'
            },
            force: {
                'elk.algorithm': 'force',
                'elk.force.repulsivePower': 0.5,
                'elk.spacing.nodeNode': 150,
                'elk.spacing.componentComponent': 100,
                'elk.hierarchyHandling': 'SEPARATE_CHILDREN'
            },
            stress: {
                'elk.algorithm': 'stress',
                'elk.stress.desiredEdgeLength': 150,
                'elk.spacing.nodeNode': 120,
                'elk.spacing.componentComponent': 80,
                'elk.hierarchyHandling': 'SEPARATE_CHILDREN'
            },
            mrtree: {
                'elk.algorithm': 'mrtree',
                'elk.mrtree.searchOrder': 'DFS',
                'elk.spacing.nodeNode': 120,
                'elk.spacing.componentComponent': 80,
                'elk.hierarchyHandling': 'SEPARATE_CHILDREN'
            },
            radial: {
                'elk.algorithm': 'radial',
                'elk.radial.radius': 250,
                'elk.spacing.nodeNode': 120,
                'elk.spacing.componentComponent': 80,
                'elk.hierarchyHandling': 'SEPARATE_CHILDREN'
            },
            disco: {
                'elk.algorithm': 'disco',
                'elk.disco.componentCompaction.strategy': 'POLYOMINO',
                'elk.spacing.nodeNode': 80,
                'elk.hierarchyHandling': 'INCLUDE_CHILDREN'
            }
        };

        // Generate colors based on selected palette
        const generateNodeColors = (nodeType, palette = 'Set3') => {
            const colors = colorPalettes[palette];
            const typeMap = {
                'Source': 0,
                'Transform': 1,
                'Join': 2,
                'Aggregation': 3,
                'Network': 4,
                'Sink': 5,
                'Tee': 6
            };
            
            const baseColor = colors[typeMap[nodeType] || 0];
            
            // Create gradient colors
            const primary = baseColor;
            const secondary = lightenColor(baseColor, 10);
            const tertiary = lightenColor(baseColor, 25);
            const border = darkenColor(baseColor, 5);
            
            // Create a gentle linear gradient
            const gradient = `linear-gradient(0deg, ${tertiary} 0%, ${secondary} 80%, ${primary} 100%)`;
            
            return { primary, secondary, tertiary, border, gradient };
        };
        
        // Simplified color manipulation using CSS color-mix
        const lightenColor = (color, percent) => `color-mix(in srgb, ${color} ${100-percent}%, white)`;
        const darkenColor = (color, percent) => `color-mix(in srgb, ${color} ${100-percent}%, black)`;

        // Helper function to truncate long labels for collapsed containers
        const leftTruncateRustPath = (label, isCollapsed) => {
            if (!isCollapsed) return label;
            if (!label || typeof label !== 'string') return 'Unknown';
            
            // For collapsed containers, we have about 180px width (200px - padding)
            // Assuming average character width of ~8px, we can fit about 22 characters
            let maxLength = 22;
            
            if (label.length <= maxLength) return label;
            
            // If it contains "::" separators, left-truncate with ellipses on the left
            if (label.includes('::')) {
                const segments = label.split('::');
                const lastComponent = segments[segments.length - 1];
                
                // Always show at least "...::lastComponent"
                const minTruncated = '...' + '::' + lastComponent;
                
                // If the minimum required format is longer than our standard width,
                // we'll need a wider container - return the minimum format
                if (minTruncated.length > maxLength) {
                    return minTruncated;
                }
                
                // Try to include more segments while keeping ellipses on the left
                let truncated = lastComponent;
                for (let i = segments.length - 2; i >= 0; i--) {
                    const withNext = segments[i] + '::' + truncated;
                    const withEllipsis = '...' + '::' + truncated;
                    
                    if (withNext.length <= maxLength) {
                        // Can fit without ellipses
                        truncated = withNext;
                    } else if (withEllipsis.length <= maxLength) {
                        // Need ellipses but it fits
                        truncated = withEllipsis;
                        break;
                    } else {
                        // Even with ellipses it doesn't fit, use previous iteration result
                        truncated = '...' + '::' + truncated;
                        break;
                    }
                }
                
                return truncated;
            } else {
                // No "::" separators, just truncate from the left with ellipses
                return '...' + label.slice(-(maxLength - 3));
            }
        };

        // Helper function to calculate minimum width needed for a collapsed container
        const getMinCollapsedWidth = (label) => {
            if (!label || typeof label !== 'string') label = 'Unknown';
            const truncated = leftTruncateRustPath(label, true);
            // Assuming 8px per character + 16px padding
            const minWidth = Math.max(200, truncated.length * 8 + 16);
            return minWidth;
        };



        // Simplified location color generation
        const generateLocationColor = (locationId, totalLocations, palette = 'Set3') => {
            const colors = colorPalettes[palette];
            const color = colors[locationId % colors.length];
            return `${color}40`; // Add transparency
        };

        const generateLocationBorderColor = (locationId, totalLocations, palette = 'Set3') => {
            const colors = colorPalettes[palette];
            return colors[locationId % colors.length];
        };

        const elk = new ELK();

        // Helper function to generate hyperedges between containers
        const generateHyperedges = (nodes, edges) => {
            const hyperedges = [];
            const containerPairs = new Set();
            
            // Find all edges that cross container boundaries
            edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.id === edge.source);
                const targetNode = nodes.find(n => n.id === edge.target);
                
                if (sourceNode && targetNode) {
                    const sourceLocationId = sourceNode.data?.locationId;
                    const targetLocationId = targetNode.data?.locationId;
                    
                    // Only create hyperedges between different locations (containers)
                    if (sourceLocationId !== undefined && targetLocationId !== undefined && 
                        sourceLocationId !== targetLocationId) {
                        
                        const sourceContainerId = `container_${sourceLocationId}`;
                        const targetContainerId = `container_${targetLocationId}`;
                        const pairKey = `${sourceContainerId}->${targetContainerId}`;
                        
                        // Avoid duplicate hyperedges between the same container pair
                        if (!containerPairs.has(pairKey)) {
                            containerPairs.add(pairKey);
                            hyperedges.push({
                                id: `hyperedge_${sourceLocationId}_to_${targetLocationId}`,
                                sources: [sourceContainerId],
                                targets: [targetContainerId],
                            });
                        }
                    }
                }
            });
            
            return hyperedges;
        };

        // Shared edge routing logic for collapsed containers
        const routeEdgesForCollapsedContainers = (edges, collapsedLocations, childNodeIdsByParent) => {
            return edges.map(edge => {
                let newEdge = { ...edge };
                
                // Reset any previous modifications
                if (newEdge.data?.originalSource) {
                    newEdge.source = newEdge.data.originalSource;
                    newEdge.data = { ...newEdge.data };
                    delete newEdge.data.originalSource;
                }
                if (newEdge.data?.originalTarget) {
                    newEdge.target = newEdge.data.originalTarget;
                    newEdge.data = { ...newEdge.data };
                    delete newEdge.data.originalTarget;
                }
                newEdge.hidden = false;

                // Find collapsed containers containing source/target
                let sourceInCollapsedContainer = null;
                let targetInCollapsedContainer = null;
                
                for (const locationId in collapsedLocations) {
                    if (collapsedLocations[locationId]) {
                        const containerId = `container_${locationId}`;
                        const childIds = childNodeIdsByParent[containerId] || new Set();

                        if (childIds.has(newEdge.source)) {
                            sourceInCollapsedContainer = containerId;
                        }
                        if (childIds.has(newEdge.target)) {
                            targetInCollapsedContainer = containerId;
                        }
                    }
                }
                
                // Apply routing based on container states
                if (sourceInCollapsedContainer && targetInCollapsedContainer) {
                    if (sourceInCollapsedContainer === targetInCollapsedContainer) {
                        newEdge.hidden = true; // Hide internal edges
                    } else {
                        // Route container to container
                        newEdge.data = { ...newEdge.data, originalSource: newEdge.source, originalTarget: newEdge.target };
                        newEdge.source = sourceInCollapsedContainer;
                        newEdge.target = targetInCollapsedContainer;
                    }
                } else if (sourceInCollapsedContainer) {
                    newEdge.data = { ...newEdge.data, originalSource: newEdge.source };
                    newEdge.source = sourceInCollapsedContainer;
                } else if (targetInCollapsedContainer) {
                    newEdge.data = { ...newEdge.data, originalTarget: newEdge.target };
                    newEdge.target = targetInCollapsedContainer;
                }
                
                return newEdge;
            });
        };

        // Function to apply ELK layout with hierarchical grouping and hyperedges
        const applyElkLayout = async (nodes, edges, layoutType = 'layered', precomputedHyperedges = []) => {
            const elkOptions = elkLayouts[layoutType] || elkLayouts.layered;
            
            // Group nodes by location first
            const locationGroups = new Map();
            const orphanNodes = [];
            
            nodes.forEach(node => {
                const nodeLocationId = node.data?.locationId;
                if (nodeLocationId !== null && nodeLocationId !== undefined) {
                    if (!locationGroups.has(nodeLocationId)) {
                        locationGroups.set(nodeLocationId, []);
                    }
                    locationGroups.get(nodeLocationId).push(node);
                } else {
                    orphanNodes.push(node);
                }
            });
            
            // Create hierarchical ELK structure with proper container spacing
            const elkChildren = [];
            
            // Process each location as a separate container
            for (const [locationId, locationNodes] of locationGroups) {
                const elkNodes = locationNodes.map(node => {
                    const actualNode = nodes.find(n => n.id === node.id);
                    const nodeWidth = actualNode?.style?.width ? 
                        parseFloat(actualNode.style.width.toString().replace('px', '')) : 200;
                    const nodeHeight = actualNode?.style?.height ? 
                        parseFloat(actualNode.style.height.toString().replace('px', '')) : 60;
                        
                    return {
                        id: node.id,
                        width: nodeWidth,
                        height: nodeHeight,
                    };
                });

                const elkEdgesInLocation = edges.filter(edge => {
                    const sourceInLocation = locationNodes.some(n => n.id === edge.source);
                    const targetInLocation = locationNodes.some(n => n.id === edge.target);
                    return sourceInLocation && targetInLocation;
                }).map(edge => ({
                    id: edge.id,
                    sources: [edge.source],
                    targets: [edge.target],
                }));

                // Use default container dimensions for ELK layout
                const containerWidth = 400;
                const containerHeight = 300;

                elkChildren.push({
                    id: `container_${locationId}`,
                    width: containerWidth,
                    height: containerHeight,
                    layoutOptions: {
                        ...elkOptions,
                        'elk.padding': '[top=40,left=20,bottom=20,right=20]',
                        'elk.spacing.nodeNode': 60,
                    },
                    children: elkNodes,
                    edges: elkEdgesInLocation,
                });
            }
            
            // Add orphan nodes as top-level nodes with actual dimensions
            orphanNodes.forEach(node => {
                const actualNode = nodes.find(n => n.id === node.id);
                const nodeWidth = actualNode?.style?.width ? 
                    parseFloat(actualNode.style.width.toString().replace('px', '')) : 200;
                const nodeHeight = actualNode?.style?.height ? 
                    parseFloat(actualNode.style.height.toString().replace('px', '')) : 60;
                    
                elkChildren.push({
                    id: node.id,
                    width: nodeWidth,
                    height: nodeHeight,
                });
            });

            // Use precomputed hyperedges if available, otherwise generate them
            const hyperedges = precomputedHyperedges.length > 0 ? precomputedHyperedges : generateHyperedges(nodes, edges);
            
            const elkGraph = {
                id: 'root',
                layoutOptions: {
                    ...elkOptions,
                    'elk.spacing.nodeNode': 150,
                    'elk.spacing.componentComponent': 100,
                    'elk.layered.spacing.nodeNodeBetweenLayers': 150,
                },
                children: elkChildren,
                edges: hyperedges, // Use hyperedges for container layout
            };

            try {
                const layoutedGraph = await elk.layout(elkGraph);
                
                // Apply positions from ELK layout
                const layoutedNodes = nodes.map((node) => {
                    // Find the node in the layout result
                    let elkNode = null;
                    let containerOffset = { x: 0, y: 0 };
                    
                    // Look for the node in containers first
                    for (const container of layoutedGraph.children || []) {
                        if (container.children) {
                            const foundNode = container.children.find(n => n.id === node.id);
                            if (foundNode) {
                                elkNode = foundNode;
                                containerOffset = { x: container.x || 0, y: container.y || 0 };
                                break;
                            }
                        }
                    }
                    
                    // If not found in containers, look at top level
                    if (!elkNode) {
                        elkNode = layoutedGraph.children?.find(n => n.id === node.id);
                    }
                    
                    return {
                        ...node,
                        position: {
                            x: elkNode ? (elkNode.x || 0) + containerOffset.x : Math.random() * 500,
                            y: elkNode ? (elkNode.y || 0) + containerOffset.y : Math.random() * 500,
                        },
                    };
                });

                return layoutedNodes;
            } catch (error) {
                console.error('ELK layout failed:', error);
                return nodes; // Fallback to original positions
            }
        };

        // Helper function to create a container for a location
        const createLocationContainer = (location, locationNodes, currentPalette) => {
            // Calculate actual bounds based on real node dimensions
            const bounds = locationNodes.reduce((acc, node) => {
                // Get actual node dimensions from style or use defaults
                const nodeWidth = node.style?.width ? 
                    parseFloat(node.style.width.toString().replace('px', '')) : 200;
                const nodeHeight = node.style?.height ? 
                    parseFloat(node.style.height.toString().replace('px', '')) : 60;
                
                const nodeRight = node.position.x + nodeWidth;
                const nodeBottom = node.position.y + nodeHeight;
                
                return {
                    minX: Math.min(acc.minX, node.position.x),
                    minY: Math.min(acc.minY, node.position.y),
                    maxX: Math.max(acc.maxX, nodeRight),
                    maxY: Math.max(acc.maxY, nodeBottom)
                };
            }, {
                minX: locationNodes[0]?.position.x || 0,
                minY: locationNodes[0]?.position.y || 0,
                maxX: locationNodes[0]?.position.x || 0,
                maxY: locationNodes[0]?.position.y || 0
            });
            
            const padding = 30;
            const containerX = bounds.minX - padding;
            const containerY = bounds.minY - padding - 30; // Extra space for label
            
            const backgroundColor = generateLocationColor(location.id, 1, currentPalette);
            const borderColor = generateLocationBorderColor(location.id, 1, currentPalette);
            
            return {
                id: `container_${location.id}`,
                type: 'default',
                position: { x: containerX, y: containerY },
                className: 'container-node',
                style: {
                    width: bounds.maxX - bounds.minX + 2 * padding,
                    height: bounds.maxY - bounds.minY + 2 * padding + 30, // Extra 30px for label
                    backgroundColor: backgroundColor,
                    border: `2px solid ${borderColor}`,
                    borderRadius: '8px',
                    cursor: 'pointer',
                    zIndex: 1,
                },
                data: { 
                    label: location.label,
                    isContainer: true
                },
                draggable: true,
            };
        };

        // Helper function to create child nodes for a container
        const createChildNodes = (locationNodes, containerId, containerPosition) => {
            return locationNodes.map(node => ({
                ...node,
                parentNode: containerId,
                extent: 'parent',
                position: {
                    x: node.position.x - containerPosition.x,
                    y: node.position.y - containerPosition.y
                }
            }));
        };

        // STEP 2: Smart container layout using ELK with position preservation and hyperedges
        const layoutContainersWithELK = async (containerNodes, allNodes, allEdges, changedContainerId = null, precomputedHyperedges = []) => {
            if (containerNodes.length === 0) return containerNodes;
            
            // Use precomputed hyperedges if available, otherwise generate them
            const hyperedges = precomputedHyperedges.length > 0 ? precomputedHyperedges : generateHyperedges(allNodes, allEdges);
            
            // Prepare ELK layout for containers only
            const elkContainers = containerNodes.map(container => {
                const width = parseFloat(container.style?.width?.toString().replace('px', '')) || 400;
                const height = parseFloat(container.style?.height?.toString().replace('px', '')) || 300;
                
                const elkContainer = {
                    id: container.id,
                    width: width,
                    height: height,
                };
                
                // If this container hasn't changed, COMPLETELY FIX its position
                if (changedContainerId && container.id !== changedContainerId) {
                    elkContainer.x = container.position.x;
                    elkContainer.y = container.position.y;
                    // Use ELK's position fixing to completely lock this container in place
                    elkContainer.layoutOptions = {
                        'elk.position.x': container.position.x.toString(),
                        'elk.position.y': container.position.y.toString(),
                        'elk.nodeSize.constraints': 'FIXED_POS', // This fixes the position completely
                        'elk.nodeSize.options': 'FIXED_POS'
                    };
                } else {
                    // For the changed container, allow ELK to position it freely
                    elkContainer.layoutOptions = {
                        'elk.nodeSize.constraints': '',
                        'elk.nodeSize.options': ''
                    };
                }
                
                return elkContainer;
            });
            
            // Create a simple ELK graph for container layout with hyperedges
            const elkGraph = {
                id: 'container_root',
                layoutOptions: {
                    'elk.algorithm': 'org.eclipse.elk.layered', // Use layered for better hyperedge handling
                    'elk.direction': 'RIGHT',
                    'elk.spacing.nodeNode': 100,
                    'elk.spacing.componentComponent': 100,
                    'elk.layered.spacing.nodeNodeBetweenLayers': 150,
                    // More iterations for the changed container to find a good position
                    'elk.layered.thoroughness': changedContainerId ? 10 : 5,
                    // Respect fixed positions
                    'elk.partitioning.activate': 'false'
                },
                children: elkContainers,
                edges: hyperedges // Use hyperedges for better container layout
            };
            
            try {
                const layoutedGraph = await elk.layout(elkGraph);
                
                // Apply the new positions back to containers
                return containerNodes.map(container => {
                    const elkContainer = layoutedGraph.children?.find(c => c.id === container.id);
                    if (elkContainer) {
                        // Only update position if this was the changed container OR if no specific container was changed
                        if (!changedContainerId || container.id === changedContainerId) {
                            return {
                                ...container,
                                position: {
                                    x: elkContainer.x || container.position.x,
                                    y: elkContainer.y || container.position.y
                                }
                            };
                        } else {
                            // Keep the original position for unchanged containers
                            return container;
                        }
                    }
                    return container;
                });
            } catch (error) {
                console.error('Container layout with ELK failed:', error);
                return containerNodes; // Fallback to original positions
            }
        };


        // Helper function to determine if graph should be auto-collapsed
        const shouldAutoCollapse = (locationContainers) => {
            if (locationContainers.length === 0) return false;
            
            const minLegibleZoom = 0.5;
            const graphWidth = Math.max(...locationContainers.map(c => c.position.x + parseFloat(c.style.width.toString().replace('px', '')) || 400)) - 
                             Math.min(...locationContainers.map(c => c.position.x));
            const graphHeight = Math.max(...locationContainers.map(c => c.position.y + parseFloat(c.style.height.toString().replace('px', '')) || 300)) - 
                              Math.min(...locationContainers.map(c => c.position.y));
                              
            const wouldBeZoomX = (window.innerWidth * 0.85) / graphWidth;
            const wouldBeZoomY = (window.innerHeight * 0.85) / graphHeight;
            const wouldBeZoom = Math.min(wouldBeZoomX, wouldBeZoomY);
            
            return wouldBeZoom < minLegibleZoom;
        };

        // Greedy expansion algorithm for small graphs
        const determineInitialContainerStates = (allContainers, locationNodes) => {
            const minLegibleZoom = 0.4; // Relaxed threshold to allow more expansion
            const viewWidth = window.innerWidth * 0.85;
            const viewHeight = window.innerHeight * 0.85;
            
            // Create container info with areas for sorting
            const containerInfo = allContainers.map(container => {
                const locationId = container.id.replace('container_', '');
                const nodes = locationNodes[locationId] || [];
                
                // Calculate area based on number of nodes and their layout
                const nodeCount = nodes.length;
                const estimatedArea = nodeCount * 200 * 60; // rough node area estimate
                
                const expandedWidth = parseFloat(container.style.width.toString().replace('px', '')) || 400;
                const expandedHeight = parseFloat(container.style.height.toString().replace('px', '')) || 300;
                
                return {
                    container,
                    locationId,
                    nodeCount,
                    estimatedArea,
                    expandedWidth,
                    expandedHeight,
                    collapsedWidth: getMinCollapsedWidth(container.data.label),
                    collapsedHeight: 50
                };
            });
            
            // Sort by area (smallest first for greedy expansion)
            containerInfo.sort((a, b) => a.estimatedArea - b.estimatedArea);
            
            const finalStates = {};
            const expandedContainers = [];
            
            // Greedy expansion algorithm
            for (const info of containerInfo) {
                // Create a test scenario where this container is expanded
                const testContainers = allContainers.map(c => {
                    const cInfo = containerInfo.find(ci => ci.container.id === c.id);
                    const isExpanded = expandedContainers.includes(cInfo.locationId) || 
                                     cInfo.locationId === info.locationId;
                    
                    return {
                        ...c,
                        style: {
                            ...c.style,
                            width: isExpanded ? cInfo.expandedWidth : cInfo.collapsedWidth,
                            height: isExpanded ? cInfo.expandedHeight : cInfo.collapsedHeight
                        }
                    };
                });
                
                // Calculate bounds with this expansion
                const bounds = testContainers.reduce((acc, c) => {
                    const width = parseFloat(c.style.width.toString().replace('px', '')) || 400;
                    const height = parseFloat(c.style.height.toString().replace('px', '')) || 300;
                    const right = c.position.x + width;
                    const bottom = c.position.y + height;
                    
                    return {
                        minX: Math.min(acc.minX, c.position.x),
                        minY: Math.min(acc.minY, c.position.y),
                        maxX: Math.max(acc.maxX, right),
                        maxY: Math.max(acc.maxY, bottom)
                    };
                }, {
                    minX: testContainers[0]?.position.x || 0,
                    minY: testContainers[0]?.position.y || 0,
                    maxX: testContainers[0]?.position.x || 0,
                    maxY: testContainers[0]?.position.y || 0
                });
                
                const graphWidth = bounds.maxX - bounds.minX;
                const graphHeight = bounds.maxY - bounds.minY;
                
                const wouldBeZoomX = viewWidth / graphWidth;
                const wouldBeZoomY = viewHeight / graphHeight;
                const wouldBeZoom = Math.min(wouldBeZoomX, wouldBeZoomY);
                
                if (wouldBeZoom >= minLegibleZoom) {
                    // Safe to expand this container
                    expandedContainers.push(info.locationId);
                    finalStates[info.locationId] = false; // false = expanded
                } else {
                    // Would make zoom too small, keep collapsed
                    finalStates[info.locationId] = true; // true = collapsed
                }
            }
            
            return finalStates;
        };

        function UnifiedLegend({ palette }) {
            const nodeTypes = ['Source', 'Transform', 'Join', 'Aggregation', 'Network', 'Sink', 'Tee'];
            const locations = graphData.locations || [];

            return (
                <div className="unified-legend">
                    <div className="legend-section">
                        <h4>Node Types</h4>
                        {nodeTypes.map(type => {
                            const colors = generateNodeColors(type, palette);
                            return (
                                <div key={type} className="legend-item">
                                    <div className="legend-color" style={{ background: colors.gradient, borderColor: colors.border }}></div>
                                    {type}
                                </div>
                            );
                        })}
                    </div>
                    {locations.length > 0 && (
                        <div className="legend-section">
                            <h4>Locations</h4>
                            {locations.map(location => {
                                const backgroundColor = generateLocationColor(location.id, locations.length, palette);
                                const borderColor = generateLocationBorderColor(location.id, locations.length, palette);
                                return (
                                    <div key={location.id} className="legend-item">
                                        <div className="location-legend-color" style={{ backgroundColor, borderColor }}></div>
                                        {location.label}
                                    </div>
                                );
                            })}
                        </div>
                    )}
                </div>
            );
        }
        
        function HydroGraph() {
            const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
            const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);
            const [currentLayout, setCurrentLayout] = React.useState('mrtree');
            const [currentPalette, setCurrentPalette] = React.useState('Set3');
            const [useShortLabels, setUseShortLabels] = React.useState(true);
            const [allContainersCollapsed, setAllContainersCollapsed] = React.useState(false);
            
            const [collapsedLocations, setCollapsedLocations] = React.useState({});
            const [originalNodeDimensions, setOriginalNodeDimensions] = React.useState({});
            const [lastChangedContainer, setLastChangedContainer] = React.useState(null);
            const [hyperedges, setHyperedges] = React.useState([]);

            const onConnect = useCallback((params) => setEdges((eds) => addEdge(params, eds)), []);
            
            const fitView = useCallback(() => {
                const reactFlowInstance = window.reactFlowInstance;
                if (reactFlowInstance) {
                    // Check if most containers are currently collapsed
                    const currentNodes = reactFlowInstance.getNodes();
                    const containerNodes = currentNodes.filter(node => node.data?.isContainer);
                    const collapsedContainers = containerNodes.filter(node => {
                        const width = parseFloat(node.style?.width?.toString().replace('px', '')) || 400;
                        // A container is considered collapsed if it's smaller than the normal expanded size
                        // Collapsed containers are typically 200-300px wide, expanded are 400px+
                        return width <= 350; 
                    });
                    
                    const mostlyCollapsed = collapsedContainers.length > containerNodes.length / 2;
                    
                    if (mostlyCollapsed) {
                        // Most containers collapsed - use wider zoom range
                        reactFlowInstance.fitView({ 
                            padding: 0.2, 
                            maxZoom: 0.5, 
                            minZoom: 0.02 
                        });
                    } else {
                        // Mostly expanded - use closer zoom
                        reactFlowInstance.fitView({ 
                            padding: 0.1, 
                            maxZoom: 1.0, 
                            minZoom: 0.2 
                        });
                    }
                }
            }, []);

            const toggleAllContainers = useCallback(() => {
                const reactFlowInstance = window.reactFlowInstance;
                if (!reactFlowInstance) return;
                
                const currentNodes = reactFlowInstance.getNodes();
                const containerNodes = currentNodes.filter(node => node.data?.isContainer);
                const newCollapsedState = {};
                const newOriginalDimensions = {};
                
                const shouldCollapse = !allContainersCollapsed;
                
                if (shouldCollapse) {
                    // Collapse all containers
                    containerNodes.forEach(container => {
                        const locationId = container.id.replace('container_', '');
                        
                        // Store original dimensions if not already stored
                        if (!originalNodeDimensions[locationId]) {
                            const width = parseFloat(container.style?.width?.toString().replace('px', '')) || 400;
                            const height = parseFloat(container.style?.height?.toString().replace('px', '')) || 300;
                            newOriginalDimensions[locationId] = { width, height };
                        } else {
                            newOriginalDimensions[locationId] = originalNodeDimensions[locationId];
                        }
                        
                        newCollapsedState[locationId] = true;
                    });
                    
                    const updatedNodes = currentNodes.map(node => {
                        if (node.data?.isContainer) {
                            // Store original label and set truncated label for collapsed state
                            const originalLabel = node.data.originalLabel || node.data.label;
                            const collapsedWidth = getMinCollapsedWidth(originalLabel);
                            return { 
                                ...node, 
                                style: { ...node.style, width: collapsedWidth + 'px', height: '50px' },
                                data: {
                                    ...node.data,
                                    originalLabel: originalLabel,
                                    label: leftTruncateRustPath(originalLabel, true)
                                }
                            };
                        } else if (node.parentNode) {
                            return { ...node, hidden: true };
                        }
                        return node;
                    });
                    
                    setNodes(updatedNodes);
                    
                    // Fit view after collapse
                    setTimeout(() => {
                        reactFlowInstance.fitView({ padding: 0.2, maxZoom: 0.5, minZoom: 0.02 });
                    }, 100);
                } else {
                    // Expand all containers
                    containerNodes.forEach(container => {
                        const locationId = container.id.replace('container_', '');
                        newCollapsedState[locationId] = false;
                        
                        // Keep existing original dimensions
                        if (originalNodeDimensions[locationId]) {
                            newOriginalDimensions[locationId] = originalNodeDimensions[locationId];
                        }
                    });
                    
                    const updatedNodes = currentNodes.map(node => {
                        if (node.data?.isContainer) {
                            const locationId = node.id.replace('container_', '');
                            const originalDims = originalNodeDimensions[locationId];
                            const originalLabel = node.data.originalLabel || node.data.label;
                            
                            if (originalDims) {
                                return { 
                                    ...node, 
                                    style: { ...node.style, width: originalDims.width, height: originalDims.height },
                                    data: { 
                                        ...node.data, 
                                        label: originalLabel
                                    }
                                };
                            } else {
                                // Default expanded size if no stored dimensions
                                return { 
                                    ...node, 
                                    style: { ...node.style, width: 400, height: 300 },
                                    data: { 
                                        ...node.data, 
                                        label: originalLabel
                                    }
                                };
                            }
                        } else if (node.parentNode) {
                            return { ...node, hidden: false };
                        }
                        return node;
                    });
                    
                    setNodes(updatedNodes);
                    
                    // Fit view after expand
                    setTimeout(() => {
                        reactFlowInstance.fitView({ padding: 0.1, maxZoom: 1.0, minZoom: 0.2 });
                    }, 100);
                }
                
                // Update states
                setCollapsedLocations(newCollapsedState);
                setOriginalNodeDimensions(prev => ({ ...prev, ...newOriginalDimensions }));
                setAllContainersCollapsed(shouldCollapse);
            }, [allContainersCollapsed, originalNodeDimensions, setCollapsedLocations, setOriginalNodeDimensions, setNodes]);

            const onNodeClick = useCallback((event, node) => {
                if (node.data?.isContainer) {
                    const locationId = node.id.replace('container_', '');
                    
                    // Track which container is being changed
                    setLastChangedContainer(node.id);
                    
                    setCollapsedLocations(prev => {
                        const isCollapsing = !prev[locationId];
                        if (isCollapsing) {
                            setOriginalNodeDimensions(dims => ({
                                ...dims,
                                [locationId]: { width: node.style.width, height: node.style.height }
                            }));
                        }
                        
                        const newState = { ...prev, [locationId]: isCollapsing };
                        
                        // Update allContainersCollapsed state
                        setTimeout(() => {
                            const allCollapsed = Object.values(newState).every(collapsed => collapsed);
                            setAllContainersCollapsed(allCollapsed);
                        }, 0);
                        
                        return newState;
                    });
                } else if (node.data?.shortLabel && node.data?.fullLabel) {
                    // Handle regular node click to toggle between short and full label
                    setNodes(currentNodes => {
                        return currentNodes.map(n => {
                            if (n.id === node.id) {
                                const isCurrentlyExpanded = n.data.expanded || false;
                                const newLabel = isCurrentlyExpanded ? n.data.shortLabel : n.data.fullLabel;
                                
                                return {
                                    ...n,
                                    data: {
                                        ...n.data,
                                        label: newLabel,
                                        expanded: !isCurrentlyExpanded
                                    }
                                };
                            }
                            return n;
                        });
                    });
                }
            }, [collapsedLocations, setNodes]);

            React.useEffect(() => {
                // Update node visibility and container sizes based on collapsed state
                setNodes(currentNodes => {
                    const updatedNodes = currentNodes.map(n => {
                        if (n.data?.isContainer) {
                            const locationId = n.id.replace('container_', '');
                            const isCollapsed = collapsedLocations[locationId];
                            if (typeof isCollapsed !== 'boolean') return n;

                            // Get the original label for this container
                            let originalLabel = n.data.label;
                            
                            // If this container has a stored original label, use that
                            if (n.data.originalLabel) {
                                originalLabel = n.data.originalLabel;
                            }

                            if (isCollapsed) {
                                return { 
                                    ...n, 
                                    style: { 
                                        ...n.style, 
                                        width: getMinCollapsedWidth(originalLabel), 
                                        height: 50 
                                    },
                                    data: { 
                                        ...n.data, 
                                        originalLabel: originalLabel, // Store original label
                                        label: leftTruncateRustPath(originalLabel, true) 
                                    }
                                };
                            } else {
                                // When expanding, use stored dimensions if available, otherwise use default size
                                const originalDims = originalNodeDimensions[locationId];
                                if (originalDims) {
                                    return { 
                                        ...n, 
                                        style: { ...n.style, width: originalDims.width, height: originalDims.height },
                                        data: { 
                                            ...n.data, 
                                            label: originalLabel // Restore original label
                                        }
                                    };
                                } else {
                                    // Default expanded size if no stored dimensions
                                    return { 
                                        ...n, 
                                        style: { ...n.style, width: 400, height: 300 },
                                        data: { 
                                            ...n.data, 
                                            label: originalLabel // Restore original label
                                        }
                                    };
                                }
                            }
                        } else if (n.parentNode) {
                            const parentLocationId = n.parentNode.replace('container_', '');
                            const isParentCollapsed = collapsedLocations[parentLocationId];
                            if (typeof isParentCollapsed === 'boolean') {
                                return { ...n, hidden: isParentCollapsed };
                            }
                        }
                        return n;
                    });

                    // Update edges using the shared routing function
                    setEdges(currentEdges => {
                        const childNodeIdsByParent = {};
                        updatedNodes.forEach(n => {
                            if (n.parentNode) {
                                if (!childNodeIdsByParent[n.parentNode]) {
                                    childNodeIdsByParent[n.parentNode] = new Set();
                                }
                                childNodeIdsByParent[n.parentNode].add(n.id);
                            }
                        });

                        return routeEdgesForCollapsedContainers(currentEdges, collapsedLocations, childNodeIdsByParent);
                    });

                    return updatedNodes;
                });
                
                // STEP 2: Use ELK to intelligently reposition containers after expand/collapse
                setTimeout(async () => {
                    const reactFlowInstance = window.reactFlowInstance;
                    if (reactFlowInstance) {
                        try {
                            const currentNodes = reactFlowInstance.getNodes();
                            const containerNodes = currentNodes.filter(node => node.data?.isContainer);
                            
                            if (containerNodes.length > 0) {
                                // Use the tracked changed container ID for better layout preservation
                                const changedContainerId = lastChangedContainer;
                                
                                // Reconstruct original internal nodes for hyperedge generation
                                // Get all child nodes (both hidden and visible) and treat them as the internal nodes
                                const internalNodes = currentNodes.filter(node => 
                                    !node.data?.isContainer && node.parentNode
                                );
                                
                                // Use original edges (not the routed container edges) for hyperedge generation
                                const originalEdges = initialEdges;
                                
                                // Use ELK to layout containers while preserving positions of unchanged ones
                                const layoutedContainers = await layoutContainersWithELK(containerNodes, internalNodes, originalEdges, changedContainerId, hyperedges);
                                
                                // Update all nodes with the new container positions
                                const updatedNodes = currentNodes.map(node => {
                                    if (node.data?.isContainer) {
                                        const layoutedContainer = layoutedContainers.find(c => c.id === node.id);
                                        return layoutedContainer || node;
                                    }
                                    return node;
                                });
                                
                                setNodes(updatedNodes);
                                
                                // Clear the changed container tracking
                                setLastChangedContainer(null);
                                
                                // Re-fit view after repositioning
                                setTimeout(() => {
                                    reactFlowInstance.fitView({ padding: 0.1, maxZoom: 1.0, minZoom: 0.01 });
                                }, 100);
                            }
                        } catch (error) {
                            console.error('Error re-layouting containers with ELK:', error);
                        }
                    }
                }, 300);
            }, [collapsedLocations, originalNodeDimensions, lastChangedContainer]);
            
            // Apply node colors based on palette
            const applyNodePalette = useCallback((nodes, palette) => {
                return nodes.map(node => {
                    if (node.data?.isContainer) return node;
                    
                    const nodeType = node.data?.nodeType || 'Transform';
                    const colors = generateNodeColors(nodeType, palette);
                    
                    return {
                        ...node,
                        style: {
                            ...node.style,
                            background: colors.gradient,
                            border: `1px solid ${colors.border}`,
                            // Remove the fixed gradients that were in the data
                            '--node-color-primary': colors.primary,
                            '--node-color-secondary': colors.secondary,
                            '--node-border-color': colors.border,
                        }
                    };
                });
            }, []);
            
            const onInit = useCallback(async (reactFlowInstance) => {
                window.reactFlowInstance = reactFlowInstance;
                
                // Compute hyperedges once from the initial graph structure
                const computedHyperedges = generateHyperedges(initialNodes, initialEdges);
                setHyperedges(computedHyperedges);
                
                // Apply ELK layout to get proper positions
                const layoutedNodes = await applyElkLayout(initialNodes, initialEdges, currentLayout, computedHyperedges);
                
                // Group nodes by location for hierarchical display
                const locationContainers = [];
                const childNodes = [];
                
                if (graphData.locations && graphData.locations.length > 0) {
                    graphData.locations.forEach(location => {
                        // Find nodes in this location
                        const locationNodes = layoutedNodes.filter(node => {
                            const nodeLocationId = node.data?.locationId;
                            return nodeLocationId !== null && 
                                   nodeLocationId !== undefined && 
                                   nodeLocationId.toString() === location.id.toString();
                        });
                        
                        if (locationNodes.length > 0) {
                            // Create container using helper function
                            const container = createLocationContainer(location, locationNodes, currentPalette);
                            locationContainers.push(container);
                            
                            // Create child nodes using helper function
                            const children = createChildNodes(locationNodes, container.id, container.position);
                            childNodes.push(...children);
                        }
                    });
                    
                    // Handle orphan nodes (not in any location) - group them into a grey container
                    const orphanNodes = layoutedNodes.filter(node => {
                        const nodeLocationId = node.data?.locationId;
                        if (nodeLocationId === null || nodeLocationId === undefined) return true;
                        
                        return !graphData.locations.some(loc => 
                            loc.id.toString() === nodeLocationId.toString()
                        );
                    });
                    
                    if (orphanNodes.length > 0) {
                        // Create orphan container using similar logic
                        const orphanLocation = { id: 'null', label: 'Internal/Unassigned' };
                        const orphanContainer = createLocationContainer(orphanLocation, orphanNodes, currentPalette);
                        
                        // Override styles for orphan container
                        orphanContainer.id = 'container_null';
                        orphanContainer.style.backgroundColor = 'rgba(200, 200, 200, 0.2)';
                        orphanContainer.style.border = '2px solid #999999';
                        
                        locationContainers.push(orphanContainer);
                        
                        const orphanChildren = createChildNodes(orphanNodes, orphanContainer.id, orphanContainer.position);
                        childNodes.push(...orphanChildren);
                    }
                } else {
                    // No locations defined, use all nodes as-is
                    childNodes.push(...layoutedNodes);
                }
                
                
                // Apply palette colors to nodes
                const coloredChildNodes = applyNodePalette(childNodes, currentPalette);
                
                // Combine containers and child nodes
                const allElements = [...locationContainers, ...coloredChildNodes];
                
                // STEP 1: Use greedy expansion algorithm to determine initial container states
                const locationNodesByLocationId = {};
                graphData.locations?.forEach(location => {
                    const locationNodes = layoutedNodes.filter(node => {
                        const nodeLocationId = node.data?.locationId;
                        return nodeLocationId !== null && 
                               nodeLocationId !== undefined && 
                               nodeLocationId.toString() === location.id.toString();
                    });
                    if (locationNodes.length > 0) {
                        locationNodesByLocationId[location.id.toString()] = locationNodes;
                    }
                });
                
                // Add orphan nodes to location mapping
                const orphanNodes = layoutedNodes.filter(node => {
                    const nodeLocationId = node.data?.locationId;
                    if (nodeLocationId === null || nodeLocationId === undefined) return true;
                    return !graphData.locations.some(loc => 
                        loc.id.toString() === nodeLocationId.toString()
                    );
                });
                if (orphanNodes.length > 0) {
                    locationNodesByLocationId['null'] = orphanNodes;
                }
                
                // Determine initial states using greedy expansion
                const initialCollapsedState = determineInitialContainerStates(locationContainers, locationNodesByLocationId);
                const initialOriginalDimensions = {};
                
                // Apply the determined states to containers
                locationContainers.forEach(container => {
                    const width = parseFloat(container.style.width.toString().replace('px', '')) || 400;
                    const height = parseFloat(container.style.height.toString().replace('px', '')) || 300;
                    const locationId = container.id.replace('container_', '');
                    
                    // Store original dimensions
                    initialOriginalDimensions[locationId] = { width, height };
                    
                    const isCollapsed = initialCollapsedState[locationId];
                    
                    if (isCollapsed) {
                        // Store original label and modify container to collapsed state with truncated label
                        const originalLabel = container.data.label;
                        const collapsedWidth = getMinCollapsedWidth(originalLabel);
                        container.style.width = collapsedWidth + 'px';
                        container.style.height = '50px';
                        container.data = {
                            ...container.data,
                            originalLabel: originalLabel,
                            label: leftTruncateRustPath(originalLabel, true)
                        };
                        
                        // Hide child nodes for collapsed containers
                        allElements.forEach(element => {
                            if (element.parentNode === container.id) {
                                element.hidden = true;
                            }
                        });
                    }
                    // If not collapsed, leave container and children as-is (expanded)
                });
                
                // Set initial states
                setCollapsedLocations(initialCollapsedState);
                setOriginalNodeDimensions(initialOriginalDimensions);
                
                // Update allContainersCollapsed state based on initial container states
                const allCollapsed = Object.values(initialCollapsedState).every(collapsed => collapsed);
                setAllContainersCollapsed(allCollapsed);
                
                setNodes(allElements);
                setEdges(initialEdges);
                
                // Apply initial label state to ensure consistency with useShortLabels
                setTimeout(() => {
                    setNodes(currentNodes => {
                        return currentNodes.map(node => {
                            // For container nodes, handle label toggling
                            if (node.data?.isContainer) {
                                const originalLabel = node.data.originalLabel || node.data.label;
                                const newLabel = useShortLabels 
                                    ? leftTruncateRustPath(originalLabel, true)
                                    : originalLabel;
                                
                                return {
                                    ...node,
                                    data: {
                                        ...node.data,
                                        label: newLabel,
                                        originalLabel: originalLabel
                                    }
                                };
                            }
                            
                            // For regular nodes, use shortLabel/fullLabel
                            if (node.data?.shortLabel && node.data?.fullLabel) {
                                return {
                                    ...node,
                                    data: {
                                        ...node.data,
                                        label: useShortLabels ? node.data.shortLabel : node.data.fullLabel
                                    }
                                };
                            }
                            
                            return node;
                        });
                    });
                }, 10); // Small delay to ensure nodes are set
                
                // Apply initial edge routing based on determined container states
                setTimeout(() => {
                    setEdges(currentEdges => {
                        const childNodeIdsByParent = {};
                        allElements.forEach(n => {
                            if (n.parentNode) {
                                if (!childNodeIdsByParent[n.parentNode]) {
                                    childNodeIdsByParent[n.parentNode] = new Set();
                                }
                                childNodeIdsByParent[n.parentNode].add(n.id);
                            }
                        });
                        return routeEdgesForCollapsedContainers(currentEdges, initialCollapsedState, childNodeIdsByParent);
                    });
                }, 50);
                
                // Adaptive fit view based on whether containers are mostly expanded or collapsed
                const expandedCount = Object.values(initialCollapsedState).filter(collapsed => !collapsed).length;
                const totalCount = Object.keys(initialCollapsedState).length;
                const mostlyExpanded = expandedCount > totalCount / 2;
                
                if (mostlyExpanded) {
                    // Most containers expanded - use closer zoom for details
                    reactFlowInstance.fitView({ padding: 0.1, maxZoom: 1.0, minZoom: 0.2, duration: 300 });
                } else {
                    // Most containers collapsed - use wider zoom
                    reactFlowInstance.fitView({ padding: 0.2, maxZoom: 0.5, minZoom: 0.02, duration: 300 });
                }
            }, [setNodes, setEdges, currentLayout, currentPalette, applyNodePalette, setHyperedges, useShortLabels]);

            // Apply elk layout with selected algorithm
            const applyLayout = useCallback(async (layoutType = currentLayout) => {
                // Only layout the actual graph nodes, not containers
                const actualNodes = nodes.filter(node => !node.data?.isContainer);
                
                if (actualNodes.length === 0) return;
                
                const layoutedNodes = await applyElkLayout(actualNodes, edges, layoutType, hyperedges);
                
                // Create new containers and child relationships using helper functions
                const locationContainers = [];
                const childNodes = [];
                
                if (graphData.locations && graphData.locations.length > 0) {
                    graphData.locations.forEach(location => {
                        const locationNodes = layoutedNodes.filter(node => {
                            const nodeLocationId = node.data?.locationId;
                            return nodeLocationId !== null && 
                                   nodeLocationId !== undefined && 
                                   nodeLocationId.toString() === location.id.toString();
                        });
                        
                        if (locationNodes.length > 0) {
                            const container = createLocationContainer(location, locationNodes, currentPalette);
                            
                            // Check if this container is currently collapsed
                            const locationId = location.id.toString();
                            const isCollapsed = collapsedLocations[locationId];
                            
                            // ALWAYS update the original dimensions with the new layout's correct size
                            // This ensures that when collapsed containers are later expanded, they use
                            // the correct dimensions for the current layout, not the old layout
                            setOriginalNodeDimensions(prev => ({
                                ...prev,
                                [locationId]: { 
                                    width: container.style.width, 
                                    height: container.style.height 
                                }
                            }));
                            
                            if (isCollapsed) {
                                // If collapsed, preserve the collapsed dimensions and label for display
                                const existingContainer = nodes.find(n => n.id === container.id);
                                if (existingContainer) {
                                    container.style.width = existingContainer.style.width;
                                    container.style.height = existingContainer.style.height;
                                    container.data = {
                                        ...container.data,
                                        originalLabel: existingContainer.data.originalLabel || container.data.label,
                                        label: existingContainer.data.label
                                    };
                                } else {
                                    // Fallback to standard collapsed sizing
                                    const originalLabel = container.data.label;
                                    const collapsedWidth = getMinCollapsedWidth(originalLabel);
                                    container.style.width = collapsedWidth + 'px';
                                    container.style.height = '50px';
                                    container.data = {
                                        ...container.data,
                                        originalLabel: originalLabel,
                                        label: leftTruncateRustPath(originalLabel, true)
                                    };
                                }
                            }
                            
                            locationContainers.push(container);
                            
                            const children = createChildNodes(locationNodes, container.id, container.position);
                            // Hide children if container is collapsed
                            const visibleChildren = children.map(child => ({
                                ...child,
                                hidden: isCollapsed
                            }));
                            childNodes.push(...visibleChildren);
                        }
                    });
                    
                    // Handle orphan nodes
                    const orphanNodes = layoutedNodes.filter(node => {
                        const nodeLocationId = node.data?.locationId;
                        if (nodeLocationId === null || nodeLocationId === undefined) return true;
                        return !graphData.locations.some(loc => 
                            loc.id.toString() === nodeLocationId.toString()
                        );
                    });
                    
                    if (orphanNodes.length > 0) {
                        const orphanLocation = { id: 'null', label: 'Internal/Unassigned' };
                        const orphanContainer = createLocationContainer(orphanLocation, orphanNodes, currentPalette);
                        
                        // Override styles for orphan container
                        orphanContainer.id = 'container_null';
                        orphanContainer.style.backgroundColor = 'rgba(200, 200, 200, 0.2)';
                        orphanContainer.style.border = '2px solid #999999';
                        
                        // ALWAYS update the original dimensions for the orphan container
                        // This ensures correct sizing when expanded after layout changes
                        setOriginalNodeDimensions(prev => ({
                            ...prev,
                            'null': { 
                                width: orphanContainer.style.width, 
                                height: orphanContainer.style.height 
                            }
                        }));
                        
                        // Check if orphan container is collapsed
                        const isOrphanCollapsed = collapsedLocations['null'];
                        if (isOrphanCollapsed) {
                            const existingOrphanContainer = nodes.find(n => n.id === 'container_null');
                            if (existingOrphanContainer) {
                                orphanContainer.style.width = existingOrphanContainer.style.width;
                                orphanContainer.style.height = existingOrphanContainer.style.height;
                                orphanContainer.data = {
                                    ...orphanContainer.data,
                                    originalLabel: existingOrphanContainer.data.originalLabel || orphanContainer.data.label,
                                    label: existingOrphanContainer.data.label
                                };
                            } else {
                                const originalLabel = orphanContainer.data.label;
                                const collapsedWidth = getMinCollapsedWidth(originalLabel);
                                orphanContainer.style.width = collapsedWidth + 'px';
                                orphanContainer.style.height = '50px';
                                orphanContainer.data = {
                                    ...orphanContainer.data,
                                    originalLabel: originalLabel,
                                    label: leftTruncateRustPath(originalLabel, true)
                                };
                            }
                        }
                        
                        locationContainers.push(orphanContainer);
                        
                        const orphanChildren = createChildNodes(orphanNodes, orphanContainer.id, orphanContainer.position);
                        // Hide orphan children if container is collapsed
                        const visibleOrphanChildren = orphanChildren.map(child => ({
                            ...child,
                            hidden: isOrphanCollapsed
                        }));
                        childNodes.push(...visibleOrphanChildren);
                    }
                } else {
                    childNodes.push(...layoutedNodes);
                }
                
                // Apply palette colors and update nodes
                const coloredChildNodes = applyNodePalette(childNodes, currentPalette);
                
                // Apply global label state to all nodes
                const labelAdjustedNodes = coloredChildNodes.map(node => {
                    if (node.data?.shortLabel && node.data?.fullLabel) {
                        return {
                            ...node,
                            data: {
                                ...node.data,
                                label: useShortLabels ? node.data.shortLabel : node.data.fullLabel
                            }
                        };
                    }
                    return node;
                });
                
                // Also apply label state to containers
                const labelAdjustedContainers = locationContainers.map(container => {
                    if (container.data?.isContainer) {
                        const originalLabel = container.data.originalLabel || container.data.label;
                        const newLabel = useShortLabels 
                            ? leftTruncateRustPath(originalLabel, true)
                            : originalLabel;
                        
                        return {
                            ...container,
                            data: {
                                ...container.data,
                                label: newLabel,
                                originalLabel: originalLabel
                            }
                        };
                    }
                    return container;
                });
                
                const allElements = [...labelAdjustedContainers, ...labelAdjustedNodes];
                setNodes(allElements);
                
                // Update edges to respect current collapsed state
                setTimeout(() => {
                    setEdges(currentEdges => {
                        const childNodeIdsByParent = {};
                        allElements.forEach(n => {
                            if (n.parentNode) {
                                if (!childNodeIdsByParent[n.parentNode]) {
                                    childNodeIdsByParent[n.parentNode] = new Set();
                                }
                                childNodeIdsByParent[n.parentNode].add(n.id);
                            }
                        });
                        return routeEdgesForCollapsedContainers(currentEdges, collapsedLocations, childNodeIdsByParent);
                    });
                }, 50);
                
                // Fit view after layout change
                setTimeout(() => {
                    const reactFlowInstance = window.reactFlowInstance;
                    if (reactFlowInstance) {
                        reactFlowInstance.fitView({ padding: 0.1, maxZoom: 1.0, minZoom: 0.01 });
                    }
                }, 100);
            }, [nodes, edges, currentLayout, currentPalette, collapsedLocations, setNodes, setOriginalNodeDimensions, applyNodePalette, hyperedges, useShortLabels]);

            const toggleLabelMode = useCallback(() => {
                setUseShortLabels(prev => {
                    const newUseShortLabels = !prev;
                    
                    // Update all nodes with appropriate labels
                    setNodes(currentNodes => {
                        return currentNodes.map(node => {
                            // For container nodes, handle label toggling
                            if (node.data?.isContainer) {
                                const originalLabel = node.data.originalLabel || node.data.label;
                                const newLabel = newUseShortLabels 
                                    ? leftTruncateRustPath(originalLabel, true)
                                    : originalLabel;
                                
                                return {
                                    ...node,
                                    data: {
                                        ...node.data,
                                        label: newLabel,
                                        originalLabel: originalLabel
                                    }
                                };
                            }
                            
                            // For regular nodes, use shortLabel/fullLabel
                            if (node.data?.shortLabel && node.data?.fullLabel) {
                                return {
                                    ...node,
                                    data: {
                                        ...node.data,
                                        label: newUseShortLabels ? node.data.shortLabel : node.data.fullLabel
                                    }
                                };
                            }
                            
                            return node;
                        });
                    });
                    
                    return newUseShortLabels;
                });
            }, [setNodes]);

            const onLayoutChange = (event) => {
                const newLayout = event.target.value;
                setCurrentLayout(newLayout);
                applyLayout(newLayout);
            };

            const onPaletteChange = (event) => {
                const newPalette = event.target.value;
                setCurrentPalette(newPalette);
                
                // Re-color nodes
                const recoloredNodes = applyNodePalette(nodes, newPalette);
                
                // Re-color location containers
                const finalNodes = recoloredNodes.map(node => {
                    if (node.data?.isContainer) {
                        const locationId = node.id.split('_')[1];
                        if (locationId === 'null') {
                            return {
                                ...node,
                                style: {
                                    ...node.style,
                                    backgroundColor: 'rgba(200, 200, 200, 0.2)',
                                    border: '2px solid #999999',
                                }
                            };
                        }
                        
                        const loc = graphData.locations.find(l => l.id.toString() === locationId);
                        if (loc) {
                            const backgroundColor = generateLocationColor(loc.id, graphData.locations.length, newPalette);
                            const borderColor = generateLocationBorderColor(loc.id, graphData.locations.length, newPalette);
                            return {
                                ...node,
                                style: {
                                    ...node.style,
                                    backgroundColor: backgroundColor,
                                    border: `2px solid ${borderColor}`,
                                }
                            };
                        }
                    }
                    return node;
                });
                
                setNodes(finalNodes);
                
                // Re-color edges
                const recoloredEdges = edges.map(edge => {
                    const sourceNode = nodes.find(n => n.id === edge.source);
                    if (sourceNode) {
                        const nodeType = sourceNode.data?.nodeType || 'Transform';
                        const colors = generateNodeColors(nodeType, newPalette);
                        return {
                            ...edge,
                            style: { ...edge.style, stroke: colors.border },
                            markerEnd: { ...edge.markerEnd, color: colors.border }
                        };
                    }
                    return edge;
                });
                setEdges(recoloredEdges);
            };

            return (
                <div className="reactflow-wrapper">
                    <div className="layout-controls">
                        <select className="layout-select" value={currentLayout} onChange={onLayoutChange}>
                            {Object.keys(elkLayouts).map(key => (
                                <option key={key} value={key}>{key.charAt(0).toUpperCase() + key.slice(1)}</option>
                            ))}
                        </select>
                        <select className="palette-select" value={currentPalette} onChange={onPaletteChange}>
                            {Object.keys(colorPalettes).map(key => (
                                <option key={key} value={key}>{key}</option>
                            ))}
                        </select>
                        <button className="icon-button" onClick={() => applyLayout(currentLayout)}>
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                                <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                            </svg>
                            <span className="tooltip">Refresh Layout</span>
                        </button>
                        <button className="icon-button" onClick={fitView}>
                            <span style={{fontSize: '16px', fontWeight: 'bold', display: 'flex', alignItems: 'center', justifyContent: 'center'}}>
                                ⛶
                            </span>
                            <span className="tooltip">Fit to View</span>
                        </button>
                        <button className="icon-button" onClick={toggleAllContainers}>
                            <span style={{fontSize: '16px', fontWeight: 'bold', display: 'flex', alignItems: 'center', justifyContent: 'center'}}>
                                {allContainersCollapsed ? '⊕' : '⊖'}
                            </span>
                            <span className="tooltip">{allContainersCollapsed ? 'Expand All Containers' : 'Collapse All Containers'}</span>
                        </button>
                        <button className="icon-button" onClick={toggleLabelMode}>
                            <span style={{fontSize: '14px', fontWeight: 'bold'}}>
                                {useShortLabels ? '↔' : '→←'}
                            </span>
                            <span className="tooltip">{useShortLabels ? 'Show Full Labels' : 'Show Short Labels'}</span>
                        </button>
                    </div>
                    <UnifiedLegend palette={currentPalette} />
                    <ReactFlow
                        nodes={nodes}
                        edges={edges}
                        onNodesChange={onNodesChange}
                        onEdgesChange={onEdgesChange}
                        onConnect={onConnect}
                        onInit={onInit}
                        onNodeClick={onNodeClick}
                        fitView
                        attributionPosition="bottom-left"
                    >
                        <Controls />
                        <MiniMap />
                        <Background />
                    </ReactFlow>
                </div>
            );
        }

        ReactDOM.render(<HydroGraph />, document.getElementById('root'));
    </script>
</body>
</html>
