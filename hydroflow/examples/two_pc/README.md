## Two Phase Commit
This is a remedial 2PC implementation. 

Design limitations:
- No database logging (just log statements via println)
- No distinction between forced and non-forced logs, no presumed commit/abort optimizations
- No recovery manager implementation (yet)
- Subordinates make random decisions whether to commit or abort

Temporary Implementation limitations:
- With the current absence of groupby, the size of the subordinate set is hardcoded inline
- With the current absence of groupby, counting is done by moving Rust HashMaps and HashSets into map operators

## Dataflow Overview
This was generated by hand. I skipped the `flatten` steps and did not include the body of the `map`s. I also had to rename (number) all the instances of each operator.

We should automate this -- very useful!
### Coordinator
```mermaid
graph TD;
    subgraph demux
    msg_recv-->p1_recv_push;
    msg_recv-->p2_recv_push;
    p1_recv_push-->p1_recv_pull;
    p2_recv_push-->p2_recv_pull;
    end

    subgraph mux
    p1_send_push-->p1_send_pull;
    p1_send_pull-->chain1;
    p2_send_push-->p2_send_pull;
    p2_send_pull-->chain1;
    chain1-->chain2;
    p2_send_end_push-->p2_send_end_pull;
    p2_send_end_pull-->chain2;
    chain2-->msg_send;
    end

    subgraph "fetch subordinates"
    subordinates_in-->subordinates_out;
    subordinates_out-->subordinates_out_tee_1_push;
    subordinates_out-->subordinates_out_tee_2_push;
    subordinates_out-->subordinates_out_tee_3_push;
    subordinates_out_tee_1_push-->subordinates_out_tee_1_pull;
    subordinates_out_tee_2_push-->subordinates_out_tee_2_pull;
    subordinates_out_tee_3_push-->subordinates_out_tee_3_pull;
    end

    subgraph "phase 1 init"
    text_out-->filter_map1-->cross_join1;
    subordinates_out_tee_1_pull-->cross_join1;
    cross_join1-->map1-->pull_to_push1-->push_to1-->p1_send_push;
    end

    subgraph "collect votes and send command"
    p1_recv_pull-->filter_map2-->map2-->cross_join2;
    subordinates_out_tee_2_pull-->cross_join2-->map-->pull_to_push-->push_to-->p2_send_push;
    end

    subgraph "collect acks and end"
    p2_recv_pull-->filter_map3-->map3-->cross_join3;
    subordinates_out_tee_3_pull-->cross_join3-->map4-->pull_to_push2-->push_to2-->p2_send_end_push;
    end
```
### Subordinate
```mermaid
graph TD;
    subgraph demux
    msg_recv-->pull_to_push1-->partition1;
    partition1-->start_tee1-->map1-->push_to1-->p1_recv_push;
    partition1-->start_tee2-->partition2;
    partition2-->start_tee3-->map2-->push_to2-->p2_end_recv_push;
    partition2-->start_tee4-->map3-->push_to3-->p2_recv_push;
    end

    subgraph mux
    p1_send_push-->p1_send_pull;
    p2_resp_push-->p2_resp_pull;
    p1_send_pull-->chain1;
    p2_resp_pull-->chain1-->pull_to_push-->push_to-->msg_send;
    end

    subgraph "p1 request handler"
    p1_recv_push-->p1_recv_pull;
    p1_recv_pull-->map4-->pull_to_push4-->push_to4-->p1_send_push;
    end

    subgraph "p2 command handler"
    p2_recv_push-->p2_recv_pull;
    p2_recv_pull-->map5-->pull_to_push5-->push_to_5-->p2_resp_push;
    end

    subgraph "p2 end handler"
    p2_end_recv_push-->p2_end_recv_pull;
    p2_end_recv_pull-->map6-->pull_to_push6-->foreach;
    end
```
### To Run the code:
Look in the file `members.json` to find the addresses of the coordinator and subordinates. 
For the coordinator, launch a process on the node with a matching IP address as follows.
Here we assume the coordinator's IP address is `localhost` and port `12346` is free:
```
cargo run --example two_pc -- --path hydroflow/examples/two_pc/members.json --role coordinator --port 12346 --addr localhost
```

Now for each subordinate, launch a process on the node with the matching IP address as follows.
Here we assume the subordinate's IP address is `localhost` and port `12349` is free:
```
cargo run --example two_pc -- --path hydroflow/examples/two_pc/members.json --role subordinate --addr localhost --port 12349
```

Now, in the coordinator process you can type an integer at `stdin`. Each integer you type is considered a transaction ID, 
and a two-phase commit process is run for that transaction. Votes to commit or abort are randomized.

You should see logging information on screen at both the coordinator and the subordinates.