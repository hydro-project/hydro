## Two Phase Commit
This is a remedial 2PC implementation. 

Design limitations:
- No database logging (just log statements via println)
- No distinction between forced and non-forced logs, no presumed commit/abort optimizations
- No recovery manager implementation (yet)
- Subordinates make random decisions whether to commit or abort

Temporary Implementation limitations:
- With the current absence of groupby, the size of the subordinate set is hardcoded inline
- With the current absence of groupby, counting is done by moving Rust HashMaps and HashSets into map operators

## Dataflow Overview
This was generated by hand. I skipped the `flatten` steps and did not include the body of the `map`s. I also had to rename (number) all the instances of each operator.

We should automate this -- very useful!
### Coordinator
```mermaid
graph TD;
    subgraph stratum0
        subgraph demux
            msg_recv-->pull_to_push0;
            pull_to_push0-->partition0-->p1_recv_push;
            partition0-->p2_recv_push;
            p1_recv_push-->p1_recv_pull;
            p2_recv_push-->p2_recv_pull;
        end
        subgraph "subordinate count"
            subordinates_out_tee_4_pull-->map_scan20;
            map_scan20-->pull_to_push20-->map20;
            map20-->push_to20-->subordinate_count_1_push;
            subordinate_count_1_push-->subordinate_count_1_pull;
        end
        subgraph "fetch subordinates"
            subordinates_in-->subordinates_out;
            subordinates_out-->tee1;
            tee1-->subordinates_out_tee_1_push;
            tee1-->tee2;
            tee2-->tee3;
            tee2-->subordinates_out_tee_2_push;
            tee3-->subordinates_out_tee_3_push;
            tee3-->subordinates_out_tee_4_push;
            subordinates_out_tee_1_push-->subordinates_out_tee_1_pull;
            subordinates_out_tee_2_push-->subordinates_out_tee_2_pull;
            subordinates_out_tee_3_push-->subordinates_out_tee_3_pull;
            subordinates_out_tee_4_push-->subordinates_out_tee_4_pull;
        end
        subgraph "phase 1 init"
            text_out-->filter_map1-->cross_join1;
            subordinates_out_tee_1_pull-->cross_join1;
            cross_join1-->map1-->pull_to_push1-->push_to1-->p1_send_push;
        end
    end

    subgraph stratum1
        subgraph mux
        p1_send_push-->p1_send_pull;
        p1_send_pull-->chain1;
        p2_send_push-->p2_send_pull;
        p2_send_pull-->chain1;
        chain1-->chain2;
        p2_send_end_push-->p2_send_end_pull;
        p2_send_end_pull-->chain2;
        chain2-->msg_send;
        end

        subgraph "collect votes and send command"
        %% p1_recv_pull-->filter_map2-->map2-->cross_join2;
        p1_recv_pull-->map021-->cross_join02-->filter_map2-->map2-->cross_join2;
        subordinate_count_1_pull-->cross_join02;
        subordinates_out_tee_2_pull-->cross_join2-->map02-->pull_to_push-->push_to-->p2_send_push;
        end

        subgraph "collect acks and end"
        p2_recv_pull-->filter_map3-->map3-->cross_join3;
        subordinates_out_tee_3_pull-->cross_join3-->map4-->pull_to_push2-->push_to2-->p2_send_end_push;
        end
    end
```
### Subordinate
```mermaid
graph TD;
    subgraph demux
    msg_recv-->pull_to_push1-->partition1;
    partition1-->start_tee1-->map1-->push_to1-->p1_recv_push;
    partition1-->start_tee2-->partition2;
    partition2-->start_tee3-->map2-->push_to2-->p2_end_recv_push;
    partition2-->start_tee4-->map3-->push_to3-->p2_recv_push;
    end

    subgraph mux
    p1_send_push-->p1_send_pull;
    p2_resp_push-->p2_resp_pull;
    p1_send_pull-->chain1;
    p2_resp_pull-->chain1-->pull_to_push-->push_to-->msg_send;
    end

    subgraph "p1 request handler"
    p1_recv_push-->p1_recv_pull;
    p1_recv_pull-->map4-->pull_to_push4-->push_to4-->p1_send_push;
    end

    subgraph "p2 command handler"
    p2_recv_push-->p2_recv_pull;
    p2_recv_pull-->map5-->pull_to_push5-->push_to_5-->p2_resp_push;
    end

    subgraph "p2 end handler"
    p2_end_recv_push-->p2_end_recv_pull;
    p2_end_recv_pull-->map6-->pull_to_push6-->foreach;
    end
```
### To Run the code:
Look in the file `members.json` to find the addresses of the coordinator and subordinates. 
For the coordinator, launch a process on the node with a matching IP address as follows.
Here we assume the coordinator's IP address is `localhost` and port `12346` is free:
```
cargo run --example two_pc -- --path hydroflow/examples/two_pc/members.json --role coordinator --port 12346 --addr localhost
```

Now for each subordinate, launch a process on the node with the matching IP address as follows.
Here we assume the subordinate's IP address is `localhost` and port `12349` is free:
```
cargo run --example two_pc -- --path hydroflow/examples/two_pc/members.json --role subordinate --addr localhost --port 12349
```

Now, in the coordinator process you can type an integer at `stdin`. Each integer you type is considered a transaction ID, 
and a two-phase commit process is run for that transaction. Votes to commit or abort are randomized.

You should see logging information on screen at both the coordinator and the subordinates.

Adding the `--graph <graph_type>` flag to the end of the command lines above will print out a node-and-edge diagram of the program. Supported values for `<graph_type>` include [mermaid](https://mermaid-js.github.io/) and [dot](https://graphviz.org/doc/info/lang.html).