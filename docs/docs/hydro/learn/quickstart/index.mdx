import CodeBlock from '@theme/CodeBlock';
import Link from "@docusaurus/Link";
import libRsSrc from '!!raw-loader!../../../../../template/hydro/src/lib.rs';
import { getLines, extractOutput, highlightLines } from '../../../../src/util';

# Quickstart
In this tutorial, you will learn the basics of Hydro by building a keyed counter. You will start by generating a Hydro project from a template. Then, you will create a single counter, and build up to a full key-counter store that partitions its keys across a cluster. Along the way, you will learn the core elements of Hydro, such as live collections, slices, and simulation testing.

On this page, you will start with the Hydro template, which comes with a simple distributed program.

:::learn
- How to use live collections to handle RPC requests and responses
- How to use the `q!` macro to wrap closures and runtime logic
- How to test distributed systems with Hydro's deterministic simulator
:::

## Creating a Hydro Project
Hydro is a Rust framework, so you will need to [install Rust](https://www.rust-lang.org/tools/install). We recommend using `rustup`, which allows you to easily manage and update Rust versions. To generate the template, you should install the `cargo-generate` utility and then expand the template into a folder of our choice.

```bash
#shell-command-next-line
cargo install cargo-generate
#shell-command-next-line
cargo generate gh:hydro-project/hydro-template
# Project Name: my-example-project
#shell-command-next-line
cd my-example-project
```

:::info

Hydro code is written with standard Rust tools. You'll manage dependencies, run tests, and launch Hydro programs using [Cargo](https://doc.rust-lang.org/cargo/), the standard Rust package manager.
We recommend using VS Code with the [**Rust Analyzer**](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer) extension, which provides inline errors and code completion

:::

After `cd`-ing into the generated folder, you can run tests for the included sample:
```bash
#shell-command-next-line
cargo test
```

## Hello World in Hydro
Hydro projects are typically organized into two folders:
- **`src/`** contains the main distributed logic and tests (like regular Rust)
- **`examples/`** contains deployment scripts for launching to the cloud

Let's take a look at the initial Hydro code in `src/lib.rs`, which implements an echo server. The top of the file initializes the project (this only needs to be done once, in `lib.rs`) and imports the Hydro prelude, which includes common Hydro APIs (you will want to do this in each file):
<CodeBlock language="rust" title={
  <Link href="https://github.com/hydro-project/hydro/tree/main/template/hydro/src/lib.rs">src/lib.rs</Link>
} showLineNumbers={1}>{getLines(libRsSrc, 1, 4)}</CodeBlock>

Next, the template defines the echo server function. The server takes in a stream of requests and responds with the text of each request capitalized. Hydro uses a stream programming model, which means that instead of the server taking a single request as a parameter, it takes in a _stream_ of requests that arrive over time. Similarly, the responses are sent back as a stream of values.

<CodeBlock language="rust" title={
  <Link href="https://github.com/hydro-project/hydro/tree/main/template/hydro/src/lib.rs">src/lib.rs</Link>
} showLineNumbers={6}>{getLines(libRsSrc, 6, 9)}</CodeBlock>

There are several things happening in this piece of code. First, let's look at the parameters of the echo server (line 8). The input is a [`Stream`](../../reference/live-collections/streams.md), a [**Live Collection**](../../reference/live-collections/index.md) where new incoming requests arrive over time. The first type parameter, `String`, tells us that each incoming request will appear as a `String` element.

The second type parameter identifies the [**`Location`**](../../reference/locations/index.md) for the live collection. In Hydro, each live collection can be placed on a different [`Process`](../../reference/locations/processes.md) (a single machine) or [`Cluster`](../../reference/locations/clusters.md) (a set of machines). By writing code that involves several locations, you can create a distributed system!

Locations come with a **tag** which help distinguish between multiple processes or clusters. The template defines a `struct EchoServer`, which is the tag for a single server. The input and output streams are both located on `Process<'a, EchoServer>`, which means that the requests will be received on that server and responses will be generated on that server. All locations in a Hydro program have the same lifetime `'a`, which is used to enforce borrowing constraints.

Finally, let us take a look at the function body:
<CodeBlock language="rust" title={
  <Link href="https://github.com/hydro-project/hydro/tree/main/template/hydro/src/lib.rs">src/lib.rs</Link>
} showLineNumbers={7}>{getLines(highlightLines(libRsSrc, [10]), 7, 12)}</CodeBlock>

To process incoming requests, you use the APIs available on live collections. This example uses `map`, which transforms each element of the incoming requests into a element of the outgoing responses. In Hydro, all values and closures passed to such APIs must be **quoted**. Quoting _sends_ the Rust code to a different distributed machine where it will be run. To quote an expression, you wrap it with the `q!` macro.

:::caution

Quoting relies on advanced features of Rust, and can sometimes emit strange type errors. The [Quoting Gotchas](../../reference/stageleft/gotchas.mdx) page covers the limitations of `q!`. For example, to invoke a local function `foo` you must use `self::foo`.

If you forget to wrap an expression in `q!` when that is required, you'll see an error like:
```text
closure is expected to take 5 arguments, but it takes X arguments
```

:::

## Testing with the Simulator
...

## Deploying the Application
...
