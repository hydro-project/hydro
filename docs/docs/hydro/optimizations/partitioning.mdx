---
sidebar_position: 2
---

# Partitioning
Partitioning splits the data on a single location in Hydro across multiple locations by rerouting data based on a partitioning function that we generate.

The challenge of partitioning is finding the right partitioning function on each input such that correctness is preserved.


:::note

Partitioning is always impossible if the recipient of the partitioned node requires a network channel with [`TotalOrder`](https://hydro.run/rustdoc/hydro_lang/stream/enum.TotalOrder).
The combined outputs of different partitions is necessarily out-of-order.
We will assume that the recipient does not require total order below.

:::


## Precursor: Partitioning in Dedalus
The safety of partitioning was initially formalized over [Dedalus](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-173.pdf), a relational algebra based on Datalog.
Dedalus programs are a set of rules, where each rule defines the materialization of joins between relations in order to create new facts.
Rules in Dedalus are analogous to operators in Hydro, relations are streams, and facts are data in those streams.

Partitioning is safe in Dedalus if any pair of facts that would have joined in the original program end up on the same machine in the partitioned program.
This is guaranteed by **partitioning the data based on the join key**, also known as **co-hashing**.

:::info

Partitioning on the join key is actually unnecessarily conservative. Indeed, functional dependencies between keys were known (for example, if key `A` is the `hash` of key `B`), then we could partition according to that dependency instead. See the SIGMOD '24 paper [Optimizing Distributed Protocols with Query Rewrites](https://hydro.run/papers/david-sigmod-2024.pdf) for more information.

:::


## Operator Analysis

Since Hydro supports operators beyond join, we must expand the criteria for partitioning to those new operators.
An operator does not affect partitioning unless it involves simultaneously processing a pair of tuples, or requires comparison across pairs of tuples.

We describe each operator below, whether or not they can be partitioned, and why.
If an operator is entirely independent of any input, i.e. it can be independently derived by each partition, then it is **always** partitionable (regardless of the table below).

| Operator | Partitionable? | Reason |
|----------|----------------|------------|
| [Placeholder](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Placeholder) | ❌ | Should not be in a Hydro program during analysis. |
| [Source](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Source) | ✅ | Has no dependencies on inputs. |
| [CycleSource](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.CycleSource) | ✅ | Single input stream and no interactions between tuples of that stream. |
| [Tee](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Tee) | ✅ | Single input stream and no interactions between tuples of that stream. |
| [Persist](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Persist) | ✅ | Single input stream and no interactions between tuples of that stream. |
| [Unpersist](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Unpersist) | ✅ | Single input stream and no interactions between tuples of that stream. |
| [Delta](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Delta) | ✅ | Equi-joins on the entire tuple, will work with any partitioning scheme. |
| [Chain](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Chain) | ✅ | No interaction between tuples. |
| [CrossProduct](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.CrossProduct) | ❌ | Compares all pairs of tuple across both inputs. |
| [CrossSingleton](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.CrossSingleton) | ❌ | The singleton cannot be partitioned. |
| [Join](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Join) | ⚠️ | Must partition on the join key (or some subset of the join key) of the two inputs. |
| [Difference](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Difference) | ⚠️ | Similar to join but compares the entirety of the two inputs (as opposed to only the join key). Must partition on some attribute of the two inputs. |
| [AntiJoin](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.AntiJoin) | ⚠️ | Similar to join but compares the join key of the 1st input against the entirety of the 2nd input. |
| [ResolveFutures](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.ResolveFutures) | ✅ | Single input stream and no interactions between tuples of that stream. |
| [ResolveFuturesOrdered](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.ResolveFuturesOrdered) | ✅ | Single input stream and no interactions between tuples of that stream. |
| [Map](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Map) | ✅ | Single input stream and no interactions between tuples of that stream. |
| [FlatMap](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.FlatMap) | ✅ | Single input stream and no interactions between tuples of that stream. |
| [Filter](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Filter) | ✅ | Single input stream and no interactions between tuples of that stream. |
| [FilterMap](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.FilterMap) | ✅ | Single input stream and no interactions between tuples of that stream. |
| [DeferTick](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.DeferTick) | ✅ | Single input stream and no interactions between tuples of that stream. |
| [Enumerate](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Enumerate) | ❌ | Requires processing all elements of a stream on a single machine in order to assign a unique, incrementing index. |
| [Inspect](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Inspect) | ✅ | Single input stream and no interactions between tuples of that stream. |
| [Unique](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Unique) | ✅ | Equi-joins on the entire tuple, will work with any partitioning scheme. |
| [Sort](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Sort) | ✅ | Only affects ordering, which we assume does not matter. |
| [Fold](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Fold) | ❌ | Computing the output requires processing all elements of the stream. |
| [FoldKeyed](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.FoldKeyed) | ⚠️ | Must partition on the fold key. |
| [Reduce](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Reduce) | ❌ | Computing the output requires processing all elements of the stream. |
| [ReduceKeyed](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.ReduceKeyed) | ⚠️ | Must partition on the reduce key. |
| [Network](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Network) | ❌ | N/A |
| [Counter](https://hydro.run/rustdoc/hydro_lang/ir/enum.HydroNode#variant.Counter) | ❌ | Should not be in a Hydro program during analysis. |

The implementation of the analysis above can be found in the `partitioning_constraint_analysis_node` function in `partitioning_node_analysis.rs`.


## Partitioning on a specific key
Many of the operators above require partitioning *on a specific key*.
But what does it mean to partition on a key?

It means that whatever partitioning scheme is used:
1. For each single-stream constraint (`FoldKeyed`, `ReduceKeyed`), the input must be partitioned such that any two tuples in that stream with the same key is assigned to the same machine.
2. For each two-stream constraint (`Join`, `Difference`, `AntiJoin`), the input must be partitioned such that tuples in stream 1 and stream 2 that share the same key are assigned to the same machine.

Critically, although the partitioning constraints are defined on *operators*, the partitioning scheme is defined on *inputs*.

Therefore, analysis is necessary in order to translate the constraints on each operator into constraints on inputs and determine if there is a partitioning scheme that simultaneously satisfies all operators' constraints.
Specifically, we need a **mapping** from each operator's constraints to constraints on its inputs' partitioning.


## Input Dependency Analysis
We first consider the task of input dependency analysis assuming, as in Dedalus, that each operator's keys were simply a reordering of its inputs' keys.
Then, a 1:1 equality can be drawn between each operator's keys and its inputs, and the constraints on partitioning can be transferred directly.
This is not the case with the introduction of the `Map` and `FilterMap` operators, which introduce UDFs (User-Defined Functions) that can manipulate data in arbitrary ways.
We will discuss the implications of UDFs and their analysis below in [UDF Analysis](#udf-analysis).

Drawing an equality between an operator's keys and its inputs' keys raises an interesting question: what happens if an operator has multiple inputs?


### Resolving Unions
Consider `Chain`, which combines two streams.
If each parent of `Chain` has different dependencies on the same input, what are the dependencies of `Chain`? What if they have dependencies on different inputs?

#### Unions with Dependencies on the Same Inputs
`Chain`'s dependencies are the **intersection** of the dependencies of its parents for a given input.

Imagine `Chain` then joins with another stream, as in the following program.
```rust
# use hydro_lang::*;
fn chain_parents_same_input<L>(
    flow: FlowBuilder<'_>,
    input1: Stream<(usize, usize), Process<L>, Unbounded>,
    input2: Stream<(usize, usize), Process<L>, Unbounded>,
) {
    let cluster = flow.cluster::<L>();
    let tick = cluster.tick();

    let parent1 = input1.clone();
    let parent2 = input1.map(q!(|(a, b)| (a, b+2)));
    // Both `chain` and `join` are atomic and require `tick_batch`
    unsafe {
        parent1.tick_batch(&tick).chain(parent2.tick_batch(&tick))
            .join(input2.tick_batch(&tick))
            .all_ticks()
            .for_each(q!(|(a, (input1b, input2b))| {
                println!("Joined: {} {} {}", a, input1b, input2b);
            }));
    }
}
```

The program is only partitionable if **both** parents of `Chain` have a 1:1 equality to the input **on the join key**.
In this example, the 0th position of both `parent1` and `parent2`'s tuples depend directly on the 0th position of `input1`; therefore, we can partition on the 0th position of `input1`.

Otherwise, partitioning would not be possible.
If `parent2` is instead initialized to `let parent2 = input1.map(q!(|(a, b)| (b, b+2)))`, then partitioning on the 0th position of `input1` would fail for the following values:
- `input1 = [(2, 1), (1, 2)]`
- `input2 = [(2, 0)]`

The two tuples of `input1` both need to join with the single tuple of `input2`, but they are partitioned to different machines.


#### Unions with Dependencies on Different Inputs
`Chain`'s dependencies are the **union** of the dependencies of its parents across inputs.

Imagine `Chain` then joins with another stream, as in the following program.
```rust
# use hydro_lang::*;
fn chain_parents_different_inputs<L>(
    flow: FlowBuilder<'_>,
    input1: Stream<(usize, usize), Process<L>, Unbounded>,
    input2: Stream<(usize, usize), Process<L>, Unbounded>,
) {
    let cluster = flow.cluster::<L>();
    let tick = cluster.tick();

    let parent1 = input1.map(q!(|(a, b)| (a, b+2)));
    let parent2 = input2.clone().map(q!(|(a, b)| (a, b+2)));
    // Both `chain` and `join` are atomic and require `tick_batch`
    unsafe {
        parent1.tick_batch(&tick).chain(parent2.tick_batch(&tick))
            .join(input2.tick_batch(&tick))
            .all_ticks()
            .for_each(q!(|(a, (input1and2b, input2b))| {
                println!("Joined: {} {} {}", a, input1and2b, input2b);
            }));
    }
}
```

The program is only partitionable if **each** parent of `Chain` has a 1:1 equality to **its** input on the join key.
In this example, the 0th position of `parent1` depends on the 0th position of `input1`, and the 0th position of `parent2` depends directly on the 0th position of `input2`; therefore, we can partition on the 0th position of `input1` and `input2`.

In summary, for union operators (`Chain`), its dependencies are the intersection of its parents' dependencies on the same input, and the union of its parents' dependencies across different inputs.
Partitioning is only possible if it is possible over all inputs that `Chain` depends on.


### Resolving Intersections
We now consider the other operators that have multiple parents.

The output of `Difference` and `AntiJoin` is a subset of their first parent, so they inherit inputdependencies directly from that parent.
This is independent of [Operator Analysis](#operator-analysis) above, where a constraint will be added based on how the parents join.

The output of `CrossProduct` and `CrossSingleton` contains elements of both parents combined into tuples.
The lineage of each tuple element can be directly traced to each parent and its dependencies inherit directly.

THe output of `Join` contains only keys present in both parents.




### Resolving Cycles


## UDF Analysis