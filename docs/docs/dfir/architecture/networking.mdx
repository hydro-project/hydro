---
sidebar_position: 3
---
import CodeBlock from '@theme/CodeBlock';
import echoServerCode from '!!raw-loader!../../../../dfir_rs/examples/echo_server/server.rs';
import tcpEchoServerCode from '!!raw-loader!../../../../dfir_rs/examples/echo_server_tcp/main.rs';
import httpServerCode from '!!raw-loader!../../../../dfir_rs/examples/http_server/server.rs';
import httpClientCode from '!!raw-loader!../../../../dfir_rs/examples/http_server/client.rs';
import { getLines } from '../../../src/util';

# Networking with DFIR

DFIR provides comprehensive networking support for building distributed systems that process data streams over UDP, TCP, and HTTP protocols. This guide covers the fundamental networking patterns and demonstrates how to build servers and clients using DFIR's declarative dataflow programming model.

## Overview

DFIR's networking model follows these key principles:

- **Stream-oriented**: Network data flows as streams through DFIR operators
- **Dataflow Programming**: Network logic is expressed as dataflow graphs
- **Protocol-agnostic**: Similar patterns work across UDP, TCP, and HTTP
- **Error-aware**: Built-in error handling with demux routing
- **Address-aware**: All network operations include source/destination addressing

## Core Networking Patterns

### Basic Server Pattern

Nearly all DFIR network servers follow this pattern:

```
bind_protocol();
source_stream() -> demux() -> processing -> dest_sink()
```

### Basic Client Pattern

Most DFIR network clients follow this pattern:

```
connect_protocol();
source_stream() -> demux() -> processing
```

## UDP Networking

UDP provides connectionless, best-effort message delivery. DFIR's UDP support is ideal for high-throughput, low-latency applications.

### UDP Echo Server

**Source:** [dfir_rs/examples/echo_server/server.rs](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/echo_server/server.rs)

<CodeBlock language="rust" showLineNumbers>{getLines(echoServerCode, 'imports')}</CodeBlock>

UDP servers start by binding to a socket address to create the inbound and outbound streams:

<CodeBlock language="rust" showLineNumbers>{getLines(echoServerCode, 'bind_udp')}</CodeBlock>

The UDP echo server demonstrates the fundamental DFIR networking pattern:

<CodeBlock language="rust" showLineNumbers>{getLines(echoServerCode, 'dfir_flow')}</CodeBlock>

Finally, compile and run the DFIR graph:

<CodeBlock language="rust" showLineNumbers>{getLines(echoServerCode, 'run_server')}</CodeBlock>

Key UDP characteristics:
- **Connectionless**: Each message is independent
- **Best-effort**: No delivery guarantees
- **Low overhead**: Minimal protocol overhead
- **High throughput**: Suitable for streaming data

**Testing:** See [dfir_rs/examples/echo_server/README.md](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/echo_server/README.md) for instructions on running and testing this example.

## TCP Networking

TCP provides reliable, connection-oriented byte streams. DFIR's TCP support handles connection management automatically while exposing a stream-based interface.

### TCP Echo Server

**Source:** [dfir_rs/examples/echo_server_tcp/main.rs](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/echo_server_tcp/main.rs)

<CodeBlock language="rust" showLineNumbers>{getLines(tcpEchoServerCode, 'imports')}</CodeBlock>

#### LocalSet Requirement for TCP Operations

TCP operations in DFIR require the use of tokio's `LocalSet` for specific parts of your application. You don't need to restructure your entire application around LocalSet - you can use it selectively for TCP operations.

**What is LocalSet?**
- LocalSet is a tokio utility that provides a single-threaded execution context for async tasks
- Unlike regular tokio tasks that can run on any thread in the runtime's thread pool, LocalSet tasks are guaranteed to run on the same thread
- This is required because DFIR's TCP implementation uses `spawn_local` internally

**Why TCP needs LocalSet:**
- DFIR's `bind_tcp_bytes`, `bind_tcp_lines`, and related TCP functions use `spawn_local` internally
- `spawn_local` requires being called from within a LocalSet context
- This design choice ensures proper connection state management and thread safety

**Practical Usage Pattern:**
You can use a regular `#[tokio::main]` and wrap only the TCP operations in LocalSet:

<CodeBlock language="rust" showLineNumbers>{getLines(tcpEchoServerCode, 'bind_tcp')}</CodeBlock>

The TCP server processes connection streams through DFIR:

<CodeBlock language="rust" showLineNumbers>{getLines(tcpEchoServerCode, 'dfir_flow')}</CodeBlock>

Finally, compile and run the DFIR graph within the LocalSet context:

<CodeBlock language="rust" showLineNumbers>{getLines(tcpEchoServerCode, 'run_server')}</CodeBlock>

Key TCP characteristics:
- **Connection-oriented**: Explicit connection establishment
- **Reliable**: Guaranteed in-order delivery
- **Flow control**: Automatic congestion management
- **Stateful**: Connection state maintained automatically

**Testing:** See [dfir_rs/examples/echo_server_tcp/README.md](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/echo_server_tcp/README.md) for instructions on running and testing this example.

## HTTP Networking

HTTP builds on TCP to provide request-response semantics with rich metadata. DFIR's HTTP support includes request/response parsing and routing.

**Note:** Like TCP operations, HTTP operations in DFIR also require `LocalSet` for the binding and execution phases since they use the underlying TCP infrastructure. You can use the same selective LocalSet pattern as with TCP.

### HTTP Server

**Source:** [dfir_rs/examples/http_server/server.rs](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/http_server/server.rs)

<CodeBlock language="rust" showLineNumbers>{getLines(httpServerCode, 'imports')}</CodeBlock>

HTTP servers bind to addresses and receive structured requests. Use LocalSet for HTTP operations:

<CodeBlock language="rust" showLineNumbers>{getLines(httpServerCode, 'bind_server')}</CodeBlock>

HTTP request routing uses demux for efficient path-based dispatch:

<CodeBlock language="rust" showLineNumbers>{getLines(httpServerCode, 'route_handlers')}</CodeBlock>

Response generation follows the same patterns:

<CodeBlock language="rust" showLineNumbers>{getLines(httpServerCode, 'response_union')}</CodeBlock>

Finally, run the DFIR graph:

<CodeBlock language="rust" showLineNumbers>{getLines(httpServerCode, 'run_server')}</CodeBlock>

**Testing:** See [dfir_rs/examples/http_server/README.md](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/http_server/README.md) for instructions on running and testing this example.

### HTTP Client

**Source:** [dfir_rs/examples/http_server/client.rs](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/http_server/client.rs)

<CodeBlock language="rust" showLineNumbers>{getLines(httpClientCode, 'imports')}</CodeBlock>

HTTP clients connect and send structured requests. Like servers, clients also require LocalSet:

<CodeBlock language="rust" showLineNumbers>{getLines(httpClientCode, 'connect_client')}</CodeBlock>

Client request processing:

<CodeBlock language="rust" showLineNumbers>{getLines(httpClientCode, 'send_requests')}</CodeBlock>

Response handling with error processing:

<CodeBlock language="rust" showLineNumbers>{getLines(httpClientCode, 'response_processing')}</CodeBlock>

Key HTTP characteristics:
- **Request-response**: Structured message exchange
- **Stateless**: Each request is independent
- **Rich metadata**: Headers, methods, status codes
- **Content-aware**: Body parsing and generation

**Testing:** See [dfir_rs/examples/http_server/README.md](https://github.com/hydro-project/hydro/blob/main/dfir_rs/examples/http_server/README.md) for instructions on running and testing both the server and client examples.

## Error Handling

All DFIR networking uses consistent error handling patterns with demux:

```rust
// UDP error handling
messages = source_stream(socket_recv)
    -> demux(|result, var_args!(success, error)| {
        match result {
            Ok((data, addr)) => success.give((data, addr)),
            Err(e) => error.give(e),
        }
    });

messages[success] -> /* process valid messages */;
messages[error] -> for_each(|e| eprintln!("Error: {}", e));
```

## Address Management

DFIR networking operators always include address information:

- **UDP**: `(data, SocketAddr)` tuples for each packet
- **TCP**: `(data, SocketAddr)` tuples identifying the connection
- **HTTP**: `(HttpRequest/Response, SocketAddr)` tuples with client info

## Performance Considerations

### UDP Performance
- Use `bind_udp_bytes()` for maximum throughput
- Consider message size vs. fragmentation
- Implement application-level reliability if needed

### TCP Performance
- Connection reuse is handled automatically
- Use appropriate buffer sizes for your workload
- Consider connection pooling for high-concurrency clients

### HTTP Performance
- Leverage HTTP keep-alive for connection reuse
- Use appropriate content encoding
- Consider HTTP/2 for multiplexing (future enhancement)

## Advanced Patterns

### Multi-protocol Servers

Single DFIR graphs can handle multiple protocols:

```rust
dfir_syntax! {
    // Combine UDP and TCP streams
    udp_messages = source_stream(udp_recv) -> map(tag_udp);
    tcp_messages = source_stream(tcp_recv) -> map(tag_tcp);
    
    all_messages = union(udp_messages, tcp_messages) -> process_unified;
}
```

### Protocol Composition

DFIR's uniform stream model also enables protocol composition:

```rust
// HTTP over UDP tunnel
udp_stream -> map(parse_http) -> demux(route_requests) -> map(generate_response) -> udp_sink
```


### Load Balancing

DFIR's demux operator easily enables writing simple load balancers
based on hashing or the like.

```rust
// Route by client address
requests -> demux(|(req, addr), var_args!(server1, server2, server3)| {
    match addr.ip().octets()[3] % 3 {
        0 => server1.give((req, addr)),
        1 => server2.give((req, addr)),
        _ => server3.give((req, addr)),
    }
});
```
More complex load balancing would be achieved by computing, say,
runtime statistics, and `match`ing on those as in the pattern above.

## Best Practices

1. **Always handle errors**: Use demux to separate success/error paths
2. **Include addresses**: Maintain client addressing throughout processing
3. **Use appropriate protocols**: UDP for throughput, TCP for reliability, HTTP for structure
4. **Consider backpressure**: DFIR handles flow control automatically
5. **Test incrementally**: Start with simple echo servers and add complexity
6. **Monitor performance**: Use DFIR's built-in observability features

## LocalSet Requirements Summary

Understanding when LocalSet is required for DFIR networking:

| Protocol | LocalSet Required | Reason |
|----------|------------------|---------|
| **UDP** | ❌ No | Uses regular tokio tasks and thread-safe operations |
| **TCP** | ✅ Yes | Internal `spawn_local` usage for connection management |
| **HTTP** | ✅ Yes | Built on TCP infrastructure, inherits LocalSet requirement |

**Canonical LocalSet Usage Pattern:**
```rust
use tokio::task::LocalSet;

#[tokio::main]
async fn main() {
    let addr = "127.0.0.1:3000";
    
    // Single LocalSet scope for both binding and execution
    LocalSet::new().run_until(async move {
        // Step 1: Bind within LocalSet
        let (sink, stream, addr) = dfir_rs::util::bind_tcp_lines(addr).await;
        
        // Step 2: DFIR graph definition
        let mut flow = dfir_syntax! {
            source_stream(stream) -> dest_sink(sink);
        };
        
        // Step 3: Execute within same LocalSet
        flow.run_async().await;
    }).await;
}
```

**Why this matters:**
- LocalSet is only needed for the specific operations that use TCP/HTTP binding and execution
- You don't need to restructure your entire application around LocalSet
- UDP operations work fine in regular tokio contexts
- TCP/HTTP operations will panic at runtime if not within LocalSet context

This networking foundation enables building sophisticated distributed systems with DFIR's declarative, stream-oriented programming model.
