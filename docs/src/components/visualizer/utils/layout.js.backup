/**
 * Simple ELK Layout Integration
 * 
 * Provides graph layout using ELK algorithms with centralized configuration from elkConfig.js
 */

import { createELKStateManager } from './elkStateManager.js';
import { filterNodesByType, filterNodesByParent, filterNodesExcludingType } from './constants.js';

let ELK = null;

// Cache for storing original expanded container dimensions
// This ensures we always use the correct expanded dimensions for layout calculations
const containerDimensionsCache = new Map();

// Create ELK state manager instance
const elkStateManager = createELKStateManager();

/**
 * Central Visual State Management
 * This structure contains all the mutable visual state for the visualizer
 */
class VisualState {
  constructor() {
    this.containers = new Map(); // containerId -> 'expanded' | 'collapsed' | 'hidden'
    this.nodes = new Map();      // nodeId -> 'visible' | 'hidden'
    this.edges = new Map();      // edgeId -> 'visible' | 'hidden'
    this.dimensionsCache = containerDimensionsCache; // Reference to shared cache
  }

  setContainerState(containerId, state) {
    if (!['expanded', 'collapsed', 'hidden'].includes(state)) {
      throw new Error(`Invalid container state '${state}'. Must be 'expanded', 'collapsed', or 'hidden'.`);
    }
    this.containers.set(containerId, state);
  }

  setNodeState(nodeId, state) {
    if (!['visible', 'hidden'].includes(state)) {
      throw new Error(`Invalid node state '${state}'. Must be 'visible' or 'hidden'.`);
    }
    this.nodes.set(nodeId, state);
  }

  setEdgeState(edgeId, state) {
    if (!['visible', 'hidden'].includes(state)) {
      throw new Error(`Invalid edge state '${state}'. Must be 'visible' or 'hidden'.`);
    }
    this.edges.set(edgeId, state);
  }

  getContainerState(containerId) {
    return this.containers.get(containerId) || 'expanded'; // Default to expanded
  }

  getNodeState(nodeId) {
    return this.nodes.get(nodeId) || 'visible'; // Default to visible
  }

  getEdgeState(edgeId) {
    return this.edges.get(edgeId) || 'visible'; // Default to visible
  }

  // Convert to the object format for backward compatibility
  toContainerStatesObject() {
    const obj = {};
    this.containers.forEach((state, id) => {
      obj[id] = state;
    });
    return obj;
  }
}

// Load ELK dynamically - keeping for backward compatibility
async function loadELK() {
  if (ELK) return ELK;
  
  try {
    const elkModule = await import('elkjs');
    ELK = new elkModule.default();
    return ELK;
  } catch (error) {
    console.error('Failed to load ELK:', error);
    return null;
  }
}

export async function applyLayout(nodes, edges, layoutType = 'mrtree') {
  console.log(`[Layout] ðŸš€ APPLY_LAYOUT: Using ELK state manager for full layout`);
  
  try {
    const result = await elkStateManager.calculateFullLayout(nodes, edges, layoutType);
    
    // CRITICAL: Cache the expanded dimensions of all group nodes for later use
    // This ensures we always have the correct expanded dimensions for layout calculations
    result.nodes.forEach(node => {
      if (node.type === 'group') {
        console.log(`[Layout] ðŸ’¾ CACHING: ${node.id} â†’ ${node.width}x${node.height}`);
        containerDimensionsCache.set(node.id, {
          width: node.width,
          height: node.height
        });
      }
    });
    
    return result;
  } catch (error) {
    console.error('[Layout] applyLayout failed:', error);
    throw error;
  }
}

/**
 * Apply layout readjustment for collapsed containers only
 * This function will only reposition containers while keeping other nodes fixed
 */
export async function applyLayoutForCollapsedContainers(displayNodes, edges, layoutType = 'mrtree', changedContainerId = null) {
  console.log(`[Layout] ðŸ”„ CONTAINER_LAYOUT: Using ELK state manager for container repositioning`);
  
  try {
    return await elkStateManager.calculateContainerRepositioning(displayNodes, edges, layoutType, changedContainerId);
  } catch (error) {
    console.error('[Layout] Container layout failed:', error);
    return { nodes: displayNodes, edges }; // Fallback to original
  }
}

/**
 * Central Visual Layout Coordinator
 * This is the single source of truth for what ELK sees and how visual elements are arranged.
 * Handles all visual state filtering and applies layout based on explicit state declarations.
 * 
 * @param {Array} allNodes - All nodes in the graph (before filtering)
 * @param {Array} allEdges - All edges in the graph (before filtering) 
 * @param {VisualState|Object} visualState - Central visual state or legacy container states object
 * @param {string} layoutType - Layout algorithm type
 * @returns {Object} { nodes, edges } - Filtered and positioned visual elements
 */
export async function layoutVisualElements(
  allNodes, 
  allEdges, 
  visualState, 
  layoutType = 'mrtree'
) {
  console.log(`[Layout] ðŸŽ¯ VISUAL_COORDINATOR: Starting layout with ELK state manager`);
  
  // Handle backward compatibility - convert legacy object to VisualState
  let state;
  if (visualState instanceof VisualState) {
    state = visualState;
  } else {
    // Legacy mode: create VisualState from containerStates object
    state = new VisualState();
    Object.entries(visualState).forEach(([containerId, containerState]) => {
      state.setContainerState(containerId, containerState);
    });
    // Default all nodes and edges to visible in legacy mode
    allNodes.forEach(node => {
      if (node.type !== 'group') { // Don't set state for containers, already handled above
        state.setNodeState(node.id, 'visible');
      }
    });
    allEdges.forEach(edge => state.setEdgeState(edge.id, 'visible'));
  }

  try {
    // Use ELK state manager to calculate layout based on visual state
    const elkResult = await elkStateManager.calculateVisualLayout(
      allNodes, 
      allEdges, 
      state, 
      layoutType, 
      containerDimensionsCache
    );
    
    console.log(`[Layout] ðŸŽ¯ VISUAL_COORDINATOR: ELK calculation complete`);

  // STEP 1: Filter nodes based on visual state
  console.log(`[Layout] ðŸ” VISUAL COORDINATOR: Filtering nodes based on state...`);
  const visibleNodes = allNodes.filter(node => {
    if (node.type === 'group' || node.type === 'collapsedContainer') {
      const containerState = state.getContainerState(node.id);
      if (containerState === 'hidden') {
        console.log(`[Layout] ï¿½ VISUAL COORDINATOR: Container ${node.id} â†’ HIDDEN (filtered out)`);
        return false;
      }
      return true;
    } else {
      const nodeState = state.getNodeState(node.id);
      if (nodeState === 'hidden') {
        console.log(`[Layout] ðŸ‘» VISUAL COORDINATOR: Node ${node.id} â†’ HIDDEN (filtered out)`);
        return false;
      }
      return true;
    }
  });

  // STEP 2: Filter edges based on visual state AND node visibility
  console.log(`[Layout] ðŸ”— VISUAL COORDINATOR: Filtering edges based on state and node visibility...`);
  const visibleNodeIds = new Set(visibleNodes.map(node => node.id));
  const visibleEdges = allEdges.filter(edge => {
    // First check edge's own visibility state
    const edgeState = state.getEdgeState(edge.id);
    if (edgeState === 'hidden') {
      console.log(`[Layout] ðŸ‘» VISUAL COORDINATOR: Edge ${edge.id} â†’ HIDDEN (filtered out)`);
      return false;
    }
    
    // Then check if both source and target nodes are visible
    const sourceVisible = visibleNodeIds.has(edge.source);
    const targetVisible = visibleNodeIds.has(edge.target);
    
    if (!sourceVisible || !targetVisible) {
      console.log(`[Layout] ðŸ”— VISUAL COORDINATOR: Edge ${edge.id} â†’ FILTERED (source:${sourceVisible}, target:${targetVisible})`);
      return false;
    }
    
    return true;
  });

  // Find container nodes for positioning
  const containerNodes = visibleNodes.filter(node => 
    node.type === 'group' || node.type === 'collapsedContainer'
  );
  
  if (containerNodes.length === 0) {
    console.log(`[Layout] âš ï¸ VISUAL COORDINATOR: No containers to layout`);
    return { nodes: visibleNodes, edges: visibleEdges };
  }

  // STEP 3: Validate that all containers have explicit states
  containerNodes.forEach(container => {
    const containerState = state.getContainerState(container.id);
    if (!['expanded', 'collapsed'].includes(containerState)) {
      throw new Error(`Container ${container.id} has invalid state '${containerState}'. Must specify 'expanded' or 'collapsed'.`);
    }
  });

  // STEP 4: Set dimensions based on explicit states
  console.log(`[Layout] ðŸ“ VISUAL COORDINATOR: Setting dimensions based on explicit states...`);
  const containersWithExplicitDimensions = containerNodes.map(container => {
    const containerState = state.getContainerState(container.id);
    let width, height;
    
    if (containerState === 'collapsed') {
      width = 180;
      height = 60;
      console.log(`[Layout] âŒ VISUAL COORDINATOR: ${container.id} â†’ COLLAPSED (${width}x${height})`);
    } else if (containerState === 'expanded') {
      const cachedDimensions = state.dimensionsCache.get(container.id);
      if (!cachedDimensions) {
        throw new Error(`Container ${container.id} requested as 'expanded' but no cached dimensions found`);
      }
      width = cachedDimensions.width;
      height = cachedDimensions.height;
      console.log(`[Layout] âœ… VISUAL COORDINATOR: ${container.id} â†’ EXPANDED (${width}x${height}) from cache`);
    }
    
    return {
      ...container,
      width: width,
      height: height,
      style: {
        ...container.style,
        width: width,
        height: height,
      }
    };
  });

  // STEP 5: Create ELK nodes - all free positioning since we're being explicit about dimensions
  console.log(`[Layout] ðŸ—ï¸ VISUAL COORDINATOR: Creating ELK nodes with explicit dimensions...`);
  const elkContainers = containersWithExplicitDimensions.map(container => ({
    id: container.id,
    width: container.width,
    height: container.height,
    layoutOptions: createFreePositionOptions() // Let ELK find optimal positions
  }));

  // STEP 5.5: Pre-calculate rerouted edges for ELK to consider during layout
  console.log(`[Layout] ðŸ”— VISUAL COORDINATOR: Pre-calculating rerouted edges for ELK...`);
  const { transformAndRerouteEdges: preRouteEdges, transformNodes: preTransformNodes } = createVisualFilters(state);
  
  // Transform nodes to get preliminary collapsed state
  const preliminaryTransformedNodes = preTransformNodes(visibleNodes);
  const preliminaryVisibleNodes = preliminaryTransformedNodes.filter(node => !node.hidden);
  
  // Get preliminary rerouted edges
  const preliminaryReroutedEdges = preRouteEdges(allEdges, allNodes, preliminaryVisibleNodes);
  
  // Convert to ELK edge format
  const elkEdges = preliminaryReroutedEdges.map(edge => ({
    id: edge.id,
    sources: [edge.source],
    targets: [edge.target],
  }));
  
  console.log(`[Layout] ðŸ”— VISUAL COORDINATOR: ${elkEdges.length} edges for ELK layout`);

  // Create ELK graph with edges for proper container positioning
  const elkGraph = {
    id: 'visual_coordinator_root',
    layoutOptions: getContainerELKConfig(layoutType, 'collapsed'),
    children: elkContainers,
    edges: elkEdges // Include edges so ELK can optimize container positions
  };

  // LOG ELK INPUT
  console.log(`[Layout] ðŸŽ¯ VISUAL COORDINATOR - ELK INPUT:`);
  elkContainers.forEach(container => {
    console.log(`[Layout] ðŸŽ¯ VISUAL COORDINATOR: ${container.id}: ${container.width}x${container.height}`);
  });

  try {
    console.log(`[Layout] ðŸš€ VISUAL COORDINATOR: Calling ELK layout...`);
    const layoutResult = await elk.layout(elkGraph);
    console.log(`[Layout] âœ… VISUAL COORDINATOR: ELK layout completed successfully`);
    
    // DEBUG: Log complete ELK output
    console.log(`[Layout] ðŸ” ELK OUTPUT - Complete layout result:`);
    if (layoutResult.children) {
      console.log(`[Layout] ðŸ” ELK NODES:`);
      layoutResult.children.forEach(node => {
        console.log(`[Layout] ðŸ”   Node ${node.id}: x=${node.x}, y=${node.y}, w=${node.width}, h=${node.height}`);
      });
    }
    if (layoutResult.edges) {
      console.log(`[Layout] ðŸ” ELK EDGES:`);
      layoutResult.edges.forEach(edge => {
        console.log(`[Layout] ðŸ”   Edge ${edge.id}: ${edge.sources} -> ${edge.targets}`);
        if (edge.sections) {
          console.log(`[Layout] ðŸ”     Sections (${edge.sections.length}):`);
          edge.sections.forEach((section, i) => {
            console.log(`[Layout] ðŸ”       Section ${i}: start=(${section.startPoint?.x},${section.startPoint?.y}) end=(${section.endPoint?.x},${section.endPoint?.y})`);
            if (section.bendPoints && section.bendPoints.length > 0) {
              console.log(`[Layout] ðŸ”       Bend points:`, section.bendPoints.map(bp => `(${bp.x},${bp.y})`).join(', '));
            }
          });
        }
      });
    } else {
      console.log(`[Layout] ðŸ” ELK EDGES: No edge routing information provided by ELK`);
    }
    
    // Apply new positions to all container nodes
    console.log(`[Layout] ðŸŽ¨ VISUAL COORDINATOR: Applying new positions...`);
    const updatedNodes = visibleNodes.map(node => {
      if (node.type === 'group' || node.type === 'collapsedContainer') {
        const elkContainer = layoutResult.children?.find(c => c.id === node.id);
        if (elkContainer) {
          return {
            ...node,
            position: {
              x: elkContainer.x || node.position.x,
              y: elkContainer.y || node.position.y
            }
          };
        }
      }
      return node;
    });
    
    console.log(`[Layout] ðŸ VISUAL COORDINATOR: Layout complete. Visible nodes: ${updatedNodes.length}, Visible edges: ${visibleEdges.length}`);
    
    // STEP 6: Reroute edges based on final positioned nodes and ELK routing
    console.log(`[Layout] ðŸ”— VISUAL COORDINATOR: Rerouting edges for positioned containers...`);
    const { transformAndRerouteEdges, transformNodes } = createVisualFilters(state);
    
    // Transform nodes to apply collapsed state (hide child nodes, transform containers)
    const transformedNodes = transformNodes(updatedNodes);
    
    // Apply ELK-calculated dimensions to collapsed containers
    const transformedNodesWithELKDimensions = transformedNodes.map(node => {
      if (node.type === 'collapsedContainer') {
        // Find the ELK-calculated dimensions for this container
        const elkContainer = layoutResult.children?.find(c => c.id === node.id);
        if (elkContainer) {
          return {
            ...node,
            width: elkContainer.width,
            height: elkContainer.height,
            style: {
              ...node.style,
              width: elkContainer.width,
              height: elkContainer.height,
            }
          };
        }
      }
      return node;
    });
    
    // Only use nodes that are actually visible (not hidden by collapsed parents)
    const finalVisibleNodes = transformedNodesWithELKDimensions.filter(node => !node.hidden);
    
    console.log(`[Layout] ðŸŽ¯ FINAL NODES DEBUG: ${finalVisibleNodes.length} final visible nodes:`);
    finalVisibleNodes.forEach(node => {
      console.log(`[Layout] ðŸŽ¯ FINAL NODE: ${node.id} (type: ${node.type}, pos: ${node.position?.x || 0},${node.position?.y || 0}, size: ${node.width || '?'}x${node.height || '?'})`);
      if (node.parentId) {
        console.log(`[Layout] ðŸŽ¯   Parent: ${node.parentId}`);
      }
    });
    
    console.log(`[Layout] ðŸŽ¯ TRANSFORMED NODES DEBUG: ${transformedNodesWithELKDimensions.length} total transformed nodes:`);
    transformedNodesWithELKDimensions.forEach(node => {
      console.log(`[Layout] ðŸŽ¯ TRANSFORMED: ${node.id} (type: ${node.type}, hidden: ${node.hidden}, parent: ${node.parentId || 'none'})`);
    });
    
    // Create a map of ELK edge routing information
    const elkEdgeRouting = new Map();
    if (layoutResult.edges) {
      layoutResult.edges.forEach(elkEdge => {
        elkEdgeRouting.set(elkEdge.id, elkEdge);
      });
    }
    
    const reroutedEdges = transformAndRerouteEdges(allEdges, allNodes, finalVisibleNodes, elkEdgeRouting);
    
    console.log(`[Layout] ðŸŽ¯ FINAL EDGES DEBUG: ${reroutedEdges.length} rerouted edges:`);
    reroutedEdges.forEach(edge => {
      console.log(`[Layout] ðŸŽ¯ FINAL EDGE: ${edge.id} (${edge.source} -> ${edge.target})`);
      console.log(`[Layout] ðŸŽ¯ EDGE HANDLES: source=${edge.sourceHandle}, target=${edge.targetHandle}`);
      if (edge.data?.elkRouting) {
        console.log(`[Layout] ðŸŽ¯ EDGE ROUTING: ELK path data included`);
      }
      console.log(`[Layout] ðŸŽ¯ EDGE DATA:`, edge.data);
    });
    
    return {
      nodes: finalVisibleNodes,
      edges: reroutedEdges,
    };
  } catch (error) {
    console.error(`[Layout] âŒ VISUAL COORDINATOR FAILED:`, error);
    return { nodes: visibleNodes, edges: visibleEdges };
  }
}

/**
 * Clear the container dimensions cache when graph data changes
 * This should be called whenever new graph data is loaded
 */
export function clearContainerDimensionsCache() {
  containerDimensionsCache.clear();
}

/**
 * Create a new VisualState instance
 * @returns {VisualState} New visual state manager
 */
export function createVisualState() {
  return new VisualState();
}

/**
 * Create VisualState from nodes/edges with default visible states
 * @param {Array} nodes - All nodes in the graph
 * @param {Array} edges - All edges in the graph
 * @param {Object} containerStates - Initial container states (optional)
 * @returns {VisualState} Initialized visual state
 */
export function createVisualStateFromGraph(nodes, edges, containerStates = {}) {
  const state = new VisualState();
  
  // Set container states
  nodes
    .filter(node => node.type === 'group' || node.type === 'collapsedContainer')
    .forEach(container => {
      const containerState = containerStates[container.id] || 'expanded';
      state.setContainerState(container.id, containerState);
    });
  
  // Set all regular nodes as visible by default
  nodes
    .filter(node => node.type !== 'group' && node.type !== 'collapsedContainer')
    .forEach(node => {
      state.setNodeState(node.id, 'visible');
    });
  
  // Set all edges as visible by default
  edges.forEach(edge => {
    state.setEdgeState(edge.id, 'visible');
  });
  
  return state;
}

/**
 * Create a common visual element filter function
 * This can be reused by both ELK and ReactFlow rendering
 * @param {VisualState} visualState - Central visual state
 * @returns {Object} { filterNodes, filterEdges, transformNodes } - Filter and transform functions
 */
export function createVisualFilters(visualState) {
  return {
    filterNodes: (nodes) => {
      return nodes.filter(node => {
        if (node.type === 'group' || node.type === 'collapsedContainer') {
          return visualState.getContainerState(node.id) !== 'hidden';
        } else {
          return visualState.getNodeState(node.id) !== 'hidden';
        }
      });
    },
    
    filterEdges: (edges, visibleNodeIds) => {
      const nodeSet = new Set(visibleNodeIds);
      return edges.filter(edge => {
        // Check edge's own visibility
        if (visualState.getEdgeState(edge.id) === 'hidden') {
          return false;
        }
        // Check if both endpoints are visible
        return nodeSet.has(edge.source) && nodeSet.has(edge.target);
      });
    },
    
    transformAndRerouteEdges: (edges, nodes, transformedNodes, elkEdgeRouting = null) => {
      // Build maps for efficient lookups
      const nodeMap = new Map(nodes.map(node => [node.id, node]));
      const transformedNodeMap = new Map(transformedNodes.map(node => [node.id, node]));
      const visibleNodeIds = new Set(transformedNodes.filter(node => !node.hidden).map(node => node.id));
      
      console.log(`[Layout] ðŸ”— EDGE REROUTING: Processing ${edges.length} edges, ${visibleNodeIds.size} visible nodes`);
      
      // Helper function to find the top-level visible container for a node
      function findVisibleContainer(nodeId, visited = new Set()) {
        if (visited.has(nodeId)) return null; // Prevent infinite loops
        visited.add(nodeId);
        
        const node = nodeMap.get(nodeId);
        if (!node) return null;
        
        // If this node is visible, return it
        if (visibleNodeIds.has(nodeId)) {
          return nodeId;
        }
        
        // If this node has a parent, check if the parent is a collapsed container
        if (node.parentId) {
          const parent = nodeMap.get(node.parentId);
          if (parent && (parent.type === 'group' || parent.type === 'collapsedContainer')) {
            const parentState = visualState.getContainerState(parent.id);
            if (parentState === 'collapsed' && visibleNodeIds.has(parent.id)) {
              return parent.id; // Parent is collapsed and visible
            }
          }
          // Recursively check parent's container
          return findVisibleContainer(node.parentId, visited);
        }
        
        return null;
      }
      
      const reroutedEdges = [];
      const edgeSet = new Set(); // To prevent duplicate edges
      
      edges.forEach(edge => {
        // Check edge's own visibility
        if (visualState.getEdgeState(edge.id) === 'hidden') {
          return;
        }
        
        const sourceContainer = findVisibleContainer(edge.source);
        const targetContainer = findVisibleContainer(edge.target);
        
        console.log(`[Layout] ðŸ”— EDGE: ${edge.source} -> ${edge.target} | Containers: ${sourceContainer} -> ${targetContainer}`);
        
        // Only include edge if both endpoints have visible containers
        if (sourceContainer && targetContainer) {
          const newSource = sourceContainer;
          const newTarget = targetContainer;
          
          // Avoid self-loops
          if (newSource === newTarget) {
            console.log(`[Layout] ðŸ”— SKIP: Self-loop ${newSource} -> ${newTarget}`);
            return;
          }
          
          // Create unique edge ID to prevent duplicates
          const edgeKey = `${newSource}->${newTarget}`;
          if (!edgeSet.has(edgeKey)) {
            edgeSet.add(edgeKey);
            
            // Check if we have ELK routing information for this edge
            // Use clean edge ID format to avoid collision
            const reroutedEdgeId = `${edge.id.split('_rerouted_')[0]}_rerouted_${newSource}_${newTarget}`;
            const elkRouting = elkEdgeRouting?.get(reroutedEdgeId);
            
            const reroutedEdge = {
              ...edge,
              id: reroutedEdgeId,
              source: newSource,
              target: newTarget,
              sourceHandle: edge.sourceHandle || 'source', // Preserve original handle or default to 'source'
              targetHandle: edge.targetHandle || 'target', // Preserve original handle or default to 'target'
              data: {
                ...edge.data,
                isRerouted: true,
                originalSource: edge.source,
                originalTarget: edge.target,
                originalSourceHandle: edge.sourceHandle,
                originalTargetHandle: edge.targetHandle,
                // Include ELK routing information if available
                ...(elkRouting && {
                  elkRouting: {
                    sections: elkRouting.sections,
                    // Extract routing coordinates for ReactFlow
                    pathData: elkRouting.sections?.map(section => ({
                      startPoint: section.startPoint,
                      endPoint: section.endPoint,
                      bendPoints: section.bendPoints || []
                    }))
                  },
                  // Convert ELK routing to ReactFlow-compatible path
                  ...(elkRouting.sections && elkRouting.sections.length > 0 && {
                    style: {
                      strokeDasharray: '0', // Ensure solid line
                    },
                    // Add path points that ReactFlow can use
                    data: {
                      ...edge.data,
                      elkPath: elkRouting.sections[0], // Use first section
                      customPath: true,
                      // Convert ELK coordinates to ReactFlow path
                      pathPoints: elkRouting.sections[0].bendPoints || []
                    }
                  })
                })
              }
            };
            
            console.log(`[Layout] ðŸ”— REROUTED: ${reroutedEdge.id}${elkRouting ? ' (with ELK routing)' : ''}`);
            reroutedEdges.push(reroutedEdge);
          }
        }
      });
      
      console.log(`[Layout] ðŸ”— EDGE REROUTING COMPLETE: ${reroutedEdges.length} rerouted edges`);
      return reroutedEdges;
    },
    
    transformNodes: (nodes) => {
      return nodes.map(node => {
        // Transform containers based on their state
        if (node.type === 'group' || node.type === 'collapsedContainer') {
          const containerState = visualState.getContainerState(node.id);
          
          if (containerState === 'collapsed') {
            // Transform to collapsed container but preserve ELK-calculated dimensions
            return {
              ...node,
              type: 'collapsedContainer',
              // Keep the original width/height from ELK positioning - don't override with hardcoded values
              data: {
                ...node.data,
                label: node.data?.label || node.id,
                // Add node count if available
                nodeCount: countChildNodes(node.id, nodes)
              },
              hidden: false
            };
          } else if (containerState === 'expanded') {
            // Transform to expanded group - preserve ELK dimensions
            return {
              ...node,
              type: 'group',
              hidden: false
            };
          }
        }
        
        // For child nodes, check if their parent is collapsed
        if (node.parentId) {
          const parentState = visualState.getContainerState(node.parentId);
          if (parentState === 'collapsed') {
            console.log(`[Layout] ðŸŽ¯ TRANSFORM: Child node ${node.id} â†’ HIDDEN (parent ${node.parentId} is collapsed)`);
            return {
              ...node,
              hidden: true
            };
          } else {
            // Parent is expanded, so child should be visible
            console.log(`[Layout] ðŸŽ¯ TRANSFORM: Child node ${node.id} â†’ VISIBLE (parent ${node.parentId} is expanded)`);
            return {
              ...node,
              hidden: false
            };
          }
        }
        
        // Regular nodes without parents are always visible
        console.log(`[Layout] ðŸŽ¯ TRANSFORM: Regular node ${node.id} â†’ VISIBLE (no parent)`);
        return {
          ...node,
          hidden: false
        };
      });
    }
  };
}

// Helper function to count child nodes
function countChildNodes(containerId, nodes) {
  let count = 0;
  nodes.forEach(node => {
    if (node.parentId === containerId) {
      if (node.type === 'group') {
        // Recursively count child nodes in nested containers
        count += countChildNodes(node.id, nodes);
      } else {
        count += 1;
      }
    }
  });
  return count;
}

// Export the VisualState class for external use
export { VisualState };
